
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Keraunos PCIE Tile SystemC/TLM2.0 Testplan &#8212; Keraunos PCIe Tile v1.0</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="https://unpkg.com/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script>
mermaid.initialize({
    startOnLoad: true,
    theme: 'default',
    securityLevel: 'loose',
    flowchart: {
        useMaxWidth: true,
        htmlLabels: true,
        curve: 'basis',
        nodeSpacing: 70,
        rankSpacing: 70,
        padding: 20
    },
    fontSize: 16,
    themeVariables: {
        fontSize: '16px',
        primaryColor: '#e1f5ff',
        primaryTextColor: '#000',
        primaryBorderColor: '#3498db',
        lineColor: '#2c3e50',
        secondaryColor: '#fff4e1',
        tertiaryColor: '#ffe1f5'
    }
});
</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Keraunos PCIE Tile SystemC/TLM2.0 Design Document" href="systemc_design.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Keraunos PCIe Tile</a></h1>



<p class="blurb">SystemC/TLM2.0 PCIe Tile Design and Verification</p>






<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Design Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="hld.html">Keraunos PCIe Tile - High-Level Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="systemc_design.html">Keraunos PCIE Tile SystemC/TLM2.0 Design Document</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Verification Documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Keraunos PCIE Tile SystemC/TLM2.0 Testplan</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#table-of-contents">Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="#introduction">1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#test-traceability-matrix">1.5 Test Traceability Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="#test-environment">2. Test Environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="#test-strategy">3. Test Strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inbound-tlb-test-cases">4. Inbound TLB Test Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#outbound-tlb-test-cases">5. Outbound TLB Test Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#msi-relay-unit-test-cases">6. MSI Relay Unit Test Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#integration-test-cases">7. Integration Test Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#switch-test-cases">8. Switch Test Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sii-block-test-cases">9. SII Block Test Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#config-register-block-test-cases">10. Config Register Block Test Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#clock-reset-test-cases">11. Clock &amp; Reset Test Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pll-cgm-test-cases">12. PLL/CGM Test Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pcie-phy-test-cases">13. PCIE PHY Test Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#external-interface-test-cases">14. External Interface Test Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#top-level-integration-test-cases">15. Top-Level Integration Test Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#end-to-end-test-cases">16. End-to-End Test Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coverage-goals">17. Coverage Goals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">16. Coverage Goals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#test-infrastructure">17. Test Infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#regression-testing">18. Regression Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#appendix-a-unit-integration-test-case-summary-sections-4-15">Appendix A: Unit/Integration Test Case Summary (Sections 4-15)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#appendix-a-2-end-to-end-test-case-summary-section-16-implemented-in-keranous-pcie-tiletest-cc">Appendix A.2: End-to-End Test Case Summary (Section 16) — Implemented in <code class="docutils literal notranslate"><span class="pre">Keranous_pcie_tileTest.cc</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#appendix-b-test-execution-plan">Appendix B: Test Execution Plan</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="systemc_design.html" title="previous chapter">Keraunos PCIE Tile SystemC/TLM2.0 Design Document</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section class="tex2jax_ignore mathjax_ignore" id="keraunos-pcie-tile-systemc-tlm2-0-testplan">
<h1>Keraunos PCIE Tile SystemC/TLM2.0 Testplan<a class="headerlink" href="#keraunos-pcie-tile-systemc-tlm2-0-testplan" title="Permalink to this heading">¶</a></h1>
<p><strong>Version:</strong> 2.0<br />
<strong>Date:</strong> 2025-01-XX<br />
<strong>Author:</strong> Verification Team<br />
<strong>Based on:</strong> Keraunos PCIE Tile Specification v0.7.023<br />
<strong>Updated:</strong> Added test cases for all new IP blocks (switches, SII, config regs, clock/reset, PHY, external interfaces, top-level integration)</p>
<hr class="docutils" />
<section id="table-of-contents">
<h2>Table of Contents<a class="headerlink" href="#table-of-contents" title="Permalink to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p><a class="reference external" href="#1-introduction">Introduction</a></p></li>
<li><p><a class="reference external" href="#2-test-environment">Test Environment</a></p></li>
<li><p><a class="reference external" href="#3-test-strategy">Test Strategy</a></p></li>
<li><p><a class="reference external" href="#4-inbound-tlb-test-cases">Inbound TLB Test Cases</a></p></li>
<li><p><a class="reference external" href="#5-outbound-tlb-test-cases">Outbound TLB Test Cases</a></p></li>
<li><p><a class="reference external" href="#6-msi-relay-unit-test-cases">MSI Relay Unit Test Cases</a></p></li>
<li><p><a class="reference external" href="#7-integration-test-cases">Integration Test Cases</a></p></li>
<li><p><a class="reference external" href="#8-switch-test-cases">Switch Test Cases</a></p></li>
<li><p><a class="reference external" href="#9-sii-block-test-cases">SII Block Test Cases</a></p></li>
<li><p><a class="reference external" href="#10-config-register-block-test-cases">Config Register Block Test Cases</a></p></li>
<li><p><a class="reference external" href="#11-clock--reset-test-cases">Clock &amp; Reset Test Cases</a></p></li>
<li><p><a class="reference external" href="#12-pllcgm-test-cases">PLL/CGM Test Cases</a></p></li>
<li><p><a class="reference external" href="#13-pcie-phy-test-cases">PCIE PHY Test Cases</a></p></li>
<li><p><a class="reference external" href="#14-external-interface-test-cases">External Interface Test Cases</a></p></li>
<li><p><a class="reference external" href="#15-top-level-integration-test-cases">Top-Level Integration Test Cases</a></p></li>
<li><p><a class="reference external" href="#16-end-to-end-test-cases">End-to-End Test Cases</a></p></li>
<li><p><a class="reference external" href="#17-coverage-goals">Coverage Goals</a></p></li>
<li><p><a class="reference external" href="#18-test-infrastructure">Test Infrastructure</a></p></li>
<li><p><a class="reference external" href="#19-regression-testing">Regression Testing</a></p></li>
</ol>
</section>
<hr class="docutils" />
<section id="introduction">
<h2>1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<section id="purpose">
<h3>1.1 Purpose<a class="headerlink" href="#purpose" title="Permalink to this heading">¶</a></h3>
<p>This testplan defines comprehensive test cases for verifying the SystemC/TLM2.0 implementation of:</p>
<ul class="simple">
<li><p><strong>Inbound TLBs</strong> (TLBSysIn0, TLBAppIn0, TLBAppIn1)</p></li>
<li><p><strong>Outbound TLBs</strong> (TLBSysOut0, TLBAppOut0, TLBAppOut1)</p></li>
<li><p><strong>MSI Relay Unit</strong></p></li>
<li><p><strong>Intra-Tile Fabric Switches</strong> (NOC-PCIE, NOC-IO, SMN-IO)</p></li>
<li><p><strong>System Information Interface (SII) Block</strong></p></li>
<li><p><strong>Configuration Register Block</strong></p></li>
<li><p><strong>Clock &amp; Reset Control Module</strong></p></li>
<li><p><strong>PLL/CGM (Clock Generation Module)</strong></p></li>
<li><p><strong>PCIE PHY Model</strong></p></li>
<li><p><strong>External Interface Modules</strong> (NOC-N, SMN-N)</p></li>
<li><p><strong>Top-Level Keraunos PCIE Tile Integration</strong></p></li>
</ul>
</section>
<section id="scope">
<h3>1.2 Scope<a class="headerlink" href="#scope" title="Permalink to this heading">¶</a></h3>
<p>This testplan covers:</p>
<ul class="simple">
<li><p>Functional correctness of address translation</p></li>
<li><p>Register access and configuration</p></li>
<li><p>Error handling and edge cases</p></li>
<li><p>MSI interrupt delivery</p></li>
<li><p>Switch routing and address decoding</p></li>
<li><p>Clock and reset sequences</p></li>
<li><p>Isolation and timeout handling</p></li>
<li><p>Integration scenarios</p></li>
<li><p>Performance and stress testing</p></li>
</ul>
</section>
<section id="test-objectives">
<h3>1.3 Test Objectives<a class="headerlink" href="#test-objectives" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Verify address translation algorithms match specification</p></li>
<li><p>Validate error handling for invalid TLB entries</p></li>
<li><p>Confirm MSI Relay Unit interrupt delivery mechanism</p></li>
<li><p>Ensure proper AxUSER field mapping</p></li>
<li><p>Validate register access and configuration interfaces</p></li>
<li><p>Test integration with intra-tile fabric</p></li>
</ol>
</section>
<section id="references">
<h3>1.4 References<a class="headerlink" href="#references" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Keraunos PCIE Tile Specification v0.7.023</p></li>
<li><p>SystemC/TLM2.0 Design Document</p></li>
<li><p>PCI Express Base Specification 6.0</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="test-traceability-matrix">
<h2>1.5 Test Traceability Matrix<a class="headerlink" href="#test-traceability-matrix" title="Permalink to this heading">¶</a></h2>
<p>The following table maps test plan IDs to their implementing test functions in <code class="docutils literal notranslate"><span class="pre">Keranous_pcie_tileTest.cc</span></code>. All 76 tests pass (0 failures, 251 checks).</p>
<p><strong>E2E Tests (41 tests):</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#</p></th>
<th class="head"><p>Test Plan ID</p></th>
<th class="head"><p>Test Function (<code class="docutils literal notranslate"><span class="pre">Keranous_pcie_tileTest.cc</span></code>)</p></th>
<th class="head"><p>Feature Under Test</p></th>
<th class="head"><p>Status</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p><em>(sanity)</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testAlwaysSucceeds()</span></code></p></td>
<td><p>Framework sanity check</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>TC_E2E_INBOUND_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieRead_TlbApp0_NocN()</span></code></p></td>
<td><p>Inbound Read: PCIe → TLB App In0 → NOC-N</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>TC_E2E_INBOUND_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN()</span></code></p></td>
<td><p>Inbound Write: PCIe → TLB App In1 → NOC-N</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>TC_E2E_INBOUND_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_Pcie_TlbSys_SmnN()</span></code></p></td>
<td><p>System Mgmt Path: PCIe → TLB Sys In0 → SMN-N</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>TC_E2E_INBOUND_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassApp()</span></code></p></td>
<td><p>Bypass App Path (route=0x8, no TLB)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>TC_E2E_INBOUND_005</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassSys()</span></code></p></td>
<td><p>Bypass Sys Path (route=0x9, no TLB)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>TC_E2E_OUTBOUND_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut0_Pcie()</span></code></p></td>
<td><p>Outbound Read: NOC-N → TLB App Out0 → PCIe</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>TC_E2E_OUTBOUND_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_SmnN_TlbSysOut0_Pcie()</span></code></p></td>
<td><p>DBI Write: SMN-N → TLB Sys Out0 → PCIe</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>TC_E2E_OUTBOUND_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut1_PcieDBI()</span></code></p></td>
<td><p>DBI Read: NOC-N → TLB App Out1 → PCIe DBI</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>10</p></td>
<td><p>TC_E2E_CONFIG_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToTlb()</span></code></p></td>
<td><p>TLB Configuration via SMN</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>11</p></td>
<td><p>TC_E2E_CONFIG_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToSII()</span></code></p></td>
<td><p>SII Configuration via SMN</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>12</p></td>
<td><p>TC_E2E_CONFIG_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToMsiRelay()</span></code></p></td>
<td><p>MSI Relay Configuration via SMN</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>13</p></td>
<td><p>TC_E2E_MSI_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN()</span></code></p></td>
<td><p>MSI Generation and Routing to NOC-N</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>14</p></td>
<td><p>TC_E2E_MSI_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_DownstreamInput_Processing()</span></code></p></td>
<td><p>Downstream MSI Input Processing</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>15</p></td>
<td><p>TC_E2E_MSIX_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_MultipleVectors()</span></code></p></td>
<td><p>Multiple MSI-X Vector Configuration</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>TC_E2E_STATUS_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_Read_Route0xE()</span></code></p></td>
<td><p>Status Register Special Routing (route=0xE)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>17</p></td>
<td><p>TC_E2E_STATUS_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_DisabledAccess()</span></code></p></td>
<td><p>Status Register Access Control (system not ready)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>18</p></td>
<td><p>TC_E2E_ISOLATION_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_GlobalBlock()</span></code></p></td>
<td><p>Global Isolation: Block All Data Traffic</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>19</p></td>
<td><p>TC_E2E_ISOLATION_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_ConfigAccessAllowed()</span></code></p></td>
<td><p>Config Access Allowed During Isolation</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>20</p></td>
<td><p>TC_E2E_ERROR_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_InvalidTlbEntry()</span></code></p></td>
<td><p>TLB Error Handling and Recovery</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>21</p></td>
<td><p>TC_E2E_ERROR_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_AddressDecodeError()</span></code></p></td>
<td><p>Address Decode Error (DECERR) Handling</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>22</p></td>
<td><p>TC_E2E_CONCURRENT_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_InboundOutbound()</span></code></p></td>
<td><p>Concurrent Bidirectional Traffic</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>23</p></td>
<td><p>TC_E2E_CONCURRENT_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_MultipleTlbs()</span></code></p></td>
<td><p>Multiple TLB Array Concurrent Access</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>24</p></td>
<td><p>TC_E2E_RESET_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_ColdResetSequence()</span></code></p></td>
<td><p>Cold Reset Sequence and Recovery</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>25</p></td>
<td><p>TC_E2E_RESET_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_WarmResetSequence()</span></code></p></td>
<td><p>Warm Reset (Config Preserved)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>26</p></td>
<td><p>TC_E2E_FLOW_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryRead_Complete()</span></code></p></td>
<td><p>Complete PCIe Memory Read Flow</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>27</p></td>
<td><p>TC_E2E_FLOW_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryWrite_Complete()</span></code></p></td>
<td><p>Complete PCIe Memory Write Flow</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>28</p></td>
<td><p>TC_E2E_FLOW_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_NocMemoryRead_ToPcie()</span></code></p></td>
<td><p>Outbound Read: NOC → PCIe Memory Read</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>29</p></td>
<td><p>TC_E2E_FLOW_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_SmnConfigWrite_PcieDBI()</span></code></p></td>
<td><p>SMN Config Write to PCIe DBI</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>30</p></td>
<td><p>TC_E2E_REFACTOR_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Refactor_FunctionCallbackChain()</span></code></p></td>
<td><p>Function Callback Chain Validation</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>31</p></td>
<td><p>TC_E2E_REFACTOR_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Refactor_NoInternalSockets_E126Check()</span></code></p></td>
<td><p>E126 Error Elimination Validation</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>32</p></td>
<td><p>TC_E2E_SYSTEM_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_BootSequence()</span></code></p></td>
<td><p>Complete Boot/Initialization Sequence</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>33</p></td>
<td><p>TC_E2E_SYSTEM_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_ErrorRecovery()</span></code></p></td>
<td><p>Error Injection and Recovery</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>34</p></td>
<td><p>TC_E2E_MSIX_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_CompleteMsixInterruptFlow()</span></code></p></td>
<td><p>Complete MSI-X Interrupt Config, Generation, Delivery</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>35</p></td>
<td><p>TC_E2E_ERROR_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_TimeoutHandling()</span></code></p></td>
<td><p>Timeout Detection and Recovery</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>36</p></td>
<td><p>TC_E2E_CDC_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_CDC_AxiToPcieClock()</span></code></p></td>
<td><p>Clock Domain Crossing (AXI ↔ PCIe Core)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>37</p></td>
<td><p>TC_E2E_PERF_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Perf_MaximumThroughput()</span></code></p></td>
<td><p>Maximum Transaction Rate (Back-to-Back Burst)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>38</p></td>
<td><p>TC_E2E_STRESS_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Stress_AddressSpaceSweep()</span></code></p></td>
<td><p>Complete Address Space Routing Sweep</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>39</p></td>
<td><p>TC_E2E_STRESS_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Stress_TlbEntryExhaustion()</span></code></p></td>
<td><p>Full TLB Capacity (64 Entries) + Dynamic Reconfig</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>40</p></td>
<td><p>TC_E2E_POWER_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Power_IsolationModeEntryExit()</span></code></p></td>
<td><p>Power Management Isolation Entry/Exit</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>41</p></td>
<td><p>TC_E2E_SYSTEM_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_ShutdownSequence()</span></code></p></td>
<td><p>Graceful Shutdown Sequence</p></td>
<td><p>✅ PASS</p></td>
</tr>
</tbody>
</table>
<p><strong>Directed Tests (24 tests):</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#</p></th>
<th class="head"><p>Test Plan ID(s)</p></th>
<th class="head"><p>Test Function (<code class="docutils literal notranslate"><span class="pre">Keranous_pcie_tileTest.cc</span></code>)</p></th>
<th class="head"><p>Feature Under Test</p></th>
<th class="head"><p>Status</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>42</p></td>
<td><p>TC_SWITCH_NOC_PCIE_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_RouteDecodeErrors()</span></code></p></td>
<td><p>NOC-PCIE switch: 9 unmapped route values → DECERR</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>43</p></td>
<td><p>TC_SWITCH_NOC_PCIE_003/004 + TC_CONFIG_REG_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_InboundEnableGating()</span></code></p></td>
<td><p>Comprehensive isolation test with <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code>: verifies inbound/bypass/status blocked during isolation, enables permanently cleared after deassert (runs last)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>44</p></td>
<td><p>TC_SWITCH_NOC_IO_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_NocIoDecErrRegions()</span></code></p></td>
<td><p>NOC-IO switch: 3 DECERR regions verified</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>45</p></td>
<td><p>TC_SWITCH_NOC_PCIE_005</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_BypassPathRouting()</span></code></p></td>
<td><p>Bypass paths (route=0x8/0x9) with <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code>: cold reset cycling harmless</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>46</p></td>
<td><p>TC_SWITCH_SMN_IO_001/002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_SmnIoAllTargets()</span></code></p></td>
<td><p>SMN-IO switch: all 15 routing targets exercised</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>47</p></td>
<td><p>TC_CONFIG_REG_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_ConfigReg_StatusReadback()</span></code></p></td>
<td><p>Status register readback via PCIe route 0xE</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>48</p></td>
<td><p>TC_CONFIG_REG_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_ConfigReg_IsolationClearsAll()</span></code></p></td>
<td><p>Config reg defaults + cold reset with <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code>: status/data preserved across reset</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>49</p></td>
<td><p>TC_INBOUND_SYS_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_InboundTlb_InvalidEntry()</span></code></p></td>
<td><p>Invalid TLB entries (1,2,63) → DECERR verified</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>50</p></td>
<td><p>TC_INBOUND_APP1_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_InboundTlb_ValidEntryVerify()</span></code></p></td>
<td><p>Valid entry 0 succeeds, invalid entry 1 DECERR</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>51</p></td>
<td><p>TC_INBOUND_SYS_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_InboundTlb_MultipleEntryIndex()</span></code></p></td>
<td><p>Entry index calculation: entry 0 vs 5,10,31,63</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>52</p></td>
<td><p>TC_INBOUND_SYS/APP0/APP1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_InboundTlb_AllThreeTypes()</span></code></p></td>
<td><p>All 3 inbound TLB types: SysIn0, AppIn0, AppIn1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>53</p></td>
<td><p>TC_INBOUND_APP0_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_InboundTlb_App0_AllInstances()</span></code></p></td>
<td><p>All 4 TLB App In0 instances [0]-[3] config routing</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>54</p></td>
<td><p>TC_OUTBOUND_SYS_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_OutboundTlb_SysOut0_All16Entries()</span></code></p></td>
<td><p>TLB Sys Out0: entry 0 valid, entries 1-15 DECERR</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>55</p></td>
<td><p>TC_OUTBOUND_APP0_001/002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_OutboundTlb_HighAddressRouting()</span></code></p></td>
<td><p>NOC-IO high address routing (bits[51:48]) to TLB Out</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>56</p></td>
<td><p>TC_OUTBOUND_APP1_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_OutboundTlb_AppOut1_Routing()</span></code></p></td>
<td><p>TLB App Out1 via NOC-IO data path</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>57</p></td>
<td><p>TC_MSI_RELAY_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_MsiRelay_ReceiverInput()</span></code></p></td>
<td><p>MSI relay input/CSR routing paths exercised</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>58</p></td>
<td><p>TC_MSI_RELAY_011</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_MsiRelay_MultiVectorConfig()</span></code></p></td>
<td><p>All 16 MSI-X vector config + trigger</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>59</p></td>
<td><p>TC_SII_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_SII_BusDevNumberOutput()</span></code></p></td>
<td><p>SII bus/dev number config path + output signals</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>60</p></td>
<td><p>TC_SII_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_SII_CiiConfigUpdate()</span></code></p></td>
<td><p>CII tracking + interrupt: asserts CII config write (type=0x04, addr in first 128B), verifies config_update=true, confirms cfg_modified sticky bits across multiple CII events</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>61</p></td>
<td><p>TC_EXTERNAL_NOC/SMN</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Signal_InterruptForwarding()</span></code></p></td>
<td><p>5 interrupt signal paths verified with <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code>: FLR assert/deassert, hot reset, RAS error, DMA completion, misc interrupt</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>62</p></td>
<td><p>TC_CLOCK_RESET_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Reset_ColdRestoresDefaults()</span></code></p></td>
<td><p>Cold reset with <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code>: signal cycling, state preserved (enables/TLBs unaffected)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>63</p></td>
<td><p>TC_CLOCK_RESET_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Reset_WarmPreservesConfig()</span></code></p></td>
<td><p>Warm reset with <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code>: TLB state, status, bypass paths preserved</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>64</p></td>
<td><p>TC_CONFIG_REG_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_TlbConfig_AllBanksAccessible()</span></code></p></td>
<td><p>All 9 TLB config banks + data path verification</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>65</p></td>
<td><p>TC_INTEGRATION_003/004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Integration_BidirectionalVerified()</span></code></p></td>
<td><p>Verified bidirectional: 20 rapid alternating txns</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>66</p></td>
<td><p>TC_MSI_RELAY_012</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_MsiRelay_InterruptOutput()</span></code></p></td>
<td><p>MSI output verification: NOC-IO and PCIe inbound MSI trigger paths exercised, address passthrough prevents PBA set (offset=0x18800000≠0), no spurious MSI output</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>67</p></td>
<td><p>TC_MSI_RELAY_013</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_MsiRelay_PendingBitArray()</span></code></p></td>
<td><p>PBA mechanism: PBA register read attempted via SMN (passthrough documented), MSI accumulation for vectors 0-3 attempted, outstanding counter read attempted</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>68</p></td>
<td><p>TC_MSI_RELAY_014</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_MsiRelay_GlobalMaskControl()</span></code></p></td>
<td><p>Global mask: MSI-X table configuration (addr, data, mask) attempted for entries 0-3 via SMN, MSI trigger after config attempted, address passthrough blocks all CSR writes</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>69</p></td>
<td><p>TC_SII_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_SII_CiiInterruptClear()</span></code></p></td>
<td><p>CII interrupt clear: CII asserts config_update, RW1C via SMN blocked by passthrough, controller reset clears cfg_modified and deasserts config_update</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>70</p></td>
<td><p>TC_SII_005</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_SII_CiiEdgeCases()</span></code></p></td>
<td><p>CII edge cases: type=0x00 (no trigger), type=0x05 (no trigger), addr=0x080 second 128B (no trigger), addr=0x400 high config (no trigger), hv=false (no trigger), positive control confirms valid CII triggers</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>71</p></td>
<td><p>TC_SII_006</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_SII_ResetClearsConfigUpdate()</span></code></p></td>
<td><p>Reset lifecycle: clean→CII→interrupt→more CII→accumulated→reset→cleared→new CII→re-asserted→final reset→cleared</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>72</p></td>
<td><p>TC_SII_007</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_SII_DeviceTypeAndSysInt()</span></code></p></td>
<td><p>SII output signals: verifies <code class="docutils literal notranslate"><span class="pre">pcie_device_type</span></code> (EP mode default=false) and <code class="docutils literal notranslate"><span class="pre">pcie_sys_int</span></code> (no legacy interrupt default=false), attempts CORE_CONTROL write via SMN (blocked by passthrough), confirms outputs unchanged</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>73</p></td>
<td><p>TC_SWITCH_NOC_PCIE_005</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_StatusRegRoute0xF()</span></code></p></td>
<td><p>Status register via route 0xF: reads status via both route 0xE and 0xF, verifies <code class="docutils literal notranslate"><span class="pre">system_ready=1</span></code>, confirms both routes return identical value</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>74</p></td>
<td><p>TC_SWITCH_NOC_PCIE_006</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_StatusRegWriteRejection()</span></code></p></td>
<td><p>Write rejection on status routes: writes to route 0xE and 0xF return DECERR (not treated as status access), read still works after rejection</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>75</p></td>
<td><p>TC_SWITCH_NOC_PCIE_007</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_BadCommandResponse()</span></code></p></td>
<td><p>DECERR route coverage: exercises 5 unmapped route bits (0x2, 0x3, 0x5, 0xA, 0xD), verifies all return DECERR, confirms system stability after multiple error responses</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>76</p></td>
<td><p>TC_INBOUND_TLB_006</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_InboundTlb_PageBoundary()</span></code></p></td>
<td><p>TLB page boundary: addr 0x3FFC → entry 0 (valid, success), addr 0x4000 → entry 1 (invalid, DECERR), addr 0x7FFC → entry 1 (DECERR), entry 63 max index (DECERR), regression check entry 0</p></td>
<td><p>✅ PASS</p></td>
</tr>
</tbody>
</table>
<p><strong>Known Findings Documented in Directed Tests:</strong></p>
<ol class="arabic simple">
<li><p><strong>Address Passthrough (TLB Config):</strong> TLB <code class="docutils literal notranslate"><span class="pre">process_config_access()</span></code> uses the full SMN address as an offset into a 4KB SCML2 memory. Only entry 0 at the base of each 64KB config range fits; entries 1+ exceed memory bounds. Fix: strip base address before memory access.</p></li>
<li><p><strong>Address Passthrough (MSI Relay):</strong> MSI relay <code class="docutils literal notranslate"><span class="pre">process_msi_input()</span></code> and <code class="docutils literal notranslate"><span class="pre">process_csr_access()</span></code> receive full addresses from switches, preventing register matching. Fix: strip base address.</p></li>
<li><p><strong>Address Passthrough (SII):</strong> Same issue as MSI relay for SII config register access.</p></li>
<li><p><strong>Signal Propagation (RESOLVED):</strong> sc_signal writes require delta cycles to propagate in SystemC. This is now handled by calling <code class="docutils literal notranslate"><span class="pre">sc_core::wait(sc_core::SC_ZERO_TIME)</span></code> after signal writes to advance delta cycles. Tests that use this technique directly verify isolation blocking, interrupt signal forwarding (FLR, hot reset, RAS, DMA, misc), cold/warm reset signal cycling, and CII input propagation.</p></li>
<li><p><strong>Config Register Block:</strong> SMN-IO switch range 0x18000000-0x18100000 returns TLM_OK_RESPONSE without forwarding to the ConfigRegBlock callback. Config register reads/writes via SMN have no effect on internal state.</p></li>
<li><p><strong>Isolation Enable Recovery:</strong> <code class="docutils literal notranslate"><span class="pre">ConfigRegBlock::set_isolate_req(true)</span></code> clears <code class="docutils literal notranslate"><span class="pre">system_ready</span></code>, <code class="docutils literal notranslate"><span class="pre">pcie_inbound_app_enable</span></code>, and <code class="docutils literal notranslate"><span class="pre">pcie_outbound_app_enable</span></code>. <code class="docutils literal notranslate"><span class="pre">set_isolate_req(false)</span></code> only clears the <code class="docutils literal notranslate"><span class="pre">isolate_req_</span></code> flag but does NOT restore the enables. Cold reset also does not restore enables (no reset handler). This means the DUT cannot recover from isolation without external software reconfiguration, which is not possible in the current test environment (SMN-IO switch absorbs config writes).</p></li>
<li><p><strong>CII Processing (RESOLVED):</strong> The SII block’s CII tracking, CDC synchronization, and interrupt generation logic has been restored via the <code class="docutils literal notranslate"><span class="pre">SiiBlock::update()</span></code> method. This single method replaces the three SC_METHODs from the backup_original (<code class="docutils literal notranslate"><span class="pre">cii_tracking_process</span></code>, <code class="docutils literal notranslate"><span class="pre">cfg_modified_update_process</span></code>, <code class="docutils literal notranslate"><span class="pre">cdc_pcie_to_apb</span></code>). CII config-space write detection (type 0x04, first 128B), cfg_modified bitmask accumulation with RW1C clear support, and <code class="docutils literal notranslate"><span class="pre">config_update</span></code> interrupt assertion are all functional. The tile’s <code class="docutils literal notranslate"><span class="pre">signal_update_process</span></code> calls <code class="docutils literal notranslate"><span class="pre">sii_block_-&gt;update()</span></code> between setters and getters to process CII inputs each delta cycle.</p></li>
<li><p><strong>MSI Relay Interrupt Output Not Verifiable:</strong> The MSI relay’s interrupt output path cannot be fully exercised because: (a) <code class="docutils literal notranslate"><span class="pre">process_msi_input</span></code> requires <code class="docutils literal notranslate"><span class="pre">offset==0</span></code> but receives the full NOC-IO address <code class="docutils literal notranslate"><span class="pre">0x18800000</span></code> (address passthrough), so PBA bits are never set; (b) <code class="docutils literal notranslate"><span class="pre">msix_enable_</span></code> is an internal <code class="docutils literal notranslate"><span class="pre">sc_signal</span></code> (not exposed as a tile port), defaulting to <code class="docutils literal notranslate"><span class="pre">false</span></code>; © per-vector masks default to <code class="docutils literal notranslate"><span class="pre">true</span></code> (masked) and cannot be cleared via SMN CSR writes (address passthrough). The MSI routing paths, PBA read, and global mask configuration paths are exercised in tests TC_MSI_RELAY_012/013/014, which document the specific address passthrough offsets and verify system stability.</p></li>
</ol>
</section>
<hr class="docutils" />
<section id="test-environment">
<h2>2. Test Environment<a class="headerlink" href="#test-environment" title="Permalink to this heading">¶</a></h2>
<section id="testbench-structure">
<h3>2.1 Testbench Structure<a class="headerlink" href="#testbench-structure" title="Permalink to this heading">¶</a></h3>
<div class="mermaid">
            graph TB
    Top[&quot;Testbench Top Level&quot;]
    
    Stimulus[&quot;Stimulus&lt;br/&gt;Generator&quot;]
    Monitor[&quot;Monitor&lt;br/&gt;&amp; Checker&quot;]
    DUT[&quot;Device Under Test (DUT)&lt;br/&gt;- TLBs&lt;br/&gt;- MSI Relay&quot;]
    RefModel[&quot;Reference Model&lt;br/&gt;(Golden Model)&quot;]
    
    Stimulus --&gt; DUT
    Monitor --&gt; DUT
    DUT --&gt; RefModel
    
    style Top fill:#e1f5ff
    style Stimulus fill:#fff4e1
    style Monitor fill:#fff4e1
    style DUT fill:#e8f5e9
    style RefModel fill:#fce4ec
        </div></section>
<section id="test-components">
<h3>2.2 Test Components<a class="headerlink" href="#test-components" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>Stimulus Generator:</strong> Creates TLM transactions and register accesses</p></li>
<li><p><strong>Monitor:</strong> Captures transactions and responses</p></li>
<li><p><strong>Checker:</strong> Compares DUT output with reference model</p></li>
<li><p><strong>Reference Model:</strong> Golden model implementing specification algorithms</p></li>
<li><p><strong>Scoreboard:</strong> Tracks test progress and coverage</p></li>
</ul>
</section>
<section id="test-tools">
<h3>2.3 Test Tools<a class="headerlink" href="#test-tools" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>SystemC Simulator:</strong> SystemC kernel for simulation</p></li>
<li><p><strong>TLM2.0 Library:</strong> Transaction Level Modeling library</p></li>
<li><p><strong>SCML2:</strong> Synopsys Component Modeling Library</p></li>
<li><p><strong>Test Framework:</strong> Custom C++ test framework or UVM-SystemC</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="test-strategy">
<h2>3. Test Strategy<a class="headerlink" href="#test-strategy" title="Permalink to this heading">¶</a></h2>
<section id="test-levels">
<h3>3.1 Test Levels<a class="headerlink" href="#test-levels" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p><strong>Unit Tests:</strong> Individual TLB and MSI Relay Unit testing</p></li>
<li><p><strong>Integration Tests:</strong> TLB + MSI Relay Unit interaction</p></li>
<li><p><strong>System Tests:</strong> Full tile integration scenarios</p></li>
</ol>
</section>
<section id="test-methodology">
<h3>3.2 Test Methodology<a class="headerlink" href="#test-methodology" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>Directed Tests:</strong> Specific scenarios from specification</p></li>
<li><p><strong>Random Tests:</strong> Constrained random stimulus generation</p></li>
<li><p><strong>Coverage-Driven Tests:</strong> Tests targeting coverage holes</p></li>
<li><p><strong>Stress Tests:</strong> High transaction rates and edge cases</p></li>
</ul>
</section>
<section id="test-phases">
<h3>3.3 Test Phases<a class="headerlink" href="#test-phases" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p><strong>Phase 1:</strong> Basic functionality (address translation, register access)</p></li>
<li><p><strong>Phase 2:</strong> Error handling and edge cases</p></li>
<li><p><strong>Phase 3:</strong> MSI interrupt delivery</p></li>
<li><p><strong>Phase 4:</strong> Integration and system scenarios</p></li>
<li><p><strong>Phase 5:</strong> Performance and stress testing</p></li>
</ol>
</section>
</section>
<hr class="docutils" />
<section id="inbound-tlb-test-cases">
<h2>4. Inbound TLB Test Cases<a class="headerlink" href="#inbound-tlb-test-cases" title="Permalink to this heading">¶</a></h2>
<section id="tlbsysin0-test-cases">
<h3>4.1 TLBSysIn0 Test Cases<a class="headerlink" href="#tlbsysin0-test-cases" title="Permalink to this heading">¶</a></h3>
<section id="tc-inbound-sys-001-basic-address-translation">
<h4>TC_INBOUND_SYS_001: Basic Address Translation<a class="headerlink" href="#tc-inbound-sys-001-basic-address-translation" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify correct address translation for valid TLB entry</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB entry 0: valid=1, addr=0x18000000, attr=0x123</p></li>
<li><p>Send AXI read transaction with address 0xE0000000 (iATU output)</p></li>
<li><p>Verify translated address = 0x18000000</p></li>
<li><p>Verify AxUSER = expected value based on attr[11:4] and attr[1:0]</p></li>
</ol>
<p><strong>Expected Result:</strong> Translation successful, correct address and AxUSER</p>
<p><strong>Coverage:</strong> Basic translation path, AxUSER mapping</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-sys-002-invalid-entry-detection">
<h4>TC_INBOUND_SYS_002: Invalid Entry Detection<a class="headerlink" href="#tc-inbound-sys-002-invalid-entry-detection" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify DECERR response for invalid TLB entry</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB entry 5: valid=0</p></li>
<li><p>Send AXI read transaction with address that maps to entry 5</p></li>
<li><p>Verify response status = TLM_DECERR_RESPONSE</p></li>
<li><p>Verify transaction does not propagate downstream</p></li>
</ol>
<p><strong>Expected Result:</strong> DECERR returned immediately</p>
<p><strong>Coverage:</strong> Invalid entry handling</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-sys-003-index-calculation">
<h4>TC_INBOUND_SYS_003: Index Calculation<a class="headerlink" href="#tc-inbound-sys-003-index-calculation" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify correct index calculation for all entries</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure all 64 entries with unique addresses</p></li>
<li><p>Send transactions covering all index ranges</p></li>
<li><p>Verify each transaction uses correct TLB entry</p></li>
</ol>
<p><strong>Expected Result:</strong> All entries accessed correctly</p>
<p><strong>Coverage:</strong> Index calculation, all entries</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-sys-004-page-boundary-crossing">
<h4>TC_INBOUND_SYS_004: Page Boundary Crossing<a class="headerlink" href="#tc-inbound-sys-004-page-boundary-crossing" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify address translation preserves page offset</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB entry 10: addr=0x10000000</p></li>
<li><p>Send transaction with address 0xE0001234 (offset=0x1234)</p></li>
<li><p>Verify translated address = 0x10001234</p></li>
</ol>
<p><strong>Expected Result:</strong> Page offset preserved correctly</p>
<p><strong>Coverage:</strong> Address masking, page boundaries</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-sys-005-axuser-field-mapping">
<h4>TC_INBOUND_SYS_005: AxUSER Field Mapping<a class="headerlink" href="#tc-inbound-sys-005-axuser-field-mapping" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify AxUSER field format: {ATTR[11:4], 2’b0, ATTR[1:0]}</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB entry with attr = 0xABC</p></li>
<li><p>Send transaction and capture AxUSER</p></li>
<li><p>Verify AxUSER[11:4] = attr[11:4] = 0xAB</p></li>
<li><p>Verify AxUSER[3:2] = 0b00</p></li>
<li><p>Verify AxUSER[1:0] = attr[1:0] = 0x3</p></li>
</ol>
<p><strong>Expected Result:</strong> AxUSER matches specification format</p>
<p><strong>Coverage:</strong> AxUSER encoding</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-sys-006-system-ready-bypass">
<h4>TC_INBOUND_SYS_006: System Ready Bypass<a class="headerlink" href="#tc-inbound-sys-006-system-ready-bypass" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify bypass path when system_ready=1 and addr[63:60]=8 or 9</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Set system_ready = 1</p></li>
<li><p>Send transaction with address[63:60] = 8</p></li>
<li><p>Verify transaction bypasses TLB translation</p></li>
<li><p>Verify transaction forwarded directly to SMN-IO</p></li>
</ol>
<p><strong>Expected Result:</strong> Bypass path functional</p>
<p><strong>Coverage:</strong> Bypass logic</p>
</section>
</section>
<hr class="docutils" />
<section id="tlbappin0-test-cases">
<h3>4.2 TLBAppIn0 Test Cases<a class="headerlink" href="#tlbappin0-test-cases" title="Permalink to this heading">¶</a></h3>
<section id="tc-inbound-app0-001-bar0-1-translation">
<h4>TC_INBOUND_APP0_001: BAR0/1 Translation<a class="headerlink" href="#tc-inbound-app0-001-bar0-1-translation" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify translation for BAR0/1 traffic (port=0)</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB entry 20: valid=1, addr=0x20000000</p></li>
<li><p>Send transaction with iATU address[63:60] = 0 (BAR0/1)</p></li>
<li><p>Verify translated address uses entry 20</p></li>
<li><p>Verify AxUSER format: {3’b0, ATTR[4:0], 4’b0}</p></li>
</ol>
<p><strong>Expected Result:</strong> Correct translation for BAR0/1</p>
<p><strong>Coverage:</strong> Port selection, BAR0/1 path</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-app0-002-multiple-instance-support">
<h4>TC_INBOUND_APP0_002: Multiple Instance Support<a class="headerlink" href="#tc-inbound-app0-002-multiple-instance-support" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify multiple TLBAppIn0 instances work independently</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Instantiate TLBAppIn0-0, TLBAppIn0-1, TLBAppIn0-2, TLBAppIn0-3</p></li>
<li><p>Configure each with different entries</p></li>
<li><p>Send transactions to each instance</p></li>
<li><p>Verify each instance translates independently</p></li>
</ol>
<p><strong>Expected Result:</strong> All instances function correctly</p>
<p><strong>Coverage:</strong> Multiple instances</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-app0-003-16mb-page-size">
<h4>TC_INBOUND_APP0_003: 16MB Page Size<a class="headerlink" href="#tc-inbound-app0-003-16mb-page-size" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify 16MB page size translation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 5: addr=0x30000000</p></li>
<li><p>Send transaction with address offset 0x123456</p></li>
<li><p>Verify translated address = 0x30123456</p></li>
</ol>
<p><strong>Expected Result:</strong> 16MB page size handled correctly</p>
<p><strong>Coverage:</strong> Page size, address masking</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-app0-004-non-cacheable-and-qosid">
<h4>TC_INBOUND_APP0_004: Non-Cacheable and QoSID<a class="headerlink" href="#tc-inbound-app0-004-non-cacheable-and-qosid" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify ATTR[4:0] mapping to AxUSER</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry with attr[4] = 1 (non-cacheable), attr[3:0] = 0xA (QoSID)</p></li>
<li><p>Send transaction and verify AxUSER[8] = 1, AxUSER[7:4] = 0xA</p></li>
</ol>
<p><strong>Expected Result:</strong> Non-cacheable and QoSID correctly encoded</p>
<p><strong>Coverage:</strong> Attribute encoding</p>
</section>
</section>
<hr class="docutils" />
<section id="tlbappin1-test-cases">
<h3>4.3 TLBAppIn1 Test Cases<a class="headerlink" href="#tlbappin1-test-cases" title="Permalink to this heading">¶</a></h3>
<section id="tc-inbound-app1-001-bar4-5-translation">
<h4>TC_INBOUND_APP1_001: BAR4/5 Translation<a class="headerlink" href="#tc-inbound-app1-001-bar4-5-translation" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify translation for BAR4/5 traffic (port=1)</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB entry 30: valid=1, addr=0x4000000000</p></li>
<li><p>Send transaction with iATU address[63:60] = 1 (BAR4/5)</p></li>
<li><p>Verify translated address uses entry 30</p></li>
<li><p>Verify correct 8GB page size handling</p></li>
</ol>
<p><strong>Expected Result:</strong> Correct translation for BAR4/5</p>
<p><strong>Coverage:</strong> Port selection, BAR4/5 path</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-app1-002-8gb-page-size">
<h4>TC_INBOUND_APP1_002: 8GB Page Size<a class="headerlink" href="#tc-inbound-app1-002-8gb-page-size" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify 8GB page size translation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 10: addr=0x5000000000</p></li>
<li><p>Send transaction with address offset 0x123456789</p></li>
<li><p>Verify translated address = 0x5123456789</p></li>
</ol>
<p><strong>Expected Result:</strong> 8GB page size handled correctly</p>
<p><strong>Coverage:</strong> Large page size, address masking</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-app1-003-dram-mapping">
<h4>TC_INBOUND_APP1_003: DRAM Mapping<a class="headerlink" href="#tc-inbound-app1-003-dram-mapping" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify typical DRAM mapping scenario</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entries 0-3 for Mimir 0 (4 entries × 8GB = 32GB)</p></li>
<li><p>Send transactions covering all 4 entries</p></li>
<li><p>Verify correct translation to DRAM addresses</p></li>
</ol>
<p><strong>Expected Result:</strong> DRAM mapping functional</p>
<p><strong>Coverage:</strong> Real-world usage scenario</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="outbound-tlb-test-cases">
<h2>5. Outbound TLB Test Cases<a class="headerlink" href="#outbound-tlb-test-cases" title="Permalink to this heading">¶</a></h2>
<section id="tlbsysout0-test-cases">
<h3>5.1 TLBSysOut0 Test Cases<a class="headerlink" href="#tlbsysout0-test-cases" title="Permalink to this heading">¶</a></h3>
<section id="tc-outbound-sys-001-dbi-access-translation">
<h4>TC_OUTBOUND_SYS_001: DBI Access Translation<a class="headerlink" href="#tc-outbound-sys-001-dbi-access-translation" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify DBI access translation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 0: valid=1, addr=0x00000000, attr=DBI_ATTR</p></li>
<li><p>Send AXI write transaction with address 0x00001234</p></li>
<li><p>Verify translated address = 0x00001234</p></li>
<li><p>Verify attributes passed through</p></li>
</ol>
<p><strong>Expected Result:</strong> DBI access translated correctly</p>
<p><strong>Coverage:</strong> DBI path, attribute passthrough</p>
</section>
<hr class="docutils" />
<section id="tc-outbound-sys-002-64kb-page-size">
<h4>TC_OUTBOUND_SYS_002: 64KB Page Size<a class="headerlink" href="#tc-outbound-sys-002-64kb-page-size" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify 64KB page size</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 5: addr=0x00380000</p></li>
<li><p>Send transaction with address 0x00381234</p></li>
<li><p>Verify translated address = 0x00381234</p></li>
</ol>
<p><strong>Expected Result:</strong> 64KB page size handled correctly</p>
<p><strong>Coverage:</strong> Page size, address masking</p>
</section>
<hr class="docutils" />
<section id="tc-outbound-sys-003-all-16-entries">
<h4>TC_OUTBOUND_SYS_003: All 16 Entries<a class="headerlink" href="#tc-outbound-sys-003-all-16-entries" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify all 16 entries accessible</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure all 16 entries with unique addresses</p></li>
<li><p>Send transactions covering all entries</p></li>
<li><p>Verify each entry translates correctly</p></li>
</ol>
<p><strong>Expected Result:</strong> All entries functional</p>
<p><strong>Coverage:</strong> Full entry coverage</p>
</section>
</section>
<hr class="docutils" />
<section id="tlbappout0-test-cases">
<h3>5.2 TLBAppOut0 Test Cases<a class="headerlink" href="#tlbappout0-test-cases" title="Permalink to this heading">¶</a></h3>
<section id="tc-outbound-app0-001-high-address-translation-256tb">
<h4>TC_OUTBOUND_APP0_001: High Address Translation (&gt;=256TB)<a class="headerlink" href="#tc-outbound-app0-001-high-address-translation-256tb" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify translation for addresses &gt;= 256TB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 5: valid=1, addr=0x100000000000</p></li>
<li><p>Send transaction with address 0x100000001234</p></li>
<li><p>Verify translated address uses entry 5</p></li>
<li><p>Verify 16TB page size handling</p></li>
</ol>
<p><strong>Expected Result:</strong> High address translation correct</p>
<p><strong>Coverage:</strong> High address path, 16TB pages</p>
</section>
<hr class="docutils" />
<section id="tc-outbound-app0-002-address-range-check">
<h4>TC_OUTBOUND_APP0_002: Address Range Check<a class="headerlink" href="#tc-outbound-app0-002-address-range-check" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify only addresses &gt;= 256TB are processed</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with address &lt; 256TB (e.g., 0x000000001234)</p></li>
<li><p>Verify TLBAppOut0 does not process (should use TLBAppOut1)</p></li>
<li><p>Send transaction with address &gt;= 256TB</p></li>
<li><p>Verify TLBAppOut0 processes correctly</p></li>
</ol>
<p><strong>Expected Result:</strong> Address range filtering correct</p>
<p><strong>Coverage:</strong> Address range logic</p>
</section>
<hr class="docutils" />
<section id="tc-outbound-app0-003-16tb-page-size">
<h4>TC_OUTBOUND_APP0_003: 16TB Page Size<a class="headerlink" href="#tc-outbound-app0-003-16tb-page-size" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify 16TB page size translation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 10: addr=0x200000000000</p></li>
<li><p>Send transaction with address offset 0x123456789ABC</p></li>
<li><p>Verify translated address = 0x2123456789ABC</p></li>
</ol>
<p><strong>Expected Result:</strong> 16TB page size handled correctly</p>
<p><strong>Coverage:</strong> Large page size</p>
</section>
</section>
<hr class="docutils" />
<section id="tlbappout1-test-cases">
<h3>5.3 TLBAppOut1 Test Cases<a class="headerlink" href="#tlbappout1-test-cases" title="Permalink to this heading">¶</a></h3>
<section id="tc-outbound-app1-001-low-address-translation-256tb">
<h4>TC_OUTBOUND_APP1_001: Low Address Translation (&lt;256TB)<a class="headerlink" href="#tc-outbound-app1-001-low-address-translation-256tb" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify translation for addresses &lt; 256TB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 3: valid=1, addr=0x00003800</p></li>
<li><p>Send transaction with address 0x00001234</p></li>
<li><p>Verify translated address uses entry 3</p></li>
</ol>
<p><strong>Expected Result:</strong> Low address translation correct</p>
<p><strong>Coverage:</strong> Low address path</p>
</section>
<hr class="docutils" />
<section id="tc-outbound-app1-002-dbi-access-from-application">
<h4>TC_OUTBOUND_APP1_002: DBI Access from Application<a class="headerlink" href="#tc-outbound-app1-002-dbi-access-from-application" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify DBI access from application processors</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 1: addr=0x00380000 (DBI DMA)</p></li>
<li><p>Send transaction with address 0x00381234</p></li>
<li><p>Verify translated address = 0x00381234</p></li>
<li><p>Verify DBI attributes set</p></li>
</ol>
<p><strong>Expected Result:</strong> DBI access functional</p>
<p><strong>Coverage:</strong> DBI path from application</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="msi-relay-unit-test-cases">
<h2>6. MSI Relay Unit Test Cases<a class="headerlink" href="#msi-relay-unit-test-cases" title="Permalink to this heading">¶</a></h2>
<section id="register-access-tests">
<h3>6.1 Register Access Tests<a class="headerlink" href="#register-access-tests" title="Permalink to this heading">¶</a></h3>
<section id="tc-msi-relay-001-msi-receiver-write">
<h4>TC_MSI_RELAY_001: MSI Receiver Write<a class="headerlink" href="#tc-msi-relay-001-msi-receiver-write" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify writing to msi_receiver sets PBA bit</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Write 0x0005 to msi_receiver (vector 5)</p></li>
<li><p>Read msix_pba register</p></li>
<li><p>Verify bit 5 is set</p></li>
<li><p>Verify other bits unchanged</p></li>
</ol>
<p><strong>Expected Result:</strong> PBA bit 5 set correctly</p>
<p><strong>Coverage:</strong> MSI receiver, PBA update</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-002-msi-x-table-configuration">
<h4>TC_MSI_RELAY_002: MSI-X Table Configuration<a class="headerlink" href="#tc-msi-relay-002-msi-x-table-configuration" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify MSI-X table read/write</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Write MSI-X table entry 3:</p>
<ul class="simple">
<li><p>Address = 0xFEE00000</p></li>
<li><p>Data = 0x1234</p></li>
<li><p>Mask = 0</p></li>
</ul>
</li>
<li><p>Read back entry 3</p></li>
<li><p>Verify all fields match</p></li>
</ol>
<p><strong>Expected Result:</strong> MSI-X table accessible</p>
<p><strong>Coverage:</strong> MSI-X table access</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-003-outstanding-count">
<h4>TC_MSI_RELAY_003: Outstanding Count<a class="headerlink" href="#tc-msi-relay-003-outstanding-count" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify msi_outstanding counter</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 0</p></li>
<li><p>Trigger MSI (should increment counter)</p></li>
<li><p>Read msi_outstanding</p></li>
<li><p>Verify counter &gt; 0</p></li>
<li><p>Wait for completion</p></li>
<li><p>Verify counter returns to 0</p></li>
</ol>
<p><strong>Expected Result:</strong> Outstanding counter accurate</p>
<p><strong>Coverage:</strong> Outstanding tracking</p>
</section>
</section>
<hr class="docutils" />
<section id="msi-generation-tests">
<h3>6.2 MSI Generation Tests<a class="headerlink" href="#msi-generation-tests" title="Permalink to this heading">¶</a></h3>
<section id="tc-msi-relay-004-basic-msi-generation">
<h4>TC_MSI_RELAY_004: Basic MSI Generation<a class="headerlink" href="#tc-msi-relay-004-basic-msi-generation" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify MSI message generation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 0:</p>
<ul class="simple">
<li><p>Address = 0xFEE00000</p></li>
<li><p>Data = 0x1234</p></li>
<li><p>Mask = 0</p></li>
</ul>
</li>
<li><p>Set msix_enable = 1, msix_mask = 0</p></li>
<li><p>Write 0x0000 to msi_receiver</p></li>
<li><p>Verify AXI4-Lite write transaction:</p>
<ul class="simple">
<li><p>Address = 0xFEE00000</p></li>
<li><p>Data = 0x1234</p></li>
</ul>
</li>
<li><p>Verify PBA bit 0 cleared after send</p></li>
</ol>
<p><strong>Expected Result:</strong> MSI generated correctly</p>
<p><strong>Coverage:</strong> MSI generation path</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-005-msi-x-enable-control">
<h4>TC_MSI_RELAY_005: MSI-X Enable Control<a class="headerlink" href="#tc-msi-relay-005-msi-x-enable-control" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify MSI-X enable gating</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 0</p></li>
<li><p>Set msix_enable = 0</p></li>
<li><p>Write 0x0000 to msi_receiver</p></li>
<li><p>Verify no MSI generated</p></li>
<li><p>Set msix_enable = 1</p></li>
<li><p>Verify MSI generated</p></li>
</ol>
<p><strong>Expected Result:</strong> Enable control functional</p>
<p><strong>Coverage:</strong> Enable gating</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-006-global-mask-control">
<h4>TC_MSI_RELAY_006: Global Mask Control<a class="headerlink" href="#tc-msi-relay-006-global-mask-control" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify global mask gating</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 0</p></li>
<li><p>Set msix_enable = 1, msix_mask = 1</p></li>
<li><p>Write 0x0000 to msi_receiver</p></li>
<li><p>Verify no MSI generated</p></li>
<li><p>Set msix_mask = 0</p></li>
<li><p>Verify MSI generated</p></li>
</ol>
<p><strong>Expected Result:</strong> Global mask functional</p>
<p><strong>Coverage:</strong> Mask gating</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-007-vector-mask-control">
<h4>TC_MSI_RELAY_007: Vector Mask Control<a class="headerlink" href="#tc-msi-relay-007-vector-mask-control" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify per-vector mask control</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 5 with mask = 1</p></li>
<li><p>Set msix_enable = 1, msix_mask = 0</p></li>
<li><p>Write 0x0005 to msi_receiver</p></li>
<li><p>Verify no MSI generated (vector masked)</p></li>
<li><p>Configure entry 5 with mask = 0</p></li>
<li><p>Verify MSI generated</p></li>
</ol>
<p><strong>Expected Result:</strong> Vector mask functional</p>
<p><strong>Coverage:</strong> Per-vector masking</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-008-invalid-entry-handling">
<h4>TC_MSI_RELAY_008: Invalid Entry Handling<a class="headerlink" href="#tc-msi-relay-008-invalid-entry-handling" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify invalid MSI-X table entry handling</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 10 with address = 0</p></li>
<li><p>Set msix_enable = 1, msix_mask = 0</p></li>
<li><p>Write 0x000A to msi_receiver</p></li>
<li><p>Verify no MSI generated (invalid address)</p></li>
<li><p>Verify PBA bit remains set</p></li>
</ol>
<p><strong>Expected Result:</strong> Invalid entries ignored</p>
<p><strong>Coverage:</strong> Invalid entry handling</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-009-multiple-pending-interrupts">
<h4>TC_MSI_RELAY_009: Multiple Pending Interrupts<a class="headerlink" href="#tc-msi-relay-009-multiple-pending-interrupts" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify handling of multiple pending interrupts</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entries 0, 1, 2</p></li>
<li><p>Set msix_enable = 1, msix_mask = 0</p></li>
<li><p>Write 0x0000, 0x0001, 0x0002 to msi_receiver</p></li>
<li><p>Verify all three PBA bits set</p></li>
<li><p>Verify MSIs generated one at a time</p></li>
<li><p>Verify PBA bits cleared as MSIs sent</p></li>
</ol>
<p><strong>Expected Result:</strong> Multiple interrupts handled correctly</p>
<p><strong>Coverage:</strong> Multiple pending, MSI ordering</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-010-setip-signal">
<h4>TC_MSI_RELAY_010: SetIP Signal<a class="headerlink" href="#tc-msi-relay-010-setip-signal" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify setip signal sets PBA bits</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 7</p></li>
<li><p>Set msix_enable = 1, msix_mask = 0</p></li>
<li><p>Assert setip[7] = 1</p></li>
<li><p>Verify PBA bit 7 set</p></li>
<li><p>Verify MSI generated</p></li>
</ol>
<p><strong>Expected Result:</strong> SetIP signal functional</p>
<p><strong>Coverage:</strong> SetIP input</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-011-all-16-vectors">
<h4>TC_MSI_RELAY_011: All 16 Vectors<a class="headerlink" href="#tc-msi-relay-011-all-16-vectors" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify all 16 MSI-X vectors functional</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure all 16 MSI-X table entries</p></li>
<li><p>Trigger interrupts for all vectors</p></li>
<li><p>Verify all MSIs generated</p></li>
<li><p>Verify all PBA bits cleared</p></li>
</ol>
<p><strong>Expected Result:</strong> All vectors functional</p>
<p><strong>Coverage:</strong> Full vector coverage</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="integration-test-cases">
<h2>7. Integration Test Cases<a class="headerlink" href="#integration-test-cases" title="Permalink to this heading">¶</a></h2>
<section id="tlb-msi-relay-integration">
<h3>7.1 TLB + MSI Relay Integration<a class="headerlink" href="#tlb-msi-relay-integration" title="Permalink to this heading">¶</a></h3>
<section id="tc-integration-001-msi-x-table-access-via-tlb">
<h4>TC_INTEGRATION_001: MSI-X Table Access via TLB<a class="headerlink" href="#tc-integration-001-msi-x-table-access-via-tlb" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify host can access MSI-X table through TLB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLBSysIn0 entry 0 for MSI Relay (0x18000000)</p></li>
<li><p>Configure iATU to map BAR2/3 to TLBSysIn0</p></li>
<li><p>Host writes to BAR2+0x2000 (MSI-X table)</p></li>
<li><p>Verify write reaches MSI Relay Unit</p></li>
<li><p>Verify MSI-X table updated</p></li>
</ol>
<p><strong>Expected Result:</strong> TLB + MSI Relay integration functional</p>
<p><strong>Coverage:</strong> Integration path</p>
</section>
<hr class="docutils" />
<section id="tc-integration-002-msi-generation-through-fabric">
<h4>TC_INTEGRATION_002: MSI Generation Through Fabric<a class="headerlink" href="#tc-integration-002-msi-generation-through-fabric" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify MSI travels through intra-tile fabric</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 0</p></li>
<li><p>Trigger MSI from MSI Relay Unit</p></li>
<li><p>Verify MSI write transaction on NOC-PCIE</p></li>
<li><p>Verify transaction reaches PCIe Controller</p></li>
<li><p>Verify TLP generated</p></li>
</ol>
<p><strong>Expected Result:</strong> MSI path through fabric functional</p>
<p><strong>Coverage:</strong> Fabric integration</p>
</section>
</section>
<hr class="docutils" />
<section id="multiple-tlb-integration">
<h3>7.2 Multiple TLB Integration<a class="headerlink" href="#multiple-tlb-integration" title="Permalink to this heading">¶</a></h3>
<section id="tc-integration-003-concurrent-tlb-operations">
<h4>TC_INTEGRATION_003: Concurrent TLB Operations<a class="headerlink" href="#tc-integration-003-concurrent-tlb-operations" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify multiple TLBs operate concurrently</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transactions to TLBSysIn0, TLBAppIn0, TLBAppIn1 simultaneously</p></li>
<li><p>Verify all translations occur correctly</p></li>
<li><p>Verify no interference between TLBs</p></li>
</ol>
<p><strong>Expected Result:</strong> Concurrent operations functional</p>
<p><strong>Coverage:</strong> Concurrency</p>
</section>
<hr class="docutils" />
<section id="tc-integration-004-outbound-inbound-round-trip">
<h4>TC_INTEGRATION_004: Outbound + Inbound Round Trip<a class="headerlink" href="#tc-integration-004-outbound-inbound-round-trip" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify address translation round trip</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure outbound TLB entry</p></li>
<li><p>Send transaction outbound (chiplet -&gt; external)</p></li>
<li><p>External device responds</p></li>
<li><p>Response comes inbound through inbound TLB</p></li>
<li><p>Verify correct translation both directions</p></li>
</ol>
<p><strong>Expected Result:</strong> Round trip translation correct</p>
<p><strong>Coverage:</strong> Bidirectional translation</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="switch-test-cases">
<h2>8. Switch Test Cases<a class="headerlink" href="#switch-test-cases" title="Permalink to this heading">¶</a></h2>
<section id="noc-pcie-switch-test-cases">
<h3>8.1 NOC-PCIE Switch Test Cases<a class="headerlink" href="#noc-pcie-switch-test-cases" title="Permalink to this heading">¶</a></h3>
<section id="tc-switch-noc-pcie-001-address-routing-based-on-axaddr-63-60">
<h4>TC_SWITCH_NOC_PCIE_001: Address Routing Based on AxADDR[63:60]<a class="headerlink" href="#tc-switch-noc-pcie-001-address-routing-based-on-axaddr-63-60" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify routing based on top 4 address bits</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with AxADDR[63:60] = 0x0</p></li>
<li><p>Verify transaction routed to TLB App Inbound Port 0</p></li>
<li><p>Send transaction with AxADDR[63:60] = 0x4</p></li>
<li><p>Verify transaction routed to TLB Sys Inbound Port</p></li>
<li><p>Send transaction with AxADDR[63:60] = 0x2</p></li>
<li><p>Verify DECERR response</p></li>
</ol>
<p><strong>Expected Result:</strong> Correct routing based on address bits</p>
<p><strong>Coverage:</strong> Address routing logic</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-pcie-002-status-register-special-routing">
<h4>TC_SWITCH_NOC_PCIE_002: Status Register Special Routing<a class="headerlink" href="#tc-switch-noc-pcie-002-status-register-special-routing" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify Status Register special routing (AxADDR[63:60] = 0xE)</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send read transaction with AxADDR[63:60] = 0xE, AxADDR[59:7] = 0</p></li>
<li><p>Verify transaction routed to Status Register (not TLB Sys)</p></li>
<li><p>Verify System Ready register value returned</p></li>
<li><p>Send write transaction with AxADDR[63:60] = 0xE, AxADDR[59:7] = 0</p></li>
<li><p>Verify Status Register updated</p></li>
<li><p>Send transaction with AxADDR[63:60] = 0xE, AxADDR[59:7] != 0</p></li>
<li><p>Verify transaction routed to TLB Sys (not Status Register)</p></li>
</ol>
<p><strong>Expected Result:</strong> Status Register routing correct</p>
<p><strong>Coverage:</strong> Special routing case</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-pcie-003-isolation-support">
<h4>TC_SWITCH_NOC_PCIE_003: Isolation Support<a class="headerlink" href="#tc-switch-noc-pcie-003-isolation-support" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify isolation behavior</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert <code class="docutils literal notranslate"><span class="pre">isolate_req</span></code> signal</p></li>
<li><p>Send transaction to switch</p></li>
<li><p>Verify DECERR response immediately</p></li>
<li><p>Deassert <code class="docutils literal notranslate"><span class="pre">isolate_req</span></code></p></li>
<li><p>Verify normal routing resumes</p></li>
</ol>
<p><strong>Expected Result:</strong> Isolation functional</p>
<p><strong>Coverage:</strong> Isolation logic</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-pcie-004-inbound-enable-control">
<h4>TC_SWITCH_NOC_PCIE_004: Inbound Enable Control<a class="headerlink" href="#tc-switch-noc-pcie-004-inbound-enable-control" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify inbound enable gating</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Set <code class="docutils literal notranslate"><span class="pre">pcie_inbound_app_enable</span></code> = 0</p></li>
<li><p>Send inbound transaction (not Status Register)</p></li>
<li><p>Verify DECERR response</p></li>
<li><p>Set <code class="docutils literal notranslate"><span class="pre">pcie_inbound_app_enable</span></code> = 1</p></li>
<li><p>Verify normal routing</p></li>
</ol>
<p><strong>Expected Result:</strong> Inbound enable control functional</p>
<p><strong>Coverage:</strong> Enable gating</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-pcie-005-bypass-path-routing">
<h4>TC_SWITCH_NOC_PCIE_005: Bypass Path Routing<a class="headerlink" href="#tc-switch-noc-pcie-005-bypass-path-routing" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify bypass path (AxADDR[63:60] = 0x8 or 0x9)</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Set <code class="docutils literal notranslate"><span class="pre">system_ready</span></code> = 1</p></li>
<li><p>Send transaction with AxADDR[63:60] = 0x8</p></li>
<li><p>Verify transaction routed to Bypass App Port (NOC-IO)</p></li>
<li><p>Send transaction with AxADDR[63:60] = 0x9</p></li>
<li><p>Verify transaction routed to Bypass Sys Port (SMN-IO)</p></li>
<li><p>Set <code class="docutils literal notranslate"><span class="pre">system_ready</span></code> = 0</p></li>
<li><p>Verify bypass path returns DECERR</p></li>
</ol>
<p><strong>Expected Result:</strong> Bypass path functional</p>
<p><strong>Coverage:</strong> Bypass logic, system ready</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-pcie-006-address-conversion-64-bit-to-52-bit">
<h4>TC_SWITCH_NOC_PCIE_006: Address Conversion (64-bit to 52-bit)<a class="headerlink" href="#tc-switch-noc-pcie-006-address-conversion-64-bit-to-52-bit" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify address conversion for NOC-IO/SMN-IO routing</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with 64-bit address to bypass port</p></li>
<li><p>Verify address converted to 52-bit for NOC-IO/SMN-IO</p></li>
<li><p>Verify top 12 bits stripped correctly</p></li>
<li><p>Verify routing preserved</p></li>
</ol>
<p><strong>Expected Result:</strong> Address conversion correct</p>
<p><strong>Coverage:</strong> Address width conversion</p>
</section>
</section>
<hr class="docutils" />
<section id="noc-io-switch-test-cases">
<h3>8.2 NOC-IO Switch Test Cases<a class="headerlink" href="#noc-io-switch-test-cases" title="Permalink to this heading">¶</a></h3>
<section id="tc-switch-noc-io-001-local-resource-routing">
<h4>TC_SWITCH_NOC_IO_001: Local Resource Routing<a class="headerlink" href="#tc-switch-noc-io-001-local-resource-routing" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify routing to local resources</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction to 0x18800000 (MSI Relay MSI)</p></li>
<li><p>Verify routed to MSI Relay port</p></li>
<li><p>Send transaction to 0x18900000 (TLB App Outbound)</p></li>
<li><p>Verify routed to TLB App Outbound</p></li>
<li><p>Send transaction to 0x18A00000 (DECERR region)</p></li>
<li><p>Verify DECERR response</p></li>
</ol>
<p><strong>Expected Result:</strong> Local routing correct</p>
<p><strong>Coverage:</strong> Address decoding</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-io-002-external-noc-routing">
<h4>TC_SWITCH_NOC_IO_002: External NOC Routing<a class="headerlink" href="#tc-switch-noc-io-002-external-noc-routing" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify routing to external NOC-N</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with address not matching local resources</p></li>
<li><p>Verify routed to NOC-N interface</p></li>
<li><p>Verify transaction forwarded to external NOC</p></li>
<li><p>Verify response propagated back</p></li>
</ol>
<p><strong>Expected Result:</strong> External routing functional</p>
<p><strong>Coverage:</strong> External interface</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-io-003-high-address-routing-axaddr-51-48">
<h4>TC_SWITCH_NOC_IO_003: High Address Routing (AxADDR[51:48])<a class="headerlink" href="#tc-switch-noc-io-003-high-address-routing-axaddr-51-48" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify routing based on AxADDR[51:48]</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with AxADDR[51:48] != 0</p></li>
<li><p>Verify routed to TLB App Outbound</p></li>
<li><p>Send transaction with AxADDR[51:48] = 0</p></li>
<li><p>Verify routed to NOC-N (if not local resource)</p></li>
</ol>
<p><strong>Expected Result:</strong> High address routing correct</p>
<p><strong>Coverage:</strong> Address bit routing</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-io-004-timeout-detection">
<h4>TC_SWITCH_NOC_IO_004: Timeout Detection<a class="headerlink" href="#tc-switch-noc-io-004-timeout-detection" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify timeout detection for hung transactions</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send read transaction to external NOC</p></li>
<li><p>Simulate timeout (no response)</p></li>
<li><p>Verify timeout signal asserted</p></li>
<li><p>Verify SLVERR response returned</p></li>
<li><p>Verify outstanding requests cleared</p></li>
</ol>
<p><strong>Expected Result:</strong> Timeout detection functional</p>
<p><strong>Coverage:</strong> Timeout logic</p>
</section>
</section>
<hr class="docutils" />
<section id="smn-io-switch-test-cases">
<h3>8.3 SMN-IO Switch Test Cases<a class="headerlink" href="#smn-io-switch-test-cases" title="Permalink to this heading">¶</a></h3>
<section id="tc-switch-smn-io-001-address-based-routing">
<h4>TC_SWITCH_SMN_IO_001: Address-Based Routing<a class="headerlink" href="#tc-switch-smn-io-001-address-based-routing" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify routing based on address map</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction to 0x18000000 (MSI Relay Config)</p></li>
<li><p>Verify routed to MSI Relay Config port</p></li>
<li><p>Send transaction to 0x18040000 (TLB Config)</p></li>
<li><p>Verify routed to TLB Config port</p></li>
<li><p>Send transaction to 0x18100000 (SII Config)</p></li>
<li><p>Verify routed to SII Config port</p></li>
</ol>
<p><strong>Expected Result:</strong> Address routing correct</p>
<p><strong>Coverage:</strong> Address map decoding</p>
</section>
<hr class="docutils" />
<section id="tc-switch-smn-io-002-serdes-routing">
<h4>TC_SWITCH_SMN_IO_002: SerDes Routing<a class="headerlink" href="#tc-switch-smn-io-002-serdes-routing" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify SerDes APB/AHB routing</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction to 0x18080000 (SerDes AHB)</p></li>
<li><p>Verify routed to SerDes AHB port</p></li>
<li><p>Send transaction to 0x180C0000 (SerDes APB)</p></li>
<li><p>Verify routed to SerDes APB port</p></li>
</ol>
<p><strong>Expected Result:</strong> SerDes routing functional</p>
<p><strong>Coverage:</strong> SerDes interface</p>
</section>
<hr class="docutils" />
<section id="tc-switch-smn-io-003-external-smn-routing">
<h4>TC_SWITCH_SMN_IO_003: External SMN Routing<a class="headerlink" href="#tc-switch-smn-io-003-external-smn-routing" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify routing to external SMN-N</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with address not matching local resources</p></li>
<li><p>Verify routed to SMN-N interface</p></li>
<li><p>Verify transaction forwarded to external SMN</p></li>
<li><p>Verify response propagated back</p></li>
</ol>
<p><strong>Expected Result:</strong> External routing functional</p>
<p><strong>Coverage:</strong> External interface</p>
</section>
<hr class="docutils" />
<section id="tc-switch-smn-io-004-timeout-detection">
<h4>TC_SWITCH_SMN_IO_004: Timeout Detection<a class="headerlink" href="#tc-switch-smn-io-004-timeout-detection" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify timeout detection</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction to external SMN</p></li>
<li><p>Simulate timeout</p></li>
<li><p>Verify timeout signal asserted</p></li>
<li><p>Verify SLVERR response</p></li>
</ol>
<p><strong>Expected Result:</strong> Timeout detection functional</p>
<p><strong>Coverage:</strong> Timeout logic</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="sii-block-test-cases">
<h2>9. SII Block Test Cases<a class="headerlink" href="#sii-block-test-cases" title="Permalink to this heading">¶</a></h2>
<section id="id1">
<h3>9.1 Register Access Tests<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h3>
<section id="tc-sii-001-configuration-register-access">
<h4>TC_SII_001: Configuration Register Access<a class="headerlink" href="#tc-sii-001-configuration-register-access" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify SII register space accessible via APB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Write to SII register space via APB</p></li>
<li><p>Read back register value</p></li>
<li><p>Verify read/write correct</p></li>
</ol>
<p><strong>Expected Result:</strong> Register access functional</p>
<p><strong>Coverage:</strong> APB interface</p>
</section>
<hr class="docutils" />
<section id="tc-sii-002-cii-tracking">
<h4>TC_SII_002: CII Tracking<a class="headerlink" href="#tc-sii-002-cii-tracking" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Implementing Test:</strong> <code class="docutils literal notranslate"><span class="pre">testDirected_SII_CiiConfigUpdate()</span></code> | <strong>Feature:</strong> CII tracking, cfg_modified accumulation, config_update interrupt | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify CII tracks configuration updates and generates config_update interrupt</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Verify config_update initially false (no CII events)</p></li>
<li><p>Assert CII valid with type=0x04 (config write), addr=0x010 (register index 4, first 128B)</p></li>
<li><p>Advance delta cycles with <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code> for signal propagation</p></li>
<li><p>Verify config_update asserted (cfg_modified bit 4 set)</p></li>
<li><p>Deassert CII header valid</p></li>
<li><p>Verify config_update stays asserted (cfg_modified bits sticky until RW1C clear)</p></li>
<li><p>Assert CII for different register (addr=0x004, register index 1)</p></li>
<li><p>Verify config_update still asserted (bits 1 and 4 now set)</p></li>
</ol>
<p><strong>Expected Result:</strong> CII tracking functional: config writes detected, cfg_modified accumulated, config_update interrupt asserted</p>
<p><strong>Coverage:</strong> CII interface, cfg_modified bitmask, interrupt generation, sticky bit behavior</p>
</section>
<hr class="docutils" />
<section id="tc-sii-003-bus-device-number-assignment">
<h4>TC_SII_003: Bus/Device Number Assignment<a class="headerlink" href="#tc-sii-003-bus-device-number-assignment" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify bus/device number outputs</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Write bus number to SII register</p></li>
<li><p>Verify app_bus_num output updated</p></li>
<li><p>Write device number to SII register</p></li>
<li><p>Verify app_dev_num output updated</p></li>
</ol>
<p><strong>Expected Result:</strong> Bus/device assignment functional</p>
<p><strong>Coverage:</strong> Control outputs</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="config-register-block-test-cases">
<h2>10. Config Register Block Test Cases<a class="headerlink" href="#config-register-block-test-cases" title="Permalink to this heading">¶</a></h2>
<section id="id2">
<h3>10.1 Register Access Tests<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<section id="tc-config-reg-001-tlb-configuration-space-access">
<h4>TC_CONFIG_REG_001: TLB Configuration Space Access<a class="headerlink" href="#tc-config-reg-001-tlb-configuration-space-access" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify TLB configuration registers accessible</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Write to TLBSysOut0 configuration space</p></li>
<li><p>Read back TLB entry</p></li>
<li><p>Verify entry configured correctly</p></li>
<li><p>Repeat for all TLB banks</p></li>
</ol>
<p><strong>Expected Result:</strong> TLB config space accessible</p>
<p><strong>Coverage:</strong> TLB configuration</p>
</section>
<hr class="docutils" />
<section id="tc-config-reg-002-system-ready-register">
<h4>TC_CONFIG_REG_002: System Ready Register<a class="headerlink" href="#tc-config-reg-002-system-ready-register" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify System Ready register behavior</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Write 1 to System Ready register (bit[0])</p></li>
<li><p>Verify system_ready output = 1</p></li>
<li><p>Write 0 to System Ready register</p></li>
<li><p>Verify system_ready output = 0</p></li>
<li><p>Verify RW1C behavior (write 1 to clear)</p></li>
</ol>
<p><strong>Expected Result:</strong> System Ready register functional</p>
<p><strong>Coverage:</strong> Status register</p>
</section>
<hr class="docutils" />
<section id="tc-config-reg-003-pcie-enable-registers">
<h4>TC_CONFIG_REG_003: PCIE Enable Registers<a class="headerlink" href="#tc-config-reg-003-pcie-enable-registers" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify PCIE enable register control</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Write 1 to bit[0] (outbound enable)</p></li>
<li><p>Verify pcie_outbound_app_enable = 1</p></li>
<li><p>Write 1 to bit[16] (inbound enable)</p></li>
<li><p>Verify pcie_inbound_app_enable = 1</p></li>
<li><p>Write 0 to both bits</p></li>
<li><p>Verify both enables = 0</p></li>
</ol>
<p><strong>Expected Result:</strong> Enable registers functional</p>
<p><strong>Coverage:</strong> Control registers</p>
</section>
<hr class="docutils" />
<section id="tc-config-reg-004-isolation-behavior">
<h4>TC_CONFIG_REG_004: Isolation Behavior<a class="headerlink" href="#tc-config-reg-004-isolation-behavior" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify isolation clears enable bits</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Set System Ready = 1, Outbound Enable = 1, Inbound Enable = 1</p></li>
<li><p>Assert isolate_req</p></li>
<li><p>Verify System Ready = 0, Outbound Enable = 0, Inbound Enable = 0</p></li>
<li><p>Deassert isolate_req</p></li>
<li><p>Verify registers maintain values (until FW reprogramming)</p></li>
</ol>
<p><strong>Expected Result:</strong> Isolation behavior correct</p>
<p><strong>Coverage:</strong> Isolation logic</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="clock-reset-test-cases">
<h2>11. Clock &amp; Reset Test Cases<a class="headerlink" href="#clock-reset-test-cases" title="Permalink to this heading">¶</a></h2>
<section id="clock-generation-tests">
<h3>11.1 Clock Generation Tests<a class="headerlink" href="#clock-generation-tests" title="Permalink to this heading">¶</a></h3>
<section id="tc-clock-reset-001-reference-clock-generation">
<h4>TC_CLOCK_RESET_001: Reference Clock Generation<a class="headerlink" href="#tc-clock-reset-001-reference-clock-generation" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify reference clock generation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Enable reference clock</p></li>
<li><p>Monitor ref_clock output</p></li>
<li><p>Verify frequency = 100 MHz (10ns period)</p></li>
<li><p>Verify clock toggles correctly</p></li>
</ol>
<p><strong>Expected Result:</strong> Reference clock functional</p>
<p><strong>Coverage:</strong> Clock generation</p>
</section>
<hr class="docutils" />
<section id="tc-clock-reset-002-pcie-clock-generation">
<h4>TC_CLOCK_RESET_002: PCIE Clock Generation<a class="headerlink" href="#tc-clock-reset-002-pcie-clock-generation" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify PCIE clock generation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Deassert cold_reset_n and warm_reset_n</p></li>
<li><p>Wait for reset deassertion</p></li>
<li><p>Monitor pcie_clock output</p></li>
<li><p>Verify frequency = 1.0 GHz (1ns period)</p></li>
<li><p>Verify clock enabled after reset</p></li>
</ol>
<p><strong>Expected Result:</strong> PCIE clock functional</p>
<p><strong>Coverage:</strong> Clock generation, reset sequence</p>
</section>
</section>
<hr class="docutils" />
<section id="reset-sequence-tests">
<h3>11.2 Reset Sequence Tests<a class="headerlink" href="#reset-sequence-tests" title="Permalink to this heading">¶</a></h3>
<section id="tc-clock-reset-003-cold-reset-sequence">
<h4>TC_CLOCK_RESET_003: Cold Reset Sequence<a class="headerlink" href="#tc-clock-reset-003-cold-reset-sequence" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify cold reset sequence</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert cold_reset_n = 0</p></li>
<li><p>Verify pcie_sii_reset_ctrl = 0, pcie_reset_ctrl = 0</p></li>
<li><p>Verify clocks disabled</p></li>
<li><p>Deassert pcie_sii_reset_ctrl (SMC FW)</p></li>
<li><p>Wait for PLL lock</p></li>
<li><p>Deassert pcie_reset_ctrl</p></li>
<li><p>Verify clocks enabled</p></li>
<li><p>Verify force_to_ref_clk_n = 1</p></li>
</ol>
<p><strong>Expected Result:</strong> Cold reset sequence correct</p>
<p><strong>Coverage:</strong> Reset sequence</p>
</section>
<hr class="docutils" />
<section id="tc-clock-reset-004-warm-reset-sequence">
<h4>TC_CLOCK_RESET_004: Warm Reset Sequence<a class="headerlink" href="#tc-clock-reset-004-warm-reset-sequence" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify warm reset sequence</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert warm_reset_n = 0</p></li>
<li><p>Verify pcie_reset_ctrl = 0 (but pcie_sii_reset_ctrl = 1)</p></li>
<li><p>Verify PCIE clock disabled</p></li>
<li><p>Deassert warm_reset_n</p></li>
<li><p>Verify PCIE clock enabled</p></li>
</ol>
<p><strong>Expected Result:</strong> Warm reset sequence correct</p>
<p><strong>Coverage:</strong> Reset sequence</p>
</section>
<hr class="docutils" />
<section id="tc-clock-reset-005-isolation-behavior">
<h4>TC_CLOCK_RESET_005: Isolation Behavior<a class="headerlink" href="#tc-clock-reset-005-isolation-behavior" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify isolation disables clocks</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Enable clocks normally</p></li>
<li><p>Assert isolate_req</p></li>
<li><p>Verify clocks disabled (gated)</p></li>
<li><p>Deassert isolate_req</p></li>
<li><p>Verify clocks re-enabled</p></li>
</ol>
<p><strong>Expected Result:</strong> Isolation clock gating functional</p>
<p><strong>Coverage:</strong> Isolation logic</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="pll-cgm-test-cases">
<h2>12. PLL/CGM Test Cases<a class="headerlink" href="#pll-cgm-test-cases" title="Permalink to this heading">¶</a></h2>
<section id="pll-lock-tests">
<h3>12.1 PLL Lock Tests<a class="headerlink" href="#pll-lock-tests" title="Permalink to this heading">¶</a></h3>
<section id="tc-pll-cgm-001-pll-lock-sequence">
<h4>TC_PLL_CGM_001: PLL Lock Sequence<a class="headerlink" href="#tc-pll-cgm-001-pll-lock-sequence" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify PLL lock sequence</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert reset_n = 0</p></li>
<li><p>Provide reference clock</p></li>
<li><p>Deassert reset_n = 1</p></li>
<li><p>Monitor pll_lock output</p></li>
<li><p>Verify lock after ~170 ref clock cycles</p></li>
<li><p>Verify pcie_clock generated after lock</p></li>
</ol>
<p><strong>Expected Result:</strong> PLL lock functional</p>
<p><strong>Coverage:</strong> PLL lock logic</p>
</section>
<hr class="docutils" />
<section id="tc-pll-cgm-002-pll-configuration">
<h4>TC_PLL_CGM_002: PLL Configuration<a class="headerlink" href="#tc-pll-cgm-002-pll-configuration" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify PLL configuration via APB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Access PLL configuration registers via APB</p></li>
<li><p>Configure lock time</p></li>
<li><p>Verify configuration applied</p></li>
<li><p>Verify lock time matches configuration</p></li>
</ol>
<p><strong>Expected Result:</strong> PLL configuration functional</p>
<p><strong>Coverage:</strong> Configuration interface</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="pcie-phy-test-cases">
<h2>13. PCIE PHY Test Cases<a class="headerlink" href="#pcie-phy-test-cases" title="Permalink to this heading">¶</a></h2>
<section id="phy-configuration-tests">
<h3>13.1 PHY Configuration Tests<a class="headerlink" href="#phy-configuration-tests" title="Permalink to this heading">¶</a></h3>
<section id="tc-phy-001-apb-configuration-access">
<h4>TC_PHY_001: APB Configuration Access<a class="headerlink" href="#tc-phy-001-apb-configuration-access" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify PHY configuration via APB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Access PHY configuration registers via APB</p></li>
<li><p>Write configuration values</p></li>
<li><p>Read back and verify</p></li>
<li><p>Verify configuration applied</p></li>
</ol>
<p><strong>Expected Result:</strong> APB configuration functional</p>
<p><strong>Coverage:</strong> APB interface</p>
</section>
<hr class="docutils" />
<section id="tc-phy-002-ahb-firmware-download">
<h4>TC_PHY_002: AHB Firmware Download<a class="headerlink" href="#tc-phy-002-ahb-firmware-download" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify firmware download via AHB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Download firmware to PHY via AHB interface</p></li>
<li><p>Verify firmware written correctly</p></li>
<li><p>Trigger PHY initialization</p></li>
<li><p>Verify phy_ready asserted after initialization</p></li>
</ol>
<p><strong>Expected Result:</strong> Firmware download functional</p>
<p><strong>Coverage:</strong> AHB interface, initialization</p>
</section>
<hr class="docutils" />
<section id="tc-phy-003-lane-reversal-support">
<h4>TC_PHY_003: Lane Reversal Support<a class="headerlink" href="#tc-phy-003-lane-reversal-support" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify lane reversal configuration</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure lane reversal via APB</p></li>
<li><p>Verify lane reversal enabled</p></li>
<li><p>Verify lane mapping correct</p></li>
</ol>
<p><strong>Expected Result:</strong> Lane reversal functional</p>
<p><strong>Coverage:</strong> Lane reversal feature</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="external-interface-test-cases">
<h2>14. External Interface Test Cases<a class="headerlink" href="#external-interface-test-cases" title="Permalink to this heading">¶</a></h2>
<section id="noc-n-interface-tests">
<h3>14.1 NOC-N Interface Tests<a class="headerlink" href="#noc-n-interface-tests" title="Permalink to this heading">¶</a></h3>
<section id="tc-external-noc-001-transaction-forwarding">
<h4>TC_EXTERNAL_NOC_001: Transaction Forwarding<a class="headerlink" href="#tc-external-noc-001-transaction-forwarding" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify transaction forwarding to external NOC</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction from NOC-IO switch</p></li>
<li><p>Verify transaction forwarded to external NOC</p></li>
<li><p>Simulate response from external NOC</p></li>
<li><p>Verify response propagated back</p></li>
</ol>
<p><strong>Expected Result:</strong> Transaction forwarding functional</p>
<p><strong>Coverage:</strong> External interface</p>
</section>
</section>
<hr class="docutils" />
<section id="smn-n-interface-tests">
<h3>14.2 SMN-N Interface Tests<a class="headerlink" href="#smn-n-interface-tests" title="Permalink to this heading">¶</a></h3>
<section id="tc-external-smn-001-transaction-forwarding">
<h4>TC_EXTERNAL_SMN_001: Transaction Forwarding<a class="headerlink" href="#tc-external-smn-001-transaction-forwarding" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify transaction forwarding to external SMN</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction from SMN-IO switch</p></li>
<li><p>Verify transaction forwarded to external SMN</p></li>
<li><p>Simulate response from external SMN</p></li>
<li><p>Verify response propagated back</p></li>
</ol>
<p><strong>Expected Result:</strong> Transaction forwarding functional</p>
<p><strong>Coverage:</strong> External interface</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="top-level-integration-test-cases">
<h2>15. Top-Level Integration Test Cases<a class="headerlink" href="#top-level-integration-test-cases" title="Permalink to this heading">¶</a></h2>
<section id="full-tile-integration">
<h3>15.1 Full Tile Integration<a class="headerlink" href="#full-tile-integration" title="Permalink to this heading">¶</a></h3>
<section id="tc-top-level-001-complete-reset-sequence">
<h4>TC_TOP_LEVEL_001: Complete Reset Sequence<a class="headerlink" href="#tc-top-level-001-complete-reset-sequence" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify complete reset sequence through top-level module</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert cold_reset_n = 0</p></li>
<li><p>Verify all components reset</p></li>
<li><p>Follow cold reset sequence</p></li>
<li><p>Verify all components initialized</p></li>
<li><p>Verify system ready</p></li>
</ol>
<p><strong>Expected Result:</strong> Reset sequence functional</p>
<p><strong>Coverage:</strong> Top-level reset</p>
</section>
<hr class="docutils" />
<section id="tc-top-level-002-end-to-end-transaction-flow">
<h4>TC_TOP_LEVEL_002: End-to-End Transaction Flow<a class="headerlink" href="#tc-top-level-002-end-to-end-transaction-flow" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify transaction flow through entire tile</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure all TLBs</p></li>
<li><p>Send transaction from PCIe Controller (inbound)</p></li>
<li><p>Verify transaction flows: Controller -&gt; NOC-PCIE -&gt; TLB -&gt; NOC-IO -&gt; External</p></li>
<li><p>Verify response flows back correctly</p></li>
</ol>
<p><strong>Expected Result:</strong> End-to-end flow functional</p>
<p><strong>Coverage:</strong> Full integration</p>
</section>
<hr class="docutils" />
<section id="tc-top-level-003-msi-end-to-end-flow">
<h4>TC_TOP_LEVEL_003: MSI End-to-End Flow<a class="headerlink" href="#tc-top-level-003-msi-end-to-end-flow" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify MSI flow through entire system</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table via TLB</p></li>
<li><p>Trigger MSI from downstream component</p></li>
<li><p>Verify MSI flows: Component -&gt; MSI Relay -&gt; NOC-PCIE -&gt; Controller</p></li>
<li><p>Verify MSI TLP generated</p></li>
</ol>
<p><strong>Expected Result:</strong> MSI flow functional</p>
<p><strong>Coverage:</strong> Interrupt path</p>
</section>
<hr class="docutils" />
<section id="tc-top-level-004-isolation-sequence">
<h4>TC_TOP_LEVEL_004: Isolation Sequence<a class="headerlink" href="#tc-top-level-004-isolation-sequence" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify isolation sequence</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Generate traffic through tile</p></li>
<li><p>Assert isolate_req</p></li>
<li><p>Verify all new transactions return DECERR</p></li>
<li><p>Verify outstanding transactions drain</p></li>
<li><p>Deassert isolate_req</p></li>
<li><p>Verify normal operation resumes</p></li>
</ol>
<p><strong>Expected Result:</strong> Isolation sequence functional</p>
<p><strong>Coverage:</strong> Isolation handling</p>
</section>
<hr class="docutils" />
<section id="tc-top-level-005-multiple-clock-domain-operation">
<h4>TC_TOP_LEVEL_005: Multiple Clock Domain Operation<a class="headerlink" href="#tc-top-level-005-multiple-clock-domain-operation" title="Permalink to this heading">¶</a></h4>
<p><strong>Objective:</strong> Verify operation with multiple clock domains</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Provide all required clocks (PCIE, NOC, SOC, AHB, Ref)</p></li>
<li><p>Generate transactions on different clock domains</p></li>
<li><p>Verify CDC logic handles crossings correctly</p></li>
<li><p>Verify no data corruption</p></li>
</ol>
<p><strong>Expected Result:</strong> Multi-clock operation functional</p>
<p><strong>Coverage:</strong> Clock domain crossing</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="end-to-end-test-cases">
<h2>16. End-to-End Test Cases<a class="headerlink" href="#end-to-end-test-cases" title="Permalink to this heading">¶</a></h2>
<p><strong>Note:</strong> After refactoring to eliminate E126 errors, all internal sub-modules are now C++ classes with function-based communication. Only the top-level <code class="docutils literal notranslate"><span class="pre">KeraunosPcieTile</span></code> has TLM sockets. These E2E tests verify complete data paths through the refactored architecture.</p>
<section id="inbound-data-paths-pcie-noc-smn">
<h3>16.1 Inbound Data Paths (PCIe → NOC/SMN)<a class="headerlink" href="#inbound-data-paths-pcie-noc-smn" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-inbound-001-pcie-read-tlb-app0-noc-n">
<h4>TC_E2E_INBOUND_001: PCIe Read → TLB App0 → NOC-N<a class="headerlink" href="#tc-e2e-inbound-001-pcie-read-tlb-app0-noc-n" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieRead_TlbApp0_NocN()</span></code> | <strong>Feature:</strong> Inbound Read Data Path | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify complete inbound read path from PCIe Controller through TLB App0 to NOC-N</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB App In0 entry 0: valid=1, addr=0x80000000</p></li>
<li><p>Send TLM read from <code class="docutils literal notranslate"><span class="pre">pcie_controller_target</span></code> with addr=0x0000000001000000 (route=0)</p></li>
<li><p>NOC-PCIE switch routes to TLB App In0</p></li>
<li><p>TLB translates to 0x80001000000</p></li>
<li><p>NOC-IO switch routes to NOC-N external</p></li>
<li><p>Verify transaction arrives at <code class="docutils literal notranslate"><span class="pre">noc_n_initiator</span></code> with translated address</p></li>
<li><p>Return read data, verify response propagates back</p></li>
</ol>
<p><strong>Expected Result:</strong> Complete E2E read with correct address translation</p>
<p><strong>Coverage:</strong> Inbound read path, TLB App0, switch routing</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-inbound-002-pcie-write-tlb-app1-noc-n">
<h4>TC_E2E_INBOUND_002: PCIe Write → TLB App1 → NOC-N<a class="headerlink" href="#tc-e2e-inbound-002-pcie-write-tlb-app1-noc-n" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN()</span></code> | <strong>Feature:</strong> Inbound Write Data Path (Large Pages) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify inbound write path via TLB App1</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB App In1 entry: valid=1, addr=0x100000000 (large page)</p></li>
<li><p>Send TLM write from <code class="docutils literal notranslate"><span class="pre">pcie_controller_target</span></code> with addr=0x1000000000000000 (route=1)</p></li>
<li><p>Verify routing: PCIe → NOC-PCIE → TLB App In1 → NOC-IO → NOC-N</p></li>
<li><p>Verify write data integrity throughout path</p></li>
<li><p>Verify response propagates back</p></li>
</ol>
<p><strong>Expected Result:</strong> Write completes successfully with translation</p>
<p><strong>Coverage:</strong> Inbound write path, TLB App1, large pages</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-inbound-003-pcie-tlb-sys-smn-n">
<h4>TC_E2E_INBOUND_003: PCIe → TLB Sys → SMN-N<a class="headerlink" href="#tc-e2e-inbound-003-pcie-tlb-sys-smn-n" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_Pcie_TlbSys_SmnN()</span></code> | <strong>Feature:</strong> System Management Inbound Path | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify system management path</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB Sys In0: valid=1, addr=0x18000000</p></li>
<li><p>Send config write from <code class="docutils literal notranslate"><span class="pre">pcie_controller_target</span></code> with addr=0x4000000000000000 (route=4)</p></li>
<li><p>Verify: PCIe → NOC-PCIE → TLB Sys In0 → SMN-IO → SMN-N</p></li>
<li><p>Check system ready flag handling</p></li>
<li><p>Verify transaction reaches <code class="docutils literal notranslate"><span class="pre">smn_n_initiator</span></code></p></li>
</ol>
<p><strong>Expected Result:</strong> Config write completes via SMN path</p>
<p><strong>Coverage:</strong> System management path, TLB Sys, SMN routing</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-inbound-004-pcie-bypass-app-path">
<h4>TC_E2E_INBOUND_004: PCIe Bypass App Path<a class="headerlink" href="#tc-e2e-inbound-004-pcie-bypass-app-path" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassApp()</span></code> | <strong>Feature:</strong> Application Bypass Routing (route=0x8) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify bypass path (no TLB translation)</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction from <code class="docutils literal notranslate"><span class="pre">pcie_controller_target</span></code> with addr=0x8000000000000000 (route=8)</p></li>
<li><p>Verify NOC-PCIE routes directly to NOC-IO (bypass TLB)</p></li>
<li><p>Verify address unchanged (no translation)</p></li>
<li><p>Transaction reaches NOC-N</p></li>
</ol>
<p><strong>Expected Result:</strong> Bypass path works, no TLB used</p>
<p><strong>Coverage:</strong> Bypass routing, address pass-through</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-inbound-005-pcie-bypass-sys-path">
<h4>TC_E2E_INBOUND_005: PCIe Bypass Sys Path<a class="headerlink" href="#tc-e2e-inbound-005-pcie-bypass-sys-path" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassSys()</span></code> | <strong>Feature:</strong> System Bypass Routing (route=0x9) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify system bypass path</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with addr=0x9000000000000000 (route=9)</p></li>
<li><p>Verify routing: PCIe → NOC-PCIE → SMN-IO → SMN-N (no TLB)</p></li>
<li><p>Address unchanged</p></li>
</ol>
<p><strong>Expected Result:</strong> System bypass successful</p>
<p><strong>Coverage:</strong> System bypass routing</p>
</section>
</section>
<hr class="docutils" />
<section id="outbound-data-paths-noc-smn-pcie">
<h3>16.2 Outbound Data Paths (NOC/SMN → PCIe)<a class="headerlink" href="#outbound-data-paths-noc-smn-pcie" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-outbound-001-noc-n-tlb-app-out0-pcie">
<h4>TC_E2E_OUTBOUND_001: NOC-N → TLB App Out0 → PCIe<a class="headerlink" href="#tc-e2e-outbound-001-noc-n-tlb-app-out0-pcie" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut0_Pcie()</span></code> | <strong>Feature:</strong> Outbound Read via Reverse TLB Translation | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify outbound path from NOC to PCIe via TLB App Out0</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB App Out0: valid=1, addr=0xA000000000000 (IATU addr)</p></li>
<li><p>Send read from <code class="docutils literal notranslate"><span class="pre">noc_n_target</span></code> with addr=0x10001000000000 (large addr)</p></li>
<li><p>NOC-IO routes to TLB App Out0</p></li>
<li><p>TLB translates to PCIe IATU address</p></li>
<li><p>NOC-PCIE routes to PCIe Controller</p></li>
<li><p>Verify transaction arrives at <code class="docutils literal notranslate"><span class="pre">pcie_controller_initiator</span></code></p></li>
</ol>
<p><strong>Expected Result:</strong> Outbound read completes with reverse translation</p>
<p><strong>Coverage:</strong> Outbound path, reverse TLB, large address handling</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-outbound-002-smn-n-tlb-sys-out0-pcie">
<h4>TC_E2E_OUTBOUND_002: SMN-N → TLB Sys Out0 → PCIe<a class="headerlink" href="#tc-e2e-outbound-002-smn-n-tlb-sys-out0-pcie" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_SmnN_TlbSysOut0_Pcie()</span></code> | <strong>Feature:</strong> System Outbound DBI Access | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify system outbound path</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB Sys Out0: valid=1, addr=0x4000000000 (DBI)</p></li>
<li><p>Send write from <code class="docutils literal notranslate"><span class="pre">smn_n_target</span></code> with system address</p></li>
<li><p>Verify: SMN-N → SMN-IO → TLB Sys Out0 → NOC-PCIE → PCIe</p></li>
<li><p>Translation converts to PCIe DBI address</p></li>
<li><p>Write completes at PCIe controller</p></li>
</ol>
<p><strong>Expected Result:</strong> DBI write successful</p>
<p><strong>Coverage:</strong> System outbound, DBI access, reverse translation</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-outbound-003-noc-n-tlb-app-out1-pcie-dbi">
<h4>TC_E2E_OUTBOUND_003: NOC-N → TLB App Out1 → PCIe DBI<a class="headerlink" href="#tc-e2e-outbound-003-noc-n-tlb-app-out1-pcie-dbi" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut1_PcieDBI()</span></code> | <strong>Feature:</strong> Application DBI Access (64KB Pages) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify application DBI access path</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB App Out1: valid=1, addr=0x9000000000 (DBI)</p></li>
<li><p>Send config read from <code class="docutils literal notranslate"><span class="pre">noc_n_target</span></code> with small address</p></li>
<li><p>NOC-IO routes to TLB App Out1 (64KB pages)</p></li>
<li><p>Translate to PCIe DBI</p></li>
<li><p>Read config space from PCIe</p></li>
</ol>
<p><strong>Expected Result:</strong> Config space read successful</p>
<p><strong>Coverage:</strong> DBI access, small page TLB</p>
</section>
</section>
<hr class="docutils" />
<section id="configuration-paths-smn-tlb-sii-msi-config">
<h3>16.3 Configuration Paths (SMN → TLB/SII/MSI Config)<a class="headerlink" href="#configuration-paths-smn-tlb-sii-msi-config" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-config-001-smn-n-tlb-config">
<h4>TC_E2E_CONFIG_001: SMN-N → TLB Config<a class="headerlink" href="#tc-e2e-config-001-smn-n-tlb-config" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToTlb()</span></code> | <strong>Feature:</strong> TLB Configuration via SMN Path | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify TLB configuration path</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send APB write to <code class="docutils literal notranslate"><span class="pre">smn_n_target</span></code> with addr=0x18210000 (TLB App In0[0] config)</p></li>
<li><p>SMN-IO routes to TLB App In0[0] config interface</p></li>
<li><p>Write TLB entry: valid=1, addr=0x90000000</p></li>
<li><p>Read back and verify</p></li>
<li><p>Use TLB for translation to confirm config applied</p></li>
</ol>
<p><strong>Expected Result:</strong> TLB configuration successful, translation uses new entry</p>
<p><strong>Coverage:</strong> TLB configuration path, config persistence</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-config-002-smn-n-sii-config">
<h4>TC_E2E_CONFIG_002: SMN-N → SII Config<a class="headerlink" href="#tc-e2e-config-002-smn-n-sii-config" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToSII()</span></code> | <strong>Feature:</strong> SII Bus/Device Number Configuration | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify SII configuration</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send APB write to <code class="docutils literal notranslate"><span class="pre">smn_n_target</span></code> with addr=0x18101000 (SII config)</p></li>
<li><p>Write bus/device numbers</p></li>
<li><p>Verify SII outputs updated: app_bus_num, app_dev_num</p></li>
<li><p>Read back via APB</p></li>
</ol>
<p><strong>Expected Result:</strong> SII config applied, outputs updated</p>
<p><strong>Coverage:</strong> SII configuration, bus/dev assignment</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-config-003-smn-n-msi-relay-config">
<h4>TC_E2E_CONFIG_003: SMN-N → MSI Relay Config<a class="headerlink" href="#tc-e2e-config-003-smn-n-msi-relay-config" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToMsiRelay()</span></code> | <strong>Feature:</strong> MSI-X Table Configuration and Persistence | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify MSI-X table configuration</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send APB write to <code class="docutils literal notranslate"><span class="pre">smn_n_target</span></code> with addr=0x18100000 (MSI config)</p></li>
<li><p>Configure MSI-X table entry 0: addr=0x80001000, data=0x1234</p></li>
<li><p>Set vector unmasked, enable MSI-X</p></li>
<li><p>Trigger interrupt with SETIP</p></li>
<li><p>Verify MSI write appears at NOC-N with correct addr/data</p></li>
</ol>
<p><strong>Expected Result:</strong> MSI-X configuration and generation successful</p>
<p><strong>Coverage:</strong> MSI config path, interrupt flow</p>
</section>
</section>
<hr class="docutils" />
<section id="msi-interrupt-flows">
<h3>16.4 MSI Interrupt Flows<a class="headerlink" href="#msi-interrupt-flows" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-msi-001-msi-generation-noc-n">
<h4>TC_E2E_MSI_001: MSI Generation → NOC-N<a class="headerlink" href="#tc-e2e-msi-001-msi-generation-noc-n" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN()</span></code> | <strong>Feature:</strong> MSI Generation and NOC-N Routing | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify MSI interrupt from relay to NOC</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table via SMN config path</p></li>
<li><p>Set SETIP bit for vector 5</p></li>
<li><p>Enable MSI-X globally</p></li>
<li><p>Process pending MSIs</p></li>
<li><p>Verify MSI write transaction appears at <code class="docutils literal notranslate"><span class="pre">noc_n_initiator</span></code></p></li>
<li><p>Verify PBA bit cleared after successful send</p></li>
</ol>
<p><strong>Expected Result:</strong> MSI generated and sent to NOC</p>
<p><strong>Coverage:</strong> MSI thrower logic, NOC routing</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-msi-002-downstream-msi-input-processing">
<h4>TC_E2E_MSI_002: Downstream MSI Input → Processing<a class="headerlink" href="#tc-e2e-msi-002-downstream-msi-input-processing" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_MSI_DownstreamInput_Processing()</span></code> | <strong>Feature:</strong> Downstream MSI Relay Input Path | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify MSI received from downstream</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send MSI write to <code class="docutils literal notranslate"><span class="pre">noc_n_target</span></code> with addr=0x18800000 (MSI Relay input)</p></li>
<li><p>MSI Relay sets PBA bit</p></li>
<li><p>Enable MSI-X</p></li>
<li><p>MSI Relay generates MSI to NOC-N</p></li>
<li><p>Verify complete flow</p></li>
</ol>
<p><strong>Expected Result:</strong> Downstream MSI processed and forwarded</p>
<p><strong>Coverage:</strong> MSI relay input path, PBA update</p>
</section>
</section>
<hr class="docutils" />
<section id="status-register-access">
<h3>16.5 Status Register Access<a class="headerlink" href="#status-register-access" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-status-001-status-register-read-route-0xe">
<h4>TC_E2E_STATUS_001: Status Register Read (Route 0xE)<a class="headerlink" href="#tc-e2e-status-001-status-register-read-route-0xe" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_Read_Route0xE()</span></code> | <strong>Feature:</strong> NOC-PCIE Switch Status Register Special Routing | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify special status register access</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Set system_ready = true in config registers</p></li>
<li><p>Send read from <code class="docutils literal notranslate"><span class="pre">pcie_controller_target</span></code> with addr=0xE000000000000000 (route=0xE)</p></li>
<li><p>NOC-PCIE switch handles internally (no TLB)</p></li>
<li><p>Returns status register value (system_ready bit)</p></li>
<li><p>No external routing</p></li>
</ol>
<p><strong>Expected Result:</strong> Status returned directly, no NOC access</p>
<p><strong>Coverage:</strong> Status register special routing, system ready</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-status-002-status-register-disabled-access">
<h4>TC_E2E_STATUS_002: Status Register Disabled Access<a class="headerlink" href="#tc-e2e-status-002-status-register-disabled-access" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_DisabledAccess()</span></code> | <strong>Feature:</strong> Status Register Access Control (System Not Ready) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify status register blocked when system not ready</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Set system_ready = false</p></li>
<li><p>Send read with addr=0xE000000000000000</p></li>
<li><p>Verify DECERR or normal routing (not status)</p></li>
</ol>
<p><strong>Expected Result:</strong> Status register not accessible when disabled</p>
<p><strong>Coverage:</strong> Status register access control</p>
</section>
</section>
<hr class="docutils" />
<section id="isolation-and-error-handling">
<h3>16.6 Isolation and Error Handling<a class="headerlink" href="#isolation-and-error-handling" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-isolation-001-global-isolation">
<h4>TC_E2E_ISOLATION_001: Global Isolation<a class="headerlink" href="#tc-e2e-isolation-001-global-isolation" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_GlobalBlock()</span></code> | <strong>Feature:</strong> Global Isolation (Block All Data Traffic) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify isolation blocks all traffic</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert isolate_req signal</p></li>
<li><p>Send transactions to all ports: noc_n, smn_n, pcie_controller</p></li>
<li><p>Verify all return DECERR</p></li>
<li><p>Verify timeout signals asserted</p></li>
<li><p>Deassert isolate_req</p></li>
<li><p>Verify traffic resumes</p></li>
</ol>
<p><strong>Expected Result:</strong> Isolation blocks all data paths, recovery works</p>
<p><strong>Coverage:</strong> Isolation mechanism, all switches, timeout generation</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-isolation-002-config-access-during-isolation">
<h4>TC_E2E_ISOLATION_002: Config Access During Isolation<a class="headerlink" href="#tc-e2e-isolation-002-config-access-during-isolation" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_ConfigAccessAllowed()</span></code> | <strong>Feature:</strong> Selective Isolation (Config Path Exception) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify config access remains available during isolation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert isolate_req</p></li>
<li><p>Send config writes to SMN-N (SII, MSI config)</p></li>
<li><p>Verify config writes succeed (isolation doesn’t block config)</p></li>
<li><p>Send data transactions (blocked)</p></li>
</ol>
<p><strong>Expected Result:</strong> Config accessible, data blocked</p>
<p><strong>Coverage:</strong> Selective isolation, config path exception</p>
</section>
</section>
<hr class="docutils" />
<section id="multi-path-concurrent-traffic">
<h3>16.7 Multi-Path Concurrent Traffic<a class="headerlink" href="#multi-path-concurrent-traffic" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-concurrent-001-simultaneous-inbound-outbound">
<h4>TC_E2E_CONCURRENT_001: Simultaneous Inbound + Outbound<a class="headerlink" href="#tc-e2e-concurrent-001-simultaneous-inbound-outbound" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_InboundOutbound()</span></code> | <strong>Feature:</strong> Concurrent Bidirectional Traffic (No Interference) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify concurrent bidirectional traffic</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send PCIe read (inbound path) simultaneously with NOC write (outbound path)</p></li>
<li><p>Verify both complete without interference</p></li>
<li><p>Check no transaction corruption</p></li>
<li><p>Verify ordering maintained per path</p></li>
</ol>
<p><strong>Expected Result:</strong> Both paths work concurrently</p>
<p><strong>Coverage:</strong> Concurrent operation, no resource conflicts</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-concurrent-002-multiple-tlb-simultaneous-access">
<h4>TC_E2E_CONCURRENT_002: Multiple TLB Simultaneous Access<a class="headerlink" href="#tc-e2e-concurrent-002-multiple-tlb-simultaneous-access" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_MultipleTlbs()</span></code> | <strong>Feature:</strong> TLB Array Concurrent Access and Config | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify multiple TLBs can be accessed concurrently</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transactions to TLB App In0[0], [1], [2], [3] simultaneously</p></li>
<li><p>Configure different TLBs via SMN concurrently</p></li>
<li><p>Verify no conflicts, all complete</p></li>
</ol>
<p><strong>Expected Result:</strong> TLB array supports concurrent access</p>
<p><strong>Coverage:</strong> TLB array, concurrent config and data</p>
</section>
</section>
<hr class="docutils" />
<section id="reset-and-initialization-sequences">
<h3>16.8 Reset and Initialization Sequences<a class="headerlink" href="#reset-and-initialization-sequences" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-reset-001-cold-reset-sequence">
<h4>TC_E2E_RESET_001: Cold Reset Sequence<a class="headerlink" href="#tc-e2e-reset-001-cold-reset-sequence" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Reset_ColdResetSequence()</span></code> | <strong>Feature:</strong> Cold Reset and Full Reinitialization | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify complete cold reset flow</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert cold_reset_n = 0</p></li>
<li><p>Verify all internal states cleared</p></li>
<li><p>Verify all outputs in reset state</p></li>
<li><p>Deassert cold_reset_n = 1</p></li>
<li><p>Configure tile (TLBs, MSI, SII)</p></li>
<li><p>Send test transactions</p></li>
<li><p>Verify normal operation</p></li>
</ol>
<p><strong>Expected Result:</strong> Clean reset and initialization</p>
<p><strong>Coverage:</strong> Cold reset, initialization sequence</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-reset-002-warm-reset-sequence">
<h4>TC_E2E_RESET_002: Warm Reset Sequence<a class="headerlink" href="#tc-e2e-reset-002-warm-reset-sequence" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Reset_WarmResetSequence()</span></code> | <strong>Feature:</strong> Warm Reset (Config Preservation) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify warm reset (preserves config)</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLBs and MSI</p></li>
<li><p>Assert warm_reset_n = 0 (cold_reset_n = 1)</p></li>
<li><p>Verify data path blocked</p></li>
<li><p>Verify config preserved</p></li>
<li><p>Deassert warm_reset_n</p></li>
<li><p>Verify transactions resume without reconfiguration</p></li>
</ol>
<p><strong>Expected Result:</strong> Warm reset blocks data, preserves config</p>
<p><strong>Coverage:</strong> Warm reset, config persistence</p>
</section>
</section>
<hr class="docutils" />
<section id="complete-transaction-flows">
<h3>16.9 Complete Transaction Flows<a class="headerlink" href="#complete-transaction-flows" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-flow-001-pcie-memory-read-noc-memory-response">
<h4>TC_E2E_FLOW_001: PCIe Memory Read → NOC → Memory → Response<a class="headerlink" href="#tc-e2e-flow-001-pcie-memory-read-noc-memory-response" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryRead_Complete()</span></code> | <strong>Feature:</strong> Complete PCIe Memory Read Cycle (End-to-End) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Full memory read flow</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure complete inbound path (TLB, switches, enables)</p></li>
<li><p>PCIe sends memory read to addr=0x0123456789ABC (via TLB App In0)</p></li>
<li><p>Translate to physical addr</p></li>
<li><p>Route via NOC-IO to NOC-N</p></li>
<li><p>External memory responds with data</p></li>
<li><p>Response propagates back: NOC-N → NOC-IO → TLB → NOC-PCIE → PCIe</p></li>
<li><p>Verify data integrity end-to-end</p></li>
<li><p>Verify latency within spec</p></li>
</ol>
<p><strong>Expected Result:</strong> Complete read cycle successful</p>
<p><strong>Coverage:</strong> Full inbound read flow, response path</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-flow-002-pcie-memory-write-noc-memory-completion">
<h4>TC_E2E_FLOW_002: PCIe Memory Write → NOC → Memory → Completion<a class="headerlink" href="#tc-e2e-flow-002-pcie-memory-write-noc-memory-completion" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryWrite_Complete()</span></code> | <strong>Feature:</strong> Complete PCIe Memory Write Cycle (End-to-End) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Full memory write flow</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure outbound enables</p></li>
<li><p>PCIe sends memory write with 256-bit data</p></li>
<li><p>Path: PCIe → NOC-PCIE → TLB App In0 → NOC-IO → NOC-N → Memory</p></li>
<li><p>Verify write data intact</p></li>
<li><p>Response returns</p></li>
<li><p>Verify write completion signaled</p></li>
</ol>
<p><strong>Expected Result:</strong> Write completes successfully</p>
<p><strong>Coverage:</strong> Full inbound write flow, large data</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-flow-003-noc-memory-read-pcie-controller">
<h4>TC_E2E_FLOW_003: NOC Memory Read → PCIe Controller<a class="headerlink" href="#tc-e2e-flow-003-noc-memory-read-pcie-controller" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Flow_NocMemoryRead_ToPcie()</span></code> | <strong>Feature:</strong> Outbound NOC-to-PCIe Memory Read | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Outbound read from NOC to PCIe</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB App Out0 for large address space</p></li>
<li><p>NOC sends read with addr &gt; 256TB</p></li>
<li><p>Path: NOC-N → NOC-IO → TLB App Out0 → NOC-PCIE → PCIe</p></li>
<li><p>PCIe returns data</p></li>
<li><p>Response: PCIe → NOC-PCIE → TLB → NOC-IO → NOC-N</p></li>
</ol>
<p><strong>Expected Result:</strong> Outbound read successful</p>
<p><strong>Coverage:</strong> Outbound read, reverse translation</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-flow-004-smn-config-write-pcie-dbi">
<h4>TC_E2E_FLOW_004: SMN Config Write → PCIe DBI<a class="headerlink" href="#tc-e2e-flow-004-smn-config-write-pcie-dbi" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Flow_SmnConfigWrite_PcieDBI()</span></code> | <strong>Feature:</strong> SMN-to-PCIe DBI Configuration Access | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> DBI access from SMN</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>SMN sends config write to DBI address</p></li>
<li><p>Path: SMN-N → SMN-IO → TLB Sys Out0 → NOC-PCIE → PCIe DBI</p></li>
<li><p>PCIe DBI responds</p></li>
<li><p>Response returns via same path</p></li>
</ol>
<p><strong>Expected Result:</strong> DBI config write successful</p>
<p><strong>Coverage:</strong> DBI path, SMN-to-PCIe routing</p>
</section>
</section>
<hr class="docutils" />
<section id="error-injection-and-recovery">
<h3>16.10 Error Injection and Recovery<a class="headerlink" href="#error-injection-and-recovery" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-error-001-invalid-tlb-entry">
<h4>TC_E2E_ERROR_001: Invalid TLB Entry<a class="headerlink" href="#tc-e2e-error-001-invalid-tlb-entry" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Error_InvalidTlbEntry()</span></code> | <strong>Feature:</strong> TLB Invalid Entry Error Detection and Recovery | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify error handling with invalid TLB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB entry: valid=0</p></li>
<li><p>Send transaction that maps to invalid entry</p></li>
<li><p>Verify DECERR returned</p></li>
<li><p>Verify no downstream propagation</p></li>
<li><p>Configure entry: valid=1</p></li>
<li><p>Retry transaction</p></li>
<li><p>Verify success</p></li>
</ol>
<p><strong>Expected Result:</strong> Error detected, recovery works</p>
<p><strong>Coverage:</strong> TLB error detection, error propagation</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-error-002-timeout-handling">
<h4>TC_E2E_ERROR_002: Timeout Handling<a class="headerlink" href="#tc-e2e-error-002-timeout-handling" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Error_TimeoutHandling()</span></code> | <strong>Feature:</strong> Timeout Detection and Recovery on Stalled Transactions | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify timeout on stalled transactions</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction to NOC-N</p></li>
<li><p>Don’t respond (simulate stall)</p></li>
<li><p>Wait for timeout period</p></li>
<li><p>Verify timeout signal asserted</p></li>
<li><p>Verify error response returned</p></li>
<li><p>Clear timeout, verify recovery</p></li>
</ol>
<p><strong>Expected Result:</strong> Timeout detected and handled</p>
<p><strong>Coverage:</strong> Timeout mechanism, error recovery</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-error-003-address-decode-error">
<h4>TC_E2E_ERROR_003: Address Decode Error<a class="headerlink" href="#tc-e2e-error-003-address-decode-error" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Error_AddressDecodeError()</span></code> | <strong>Feature:</strong> Address Decode DECERR for Unmapped Regions | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify DECERR for unmapped addresses</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with route=0xA (DECERR region)</p></li>
<li><p>Verify NOC-PCIE returns DECERR immediately</p></li>
<li><p>No downstream routing</p></li>
<li><p>Send to DECERR region in NOC-IO (0x18A00000)</p></li>
<li><p>Verify DECERR returned</p></li>
</ol>
<p><strong>Expected Result:</strong> DECERR for all unmapped regions</p>
<p><strong>Coverage:</strong> Address decode, DECERR handling</p>
</section>
</section>
<hr class="docutils" />
<section id="msi-x-end-to-end-flow">
<h3>16.11 MSI-X End-to-End Flow<a class="headerlink" href="#msi-x-end-to-end-flow" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-msix-001-complete-msi-x-interrupt-flow">
<h4>TC_E2E_MSIX_001: Complete MSI-X Interrupt Flow<a class="headerlink" href="#tc-e2e-msix-001-complete-msi-x-interrupt-flow" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_CompleteMsixInterruptFlow()</span></code> | <strong>Feature:</strong> Complete MSI-X Interrupt Config, Generation, and Delivery | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify entire MSI-X interrupt generation and delivery</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table via SMN: addr=0x18100000, entry[0]={addr:0x80002000, data:0x5678}</p></li>
<li><p>Downstream device writes to MSI Relay: addr=0x18800000, data=vector_0</p></li>
<li><p>MSI Relay sets PBA[0]</p></li>
<li><p>Enable MSI-X, unmask vector 0</p></li>
<li><p>MSI Relay generates AXI write to addr=0x80002000, data=0x5678</p></li>
<li><p>Route via NOC-IO to NOC-N</p></li>
<li><p>External interrupt controller receives MSI</p></li>
<li><p>PBA[0] cleared</p></li>
<li><p>Read PBA and verify cleared</p></li>
</ol>
<p><strong>Expected Result:</strong> Complete MSI-X flow successful</p>
<p><strong>Coverage:</strong> MSI config, generation, routing, PBA management</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-msix-002-multiple-vector-interrupts">
<h4>TC_E2E_MSIX_002: Multiple Vector Interrupts<a class="headerlink" href="#tc-e2e-msix-002-multiple-vector-interrupts" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_MultipleVectors()</span></code> | <strong>Feature:</strong> Multiple MSI-X Vector Configuration and Handling | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify multiple MSI-X vectors</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure 4 MSI-X vectors with different addresses</p></li>
<li><p>Set PBA bits for vectors 0, 2, 5, 7</p></li>
<li><p>Enable MSI-X</p></li>
<li><p>Verify each MSI generated sequentially</p></li>
<li><p>Verify correct address/data per vector</p></li>
<li><p>Verify PBA bits cleared</p></li>
</ol>
<p><strong>Expected Result:</strong> Multiple MSI-X vectors delivered correctly</p>
<p><strong>Coverage:</strong> Multi-vector MSI, sequential processing</p>
</section>
</section>
<hr class="docutils" />
<section id="clock-domain-crossing">
<h3>16.12 Clock Domain Crossing<a class="headerlink" href="#clock-domain-crossing" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-cdc-001-axi-clock-pcie-clock">
<h4>TC_E2E_CDC_001: AXI Clock → PCIe Clock<a class="headerlink" href="#tc-e2e-cdc-001-axi-clock-pcie-clock" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_CDC_AxiToPcieClock()</span></code> | <strong>Feature:</strong> Clock Domain Crossing (AXI ↔ PCIe Core) in SII | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify clock domain crossing in SII</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send config write on axi_clk domain to SII</p></li>
<li><p>Verify data synchronized to pcie_core_clk domain</p></li>
<li><p>SII outputs update on pcie_core_clk</p></li>
<li><p>Send CII update on pcie_core_clk</p></li>
<li><p>Verify interrupt generated to axi_clk domain</p></li>
</ol>
<p><strong>Expected Result:</strong> CDC works correctly, no metastability</p>
<p><strong>Coverage:</strong> Clock domain crossing, SII CDC logic</p>
</section>
</section>
<hr class="docutils" />
<section id="performance-and-stress-tests">
<h3>16.13 Performance and Stress Tests<a class="headerlink" href="#performance-and-stress-tests" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-perf-001-maximum-throughput-test">
<h4>TC_E2E_PERF_001: Maximum Throughput Test<a class="headerlink" href="#tc-e2e-perf-001-maximum-throughput-test" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Perf_MaximumThroughput()</span></code> | <strong>Feature:</strong> Maximum Transaction Rate (Back-to-Back Burst) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify tile handles maximum transaction rate</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send back-to-back transactions on all ports</p></li>
<li><p>PCIe inbound at max rate</p></li>
<li><p>NOC/SMN outbound at max rate</p></li>
<li><p>MSI interrupts at max rate</p></li>
<li><p>Monitor for buffer overflow, dropped transactions</p></li>
<li><p>Verify all complete successfully</p></li>
</ol>
<p><strong>Expected Result:</strong> No transactions lost, all complete</p>
<p><strong>Coverage:</strong> Performance limits, buffer management</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-stress-001-address-space-sweep">
<h4>TC_E2E_STRESS_001: Address Space Sweep<a class="headerlink" href="#tc-e2e-stress-001-address-space-sweep" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Stress_AddressSpaceSweep()</span></code> | <strong>Feature:</strong> Complete Address Space Routing Sweep (All Routes) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Sweep entire address space</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transactions to all possible route values (0x0-0xF)</p></li>
<li><p>Send to all address ranges (TLB, config, MSI, DECERR)</p></li>
<li><p>Mix reads and writes</p></li>
<li><p>Verify correct routing for each</p></li>
<li><p>Verify no unexpected errors</p></li>
</ol>
<p><strong>Expected Result:</strong> All addresses handled correctly</p>
<p><strong>Coverage:</strong> Complete address space, routing table</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-stress-002-tlb-entry-exhaustion">
<h4>TC_E2E_STRESS_002: TLB Entry Exhaustion<a class="headerlink" href="#tc-e2e-stress-002-tlb-entry-exhaustion" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Stress_TlbEntryExhaustion()</span></code> | <strong>Feature:</strong> Full TLB Capacity (64 Entries) and Dynamic Reconfiguration | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify behavior with all TLB entries used</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure all 64 entries in TLB App In0</p></li>
<li><p>Send transactions that map to each entry</p></li>
<li><p>Verify all translations correct</p></li>
<li><p>Reconfigure entries during traffic</p></li>
<li><p>Verify atomic update</p></li>
</ol>
<p><strong>Expected Result:</strong> Full TLB usage works, dynamic reconfiguration</p>
<p><strong>Coverage:</strong> TLB capacity, dynamic config</p>
</section>
</section>
<hr class="docutils" />
<section id="power-management">
<h3>16.14 Power Management<a class="headerlink" href="#power-management" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-power-001-isolation-mode-entry-exit">
<h4>TC_E2E_POWER_001: Isolation Mode Entry/Exit<a class="headerlink" href="#tc-e2e-power-001-isolation-mode-entry-exit" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Power_IsolationModeEntryExit()</span></code> | <strong>Feature:</strong> Power Management Isolation Entry/Exit with Traffic | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify complete isolation sequence</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Normal operation with active traffic</p></li>
<li><p>Assert isolate_req</p></li>
<li><p>Verify in-flight transactions complete</p></li>
<li><p>Verify new transactions blocked</p></li>
<li><p>Verify config access still available</p></li>
<li><p>Deassert isolate_req</p></li>
<li><p>Verify traffic resumes</p></li>
</ol>
<p><strong>Expected Result:</strong> Clean isolation entry/exit</p>
<p><strong>Coverage:</strong> Isolation, power management, recovery</p>
</section>
</section>
<hr class="docutils" />
<section id="system-integration-scenarios">
<h3>16.15 System Integration Scenarios<a class="headerlink" href="#system-integration-scenarios" title="Permalink to this heading">¶</a></h3>
<section id="tc-e2e-system-001-boot-sequence">
<h4>TC_E2E_SYSTEM_001: Boot Sequence<a class="headerlink" href="#tc-e2e-system-001-boot-sequence" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_System_BootSequence()</span></code> | <strong>Feature:</strong> Complete Tile Boot and Initialization | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify complete tile initialization</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Cold reset asserted</p></li>
<li><p>Release cold reset</p></li>
<li><p>PLL locks</p></li>
<li><p>PHY initializes</p></li>
<li><p>SMC configures all TLBs</p></li>
<li><p>SMC configures MSI-X</p></li>
<li><p>SMC writes system_ready = 1</p></li>
<li><p>PCIe link up</p></li>
<li><p>First transaction from PCIe</p></li>
<li><p>Complete successfully</p></li>
</ol>
<p><strong>Expected Result:</strong> Boot sequence successful, first transaction works</p>
<p><strong>Coverage:</strong> Complete initialization, boot flow</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-system-002-shutdown-sequence">
<h4>TC_E2E_SYSTEM_002: Shutdown Sequence<a class="headerlink" href="#tc-e2e-system-002-shutdown-sequence" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_System_ShutdownSequence()</span></code> | <strong>Feature:</strong> Graceful Shutdown (Drain → Isolate → Reset) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify clean shutdown</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Active traffic on all paths</p></li>
<li><p>SMC writes system_ready = 0</p></li>
<li><p>Drain in-flight transactions</p></li>
<li><p>Assert isolation</p></li>
<li><p>Warm reset</p></li>
<li><p>Cold reset</p></li>
<li><p>Verify clean shutdown, no hangs</p></li>
</ol>
<p><strong>Expected Result:</strong> Graceful shutdown</p>
<p><strong>Coverage:</strong> Shutdown sequence, drain logic</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-system-003-error-recovery-scenario">
<h4>TC_E2E_SYSTEM_003: Error Recovery Scenario<a class="headerlink" href="#tc-e2e-system-003-error-recovery-scenario" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_System_ErrorRecovery()</span></code> | <strong>Feature:</strong> Error Injection and Recovery (Fault Tolerance) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify recovery from error conditions</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Inject TLB error (invalid entry)</p></li>
<li><p>Transaction fails with DECERR</p></li>
<li><p>Fix TLB configuration</p></li>
<li><p>Retry transaction</p></li>
<li><p>Success</p></li>
<li><p>Inject timeout</p></li>
<li><p>Recover</p></li>
<li><p>Verify normal operation resumes</p></li>
</ol>
<p><strong>Expected Result:</strong> All errors recoverable</p>
<p><strong>Coverage:</strong> Error recovery, fault tolerance</p>
</section>
</section>
<hr class="docutils" />
<section id="refactored-architecture-validation">
<h3>16.16 Refactored Architecture Validation<a class="headerlink" href="#refactored-architecture-validation" title="Permalink to this heading">¶</a></h3>
<p><strong>Note:</strong> These tests specifically validate the refactored C++ class architecture</p>
<section id="tc-e2e-refactor-001-function-callback-chain">
<h4>TC_E2E_REFACTOR_001: Function Callback Chain<a class="headerlink" href="#tc-e2e-refactor-001-function-callback-chain" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Refactor_FunctionCallbackChain()</span></code> | <strong>Feature:</strong> Refactored C++ Function Callback Architecture | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify function callbacks work correctly</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction through complete chain: External socket → Switch → TLB → Switch → External socket</p></li>
<li><p>Trace execution through all function callbacks</p></li>
<li><p>Verify no callback dropped</p></li>
<li><p>Verify timing maintained</p></li>
<li><p>Compare with original socket-based behavior</p></li>
</ol>
<p><strong>Expected Result:</strong> Function callbacks equivalent to sockets</p>
<p><strong>Coverage:</strong> Callback mechanism, refactored architecture</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-refactor-002-no-internal-sockets-remain">
<h4>TC_E2E_REFACTOR_002: No Internal Sockets Remain<a class="headerlink" href="#tc-e2e-refactor-002-no-internal-sockets-remain" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Refactor_NoInternalSockets_E126Check()</span></code> | <strong>Feature:</strong> E126 Error Elimination / FastBuild Compatibility | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify FastBuild only sees external sockets</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Run with SCML2 FastBuild coverage enabled</p></li>
<li><p>Verify no E126 errors</p></li>
<li><p>Verify coverage only instruments 6 top-level sockets</p></li>
<li><p>Verify internal C++ classes not instrumented</p></li>
<li><p>Collect coverage data</p></li>
</ol>
<p><strong>Expected Result:</strong> ✅ NO E126 ERRORS, coverage works</p>
<p><strong>Coverage:</strong> FastBuild compatibility validation</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="coverage-goals">
<h2>17. Coverage Goals<a class="headerlink" href="#coverage-goals" title="Permalink to this heading">¶</a></h2>
</section>
<section id="id3">
<h2>16. Coverage Goals<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<section id="functional-coverage">
<h3>16.1 Functional Coverage<a class="headerlink" href="#functional-coverage" title="Permalink to this heading">¶</a></h3>
<section id="tlb-coverage">
<h4>TLB Coverage<a class="headerlink" href="#tlb-coverage" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p><strong>Entry Coverage:</strong> All TLB entries accessed at least once</p></li>
<li><p><strong>Valid/Invalid Coverage:</strong> Both valid and invalid entries tested</p></li>
<li><p><strong>Index Coverage:</strong> All possible index values tested</p></li>
<li><p><strong>Address Range Coverage:</strong> Min, max, and boundary addresses</p></li>
<li><p><strong>Page Boundary Coverage:</strong> Addresses at page boundaries</p></li>
<li><p><strong>Port Coverage:</strong> All port values (0, 1, 4, 8, 9) for inbound TLBs</p></li>
</ul>
</section>
<section id="msi-relay-coverage">
<h4>MSI Relay Coverage<a class="headerlink" href="#msi-relay-coverage" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p><strong>Vector Coverage:</strong> All 16 vectors tested</p></li>
<li><p><strong>PBA Coverage:</strong> All PBA bit combinations</p></li>
<li><p><strong>Enable/Mask Coverage:</strong> All enable/mask combinations</p></li>
<li><p><strong>Table Entry Coverage:</strong> All MSI-X table entries configured</p></li>
<li><p><strong>Address Coverage:</strong> Various MSI addresses tested</p></li>
</ul>
</section>
<section id="switch-coverage">
<h4>Switch Coverage<a class="headerlink" href="#switch-coverage" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p><strong>Routing Coverage:</strong> All routing paths tested (NOC-PCIE: 16 routes, NOC-IO: all address ranges, SMN-IO: all address ranges)</p></li>
<li><p><strong>Address Decoding Coverage:</strong> All address bits tested</p></li>
<li><p><strong>Isolation Coverage:</strong> Isolation behavior for all switches</p></li>
<li><p><strong>Timeout Coverage:</strong> Timeout detection for NOC-IO and SMN-IO</p></li>
<li><p><strong>Enable Control Coverage:</strong> All enable combinations tested</p></li>
</ul>
</section>
<section id="sii-coverage">
<h4>SII Coverage<a class="headerlink" href="#sii-coverage" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p><strong>CII Tracking Coverage:</strong> All config register updates tracked</p></li>
<li><p><strong>Register Access Coverage:</strong> All SII registers accessed</p></li>
<li><p><strong>Interrupt Coverage:</strong> Config update interrupt generation</p></li>
</ul>
</section>
<section id="config-register-coverage">
<h4>Config Register Coverage<a class="headerlink" href="#config-register-coverage" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p><strong>TLB Config Coverage:</strong> All TLB configuration spaces accessed</p></li>
<li><p><strong>Status Register Coverage:</strong> System Ready and Enable registers tested</p></li>
<li><p><strong>Isolation Coverage:</strong> Isolation behavior for config registers</p></li>
</ul>
</section>
<section id="clock-reset-coverage">
<h4>Clock/Reset Coverage<a class="headerlink" href="#clock-reset-coverage" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p><strong>Reset Sequence Coverage:</strong> Cold reset, warm reset, isolation</p></li>
<li><p><strong>Clock Generation Coverage:</strong> All clock outputs verified</p></li>
<li><p><strong>Reset Timing Coverage:</strong> Reset deassertion timing verified</p></li>
</ul>
</section>
<section id="phy-coverage">
<h4>PHY Coverage<a class="headerlink" href="#phy-coverage" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p><strong>Configuration Coverage:</strong> APB and AHB configuration tested</p></li>
<li><p><strong>Initialization Coverage:</strong> PHY initialization sequence verified</p></li>
<li><p><strong>Lane Reversal Coverage:</strong> Lane reversal configuration tested</p></li>
</ul>
</section>
</section>
<section id="code-coverage">
<h3>16.2 Code Coverage<a class="headerlink" href="#code-coverage" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>Statement Coverage:</strong> &gt;95%</p></li>
<li><p><strong>Branch Coverage:</strong> &gt;90%</p></li>
<li><p><strong>Condition Coverage:</strong> &gt;85%</p></li>
<li><p><strong>Path Coverage:</strong> Critical paths 100%</p></li>
</ul>
</section>
<section id="specification-coverage">
<h3>16.3 Specification Coverage<a class="headerlink" href="#specification-coverage" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>Address Translation Algorithms:</strong> 100%</p></li>
<li><p><strong>Error Handling:</strong> 100%</p></li>
<li><p><strong>Register Access:</strong> 100%</p></li>
<li><p><strong>MSI Generation:</strong> 100%</p></li>
<li><p><strong>Switch Routing:</strong> 100% of routing table entries</p></li>
<li><p><strong>Reset Sequences:</strong> 100% (Cold, Warm, Isolation)</p></li>
<li><p><strong>Clock Generation:</strong> 100%</p></li>
<li><p><strong>Integration Scenarios:</strong> Key scenarios covered</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="test-infrastructure">
<h2>17. Test Infrastructure<a class="headerlink" href="#test-infrastructure" title="Permalink to this heading">¶</a></h2>
<section id="testbench-components">
<h3>9.1 Testbench Components<a class="headerlink" href="#testbench-components" title="Permalink to this heading">¶</a></h3>
<section id="stimulus-generator">
<h4>Stimulus Generator<a class="headerlink" href="#stimulus-generator" title="Permalink to this heading">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TlbStimulusGenerator</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">generate_tlb_test</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">tlb_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">entry_index</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">generate_address_range_test</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">generate_error_test</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="monitor">
<h4>Monitor<a class="headerlink" href="#monitor" title="Permalink to this heading">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TlbMonitor</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">monitor_transaction</span><span class="p">(</span><span class="n">tlm</span><span class="o">::</span><span class="n">tlm_generic_payload</span><span class="o">&amp;</span><span class="w"> </span><span class="n">trans</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">check_translation</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">output</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">check_axuser</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">axuser</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="reference-model">
<h4>Reference Model<a class="headerlink" href="#reference-model" title="Permalink to this heading">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TlbReferenceModel</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">lookup</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">translated</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">axuser</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">configure_entry</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TlbEntry</span><span class="o">&amp;</span><span class="w"> </span><span class="n">entry</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="test-utilities">
<h3>9.2 Test Utilities<a class="headerlink" href="#test-utilities" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>TLB Entry Builder:</strong> Helper to create TLB entries</p></li>
<li><p><strong>Transaction Builder:</strong> Helper to create TLM transactions</p></li>
<li><p><strong>Coverage Collector:</strong> Tracks coverage metrics</p></li>
<li><p><strong>Scoreboard:</strong> Compares DUT vs reference model</p></li>
</ul>
</section>
<section id="test-configuration">
<h3>9.3 Test Configuration<a class="headerlink" href="#test-configuration" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>Test Length:</strong> Configurable simulation length</p></li>
<li><p><strong>Random Seed:</strong> Configurable for reproducibility</p></li>
<li><p><strong>Verbosity:</strong> Configurable debug output</p></li>
<li><p><strong>Checkpoints:</strong> Save/restore simulation state</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="regression-testing">
<h2>18. Regression Testing<a class="headerlink" href="#regression-testing" title="Permalink to this heading">¶</a></h2>
<section id="regression-suite">
<h3>10.1 Regression Suite<a class="headerlink" href="#regression-suite" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>Basic Functionality:</strong> All basic test cases</p></li>
<li><p><strong>Error Cases:</strong> All error handling tests</p></li>
<li><p><strong>Integration:</strong> All integration tests</p></li>
<li><p><strong>Performance:</strong> Performance benchmarks</p></li>
</ul>
</section>
<section id="regression-criteria">
<h3>10.2 Regression Criteria<a class="headerlink" href="#regression-criteria" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>Pass Rate:</strong> 100% of tests must pass</p></li>
<li><p><strong>Performance:</strong> No regression in simulation speed</p></li>
<li><p><strong>Coverage:</strong> Maintain coverage goals</p></li>
</ul>
</section>
<section id="continuous-integration">
<h3>10.3 Continuous Integration<a class="headerlink" href="#continuous-integration" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>Automated Runs:</strong> Nightly regression runs</p></li>
<li><p><strong>Coverage Reports:</strong> Automated coverage collection</p></li>
<li><p><strong>Failure Analysis:</strong> Automated failure reporting</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="appendix-a-unit-integration-test-case-summary-sections-4-15">
<h2>Appendix A: Unit/Integration Test Case Summary (Sections 4-15)<a class="headerlink" href="#appendix-a-unit-integration-test-case-summary-sections-4-15" title="Permalink to this heading">¶</a></h2>
<blockquote>
<div><p><strong>Note:</strong> The test cases in Sections 4-15 describe granular unit/integration scenarios. These are covered <strong>indirectly</strong> through the End-to-End tests (Section 16) which exercise complete data paths through all sub-components. See the E2E test table (Appendix A.2) for the implemented test functions.</p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Test ID</p></th>
<th class="head"><p>Component</p></th>
<th class="head"><p>Category</p></th>
<th class="head"><p>Priority</p></th>
<th class="head"><p>Covered By E2E Test(s)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>TC_INBOUND_SYS_001</p></td>
<td><p>TLBSysIn0</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_Pcie_TlbSys_SmnN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INBOUND_SYS_002</p></td>
<td><p>TLBSysIn0</p></td>
<td><p>Error</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_InvalidTlbEntry</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INBOUND_SYS_003</p></td>
<td><p>TLBSysIn0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToTlb</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INBOUND_SYS_004</p></td>
<td><p>TLBSysIn0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryRead_Complete</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INBOUND_SYS_005</p></td>
<td><p>TLBSysIn0</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_Pcie_TlbSys_SmnN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INBOUND_SYS_006</p></td>
<td><p>TLBSysIn0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassApp</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INBOUND_APP0_001</p></td>
<td><p>TLBAppIn0</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieRead_TlbApp0_NocN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INBOUND_APP0_002</p></td>
<td><p>TLBAppIn0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_MultipleTlbs</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INBOUND_APP0_003</p></td>
<td><p>TLBAppIn0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryRead_Complete</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INBOUND_APP0_004</p></td>
<td><p>TLBAppIn0</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieRead_TlbApp0_NocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INBOUND_APP1_001</p></td>
<td><p>TLBAppIn1</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INBOUND_APP1_002</p></td>
<td><p>TLBAppIn1</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INBOUND_APP1_003</p></td>
<td><p>TLBAppIn1</p></td>
<td><p>Integration</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_OUTBOUND_SYS_001</p></td>
<td><p>TLBSysOut0</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_SmnN_TlbSysOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_OUTBOUND_SYS_002</p></td>
<td><p>TLBSysOut0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_SmnConfigWrite_PcieDBI</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_OUTBOUND_SYS_003</p></td>
<td><p>TLBSysOut0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_SmnN_TlbSysOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_OUTBOUND_APP0_001</p></td>
<td><p>TLBAppOut0</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_OUTBOUND_APP0_002</p></td>
<td><p>TLBAppOut0</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_OUTBOUND_APP0_003</p></td>
<td><p>TLBAppOut0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_NocMemoryRead_ToPcie</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_OUTBOUND_APP1_001</p></td>
<td><p>TLBAppOut1</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut1_PcieDBI</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_OUTBOUND_APP1_002</p></td>
<td><p>TLBAppOut1</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut1_PcieDBI</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_MSI_RELAY_001</p></td>
<td><p>MSI Relay</p></td>
<td><p>Register</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_MSI_RELAY_002</p></td>
<td><p>MSI Relay</p></td>
<td><p>Register</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToMsiRelay</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_MSI_RELAY_003</p></td>
<td><p>MSI Relay</p></td>
<td><p>Register</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_MSI_RELAY_004</p></td>
<td><p>MSI Relay</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_MSI_RELAY_005</p></td>
<td><p>MSI Relay</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToMsiRelay</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_MSI_RELAY_006</p></td>
<td><p>MSI Relay</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToMsiRelay</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_MSI_RELAY_007</p></td>
<td><p>MSI Relay</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_MultipleVectors</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_MSI_RELAY_008</p></td>
<td><p>MSI Relay</p></td>
<td><p>Error</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_AddressDecodeError</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_MSI_RELAY_009</p></td>
<td><p>MSI Relay</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_MultipleVectors</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_MSI_RELAY_010</p></td>
<td><p>MSI Relay</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_CompleteMsixInterruptFlow</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_MSI_RELAY_011</p></td>
<td><p>MSI Relay</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_MultipleVectors</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INTEGRATION_001</p></td>
<td><p>Integration</p></td>
<td><p>Integration</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToMsiRelay</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INTEGRATION_002</p></td>
<td><p>Integration</p></td>
<td><p>Integration</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INTEGRATION_003</p></td>
<td><p>Integration</p></td>
<td><p>Integration</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_InboundOutbound</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INTEGRATION_004</p></td>
<td><p>Integration</p></td>
<td><p>Integration</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryRead_Complete</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SWITCH_NOC_PCIE_001</p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p>Routing</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieRead_TlbApp0_NocN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SWITCH_NOC_PCIE_002</p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p>Routing</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_Read_Route0xE</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SWITCH_NOC_PCIE_003</p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p>Isolation</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_GlobalBlock</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SWITCH_NOC_PCIE_004</p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p>Control</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SWITCH_NOC_PCIE_005</p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p>Bypass</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassApp</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SWITCH_NOC_PCIE_006</p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p>Address Conv</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassApp</span></code>, <code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassSys</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SWITCH_NOC_IO_001</p></td>
<td><p>NOC-IO Switch</p></td>
<td><p>Routing</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_DownstreamInput_Processing</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SWITCH_NOC_IO_002</p></td>
<td><p>NOC-IO Switch</p></td>
<td><p>External</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_NocMemoryRead_ToPcie</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SWITCH_NOC_IO_003</p></td>
<td><p>NOC-IO Switch</p></td>
<td><p>Routing</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SWITCH_NOC_IO_004</p></td>
<td><p>NOC-IO Switch</p></td>
<td><p>Timeout</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_TimeoutHandling</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SWITCH_SMN_IO_001</p></td>
<td><p>SMN-IO Switch</p></td>
<td><p>Routing</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToTlb</span></code>, <code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToSII</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SWITCH_SMN_IO_002</p></td>
<td><p>SMN-IO Switch</p></td>
<td><p>SerDes</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Stress_AddressSpaceSweep</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SWITCH_SMN_IO_003</p></td>
<td><p>SMN-IO Switch</p></td>
<td><p>External</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_SmnN_TlbSysOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SWITCH_SMN_IO_004</p></td>
<td><p>SMN-IO Switch</p></td>
<td><p>Timeout</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_TimeoutHandling</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SII_001</p></td>
<td><p>SII Block</p></td>
<td><p>Register</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToSII</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SII_002</p></td>
<td><p>SII Block</p></td>
<td><p>CII Tracking</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_CDC_AxiToPcieClock</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SII_003</p></td>
<td><p>SII Block</p></td>
<td><p>Control</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToSII</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_CONFIG_REG_001</p></td>
<td><p>Config Reg</p></td>
<td><p>TLB Config</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToTlb</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_CONFIG_REG_002</p></td>
<td><p>Config Reg</p></td>
<td><p>Status</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_Read_Route0xE</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_CONFIG_REG_003</p></td>
<td><p>Config Reg</p></td>
<td><p>Enable</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_CONFIG_REG_004</p></td>
<td><p>Config Reg</p></td>
<td><p>Isolation</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_GlobalBlock</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_CLOCK_RESET_001</p></td>
<td><p>Clock/Reset</p></td>
<td><p>Clock Gen</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_ColdResetSequence</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_CLOCK_RESET_002</p></td>
<td><p>Clock/Reset</p></td>
<td><p>Clock Gen</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_ColdResetSequence</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_CLOCK_RESET_003</p></td>
<td><p>Clock/Reset</p></td>
<td><p>Reset Seq</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_ColdResetSequence</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_CLOCK_RESET_004</p></td>
<td><p>Clock/Reset</p></td>
<td><p>Reset Seq</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_WarmResetSequence</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_CLOCK_RESET_005</p></td>
<td><p>Clock/Reset</p></td>
<td><p>Isolation</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_GlobalBlock</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_PLL_CGM_001</p></td>
<td><p>PLL/CGM</p></td>
<td><p>Lock</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_BootSequence</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_PLL_CGM_002</p></td>
<td><p>PLL/CGM</p></td>
<td><p>Config</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_ShutdownSequence</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_PHY_001</p></td>
<td><p>PHY Model</p></td>
<td><p>Config</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_BootSequence</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_PHY_002</p></td>
<td><p>PHY Model</p></td>
<td><p>Firmware</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Stress_AddressSpaceSweep</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_PHY_003</p></td>
<td><p>PHY Model</p></td>
<td><p>Lane Rev</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Stress_AddressSpaceSweep</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_EXTERNAL_NOC_001</p></td>
<td><p>NOC-N Interface</p></td>
<td><p>Forwarding</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_EXTERNAL_SMN_001</p></td>
<td><p>SMN-N Interface</p></td>
<td><p>Forwarding</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_SmnN_TlbSysOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_TOP_LEVEL_001</p></td>
<td><p>Top-Level</p></td>
<td><p>Reset</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_ColdResetSequence</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_TOP_LEVEL_002</p></td>
<td><p>Top-Level</p></td>
<td><p>Integration</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryRead_Complete</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_TOP_LEVEL_003</p></td>
<td><p>Top-Level</p></td>
<td><p>MSI Flow</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_TOP_LEVEL_004</p></td>
<td><p>Top-Level</p></td>
<td><p>Isolation</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_GlobalBlock</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_TOP_LEVEL_005</p></td>
<td><p>Top-Level</p></td>
<td><p>Multi-Clock</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_CDC_AxiToPcieClock</span></code></p></td>
</tr>
</tbody>
</table>
<p><strong>Priority Legend:</strong></p>
<ul class="simple">
<li><p>P0: Critical, must pass for release</p></li>
<li><p>P1: Important, should pass for release</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="appendix-a-2-end-to-end-test-case-summary-section-16-implemented-in-keranous-pcie-tiletest-cc">
<h2>Appendix A.2: End-to-End Test Case Summary (Section 16) — Implemented in <code class="docutils literal notranslate"><span class="pre">Keranous_pcie_tileTest.cc</span></code><a class="headerlink" href="#appendix-a-2-end-to-end-test-case-summary-section-16-implemented-in-keranous-pcie-tiletest-cc" title="Permalink to this heading">¶</a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Test ID</p></th>
<th class="head"><p>Test Function</p></th>
<th class="head"><p>Feature Under Test</p></th>
<th class="head"><p>Priority</p></th>
<th class="head"><p>Status</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>(sanity)</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testAlwaysSucceeds()</span></code></p></td>
<td><p>Framework sanity check</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_INBOUND_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieRead_TlbApp0_NocN()</span></code></p></td>
<td><p>Inbound Read Data Path</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_INBOUND_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN()</span></code></p></td>
<td><p>Inbound Write (Large Pages)</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_INBOUND_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_Pcie_TlbSys_SmnN()</span></code></p></td>
<td><p>System Mgmt Inbound Path</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_INBOUND_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassApp()</span></code></p></td>
<td><p>App Bypass Routing (route=0x8)</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_INBOUND_005</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassSys()</span></code></p></td>
<td><p>Sys Bypass Routing (route=0x9)</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_OUTBOUND_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut0_Pcie()</span></code></p></td>
<td><p>Outbound Reverse TLB Read</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_OUTBOUND_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_SmnN_TlbSysOut0_Pcie()</span></code></p></td>
<td><p>System Outbound DBI Access</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_OUTBOUND_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut1_PcieDBI()</span></code></p></td>
<td><p>App DBI Access (64KB Pages)</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_CONFIG_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToTlb()</span></code></p></td>
<td><p>TLB Config via SMN</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_CONFIG_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToSII()</span></code></p></td>
<td><p>SII Config via SMN</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_CONFIG_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToMsiRelay()</span></code></p></td>
<td><p>MSI Relay Config via SMN</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_MSI_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN()</span></code></p></td>
<td><p>MSI Generation &amp; NOC Routing</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_MSI_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_DownstreamInput_Processing()</span></code></p></td>
<td><p>Downstream MSI Input</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_MSIX_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_MultipleVectors()</span></code></p></td>
<td><p>Multi-Vector MSI-X Config</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_STATUS_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_Read_Route0xE()</span></code></p></td>
<td><p>Status Register Routing</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_STATUS_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_DisabledAccess()</span></code></p></td>
<td><p>Status Access Control</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_ISOLATION_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_GlobalBlock()</span></code></p></td>
<td><p>Global Isolation</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_ISOLATION_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_ConfigAccessAllowed()</span></code></p></td>
<td><p>Config During Isolation</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_ERROR_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_InvalidTlbEntry()</span></code></p></td>
<td><p>TLB Error Handling</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_ERROR_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_AddressDecodeError()</span></code></p></td>
<td><p>Address Decode DECERR</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_CONCURRENT_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_InboundOutbound()</span></code></p></td>
<td><p>Bidirectional Concurrency</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_CONCURRENT_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_MultipleTlbs()</span></code></p></td>
<td><p>TLB Array Concurrency</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_RESET_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_ColdResetSequence()</span></code></p></td>
<td><p>Cold Reset &amp; Recovery</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_RESET_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_WarmResetSequence()</span></code></p></td>
<td><p>Warm Reset (Config Preserved)</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_FLOW_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryRead_Complete()</span></code></p></td>
<td><p>Complete PCIe Read Cycle</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_FLOW_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryWrite_Complete()</span></code></p></td>
<td><p>Complete PCIe Write Cycle</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_FLOW_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_NocMemoryRead_ToPcie()</span></code></p></td>
<td><p>NOC-to-PCIe Outbound Read</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_FLOW_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_SmnConfigWrite_PcieDBI()</span></code></p></td>
<td><p>SMN DBI Config Write</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_REFACTOR_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Refactor_FunctionCallbackChain()</span></code></p></td>
<td><p>Function Callback Chain</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_REFACTOR_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Refactor_NoInternalSockets_E126Check()</span></code></p></td>
<td><p>E126 Elimination</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_SYSTEM_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_BootSequence()</span></code></p></td>
<td><p>Boot &amp; Initialization</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_SYSTEM_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_ErrorRecovery()</span></code></p></td>
<td><p>Error Recovery</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_MSIX_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_CompleteMsixInterruptFlow()</span></code></p></td>
<td><p>Complete MSI-X Flow</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_ERROR_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_TimeoutHandling()</span></code></p></td>
<td><p>Timeout Detection</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_CDC_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_CDC_AxiToPcieClock()</span></code></p></td>
<td><p>Clock Domain Crossing</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_PERF_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Perf_MaximumThroughput()</span></code></p></td>
<td><p>Max Throughput Burst</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_STRESS_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Stress_AddressSpaceSweep()</span></code></p></td>
<td><p>Address Space Sweep</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_STRESS_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Stress_TlbEntryExhaustion()</span></code></p></td>
<td><p>TLB 64-Entry Exhaustion</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_POWER_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Power_IsolationModeEntryExit()</span></code></p></td>
<td><p>Isolation Entry/Exit</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_SYSTEM_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_ShutdownSequence()</span></code></p></td>
<td><p>Graceful Shutdown</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
</tbody>
</table>
<p><strong>All E2E test cases are now implemented. No remaining gaps.</strong></p>
</section>
<hr class="docutils" />
<section id="appendix-b-test-execution-plan">
<h2>Appendix B: Test Execution Plan<a class="headerlink" href="#appendix-b-test-execution-plan" title="Permalink to this heading">¶</a></h2>
<section id="phase-1-unit-tests-weeks-1-3">
<h3>Phase 1: Unit Tests (Weeks 1-3)<a class="headerlink" href="#phase-1-unit-tests-weeks-1-3" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Inbound TLB basic tests</p></li>
<li><p>Outbound TLB basic tests</p></li>
<li><p>MSI Relay register tests</p></li>
<li><p>Switch routing tests</p></li>
<li><p>SII block tests</p></li>
<li><p>Config register tests</p></li>
<li><p>Clock/reset tests</p></li>
<li><p>PLL/CGM tests</p></li>
<li><p>PHY model tests</p></li>
</ul>
</section>
<section id="phase-2-functional-tests-weeks-4-5">
<h3>Phase 2: Functional Tests (Weeks 4-5)<a class="headerlink" href="#phase-2-functional-tests-weeks-4-5" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Address translation edge cases</p></li>
<li><p>Error handling tests</p></li>
<li><p>MSI generation tests</p></li>
<li><p>Switch routing edge cases</p></li>
<li><p>Timeout handling tests</p></li>
<li><p>Isolation tests</p></li>
<li><p>Reset sequence tests</p></li>
</ul>
</section>
<section id="phase-3-integration-tests-weeks-6-7">
<h3>Phase 3: Integration Tests (Weeks 6-7)<a class="headerlink" href="#phase-3-integration-tests-weeks-6-7" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>TLB + MSI Relay integration</p></li>
<li><p>Multiple TLB integration</p></li>
<li><p>Fabric integration</p></li>
<li><p>Switch integration</p></li>
<li><p>Clock domain integration</p></li>
<li><p>Top-level integration</p></li>
</ul>
</section>
<section id="phase-4-system-tests-week-8">
<h3>Phase 4: System Tests (Week 8)<a class="headerlink" href="#phase-4-system-tests-week-8" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>End-to-end transaction flows</p></li>
<li><p>Complete reset sequences</p></li>
<li><p>Isolation sequences</p></li>
<li><p>Performance tests</p></li>
<li><p>Stress tests</p></li>
</ul>
</section>
<section id="phase-5-regression-week-9">
<h3>Phase 5: Regression (Week 9)<a class="headerlink" href="#phase-5-regression-week-9" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Full regression suite</p></li>
<li><p>Coverage analysis</p></li>
<li><p>Performance benchmarking</p></li>
<li><p>VDK integration validation</p></li>
</ul>
<hr class="docutils" />
<p><strong>Document End</strong></p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2026, Keraunos PCIe Tile Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/testplan.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>