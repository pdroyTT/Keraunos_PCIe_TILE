
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Keraunos PCIe Tile - High-Level Design &#8212; Keraunos PCIe Tile v1.0</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="https://unpkg.com/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script>
mermaid.initialize({
    startOnLoad: true,
    theme: 'default',
    securityLevel: 'loose',
    flowchart: {
        useMaxWidth: true,
        htmlLabels: true,
        curve: 'basis',
        nodeSpacing: 70,
        rankSpacing: 70,
        padding: 20
    },
    fontSize: 16,
    themeVariables: {
        fontSize: '16px',
        primaryColor: '#e1f5ff',
        primaryTextColor: '#000',
        primaryBorderColor: '#3498db',
        lineColor: '#2c3e50',
        secondaryColor: '#fff4e1',
        tertiaryColor: '#ffe1f5'
    }
});
</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Keraunos PCIE Tile SystemC/TLM2.0 Design Document" href="systemc_design.html" />
    <link rel="prev" title="Keraunos PCIe Tile Documentation" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Keraunos PCIe Tile</a></h1>



<p class="blurb">SystemC/TLM2.0 PCIe Tile Design and Verification</p>






<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Design Documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Keraunos PCIe Tile - High-Level Design</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#architecture-overview">2. Architecture Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#theory-of-operation">3. Theory of Operation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#detailed-block-diagram">4. Detailed Block Diagram</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-flow-paths">5. Data Flow Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-descriptions">6. Module Descriptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#address-map">7. Address Map</a></li>
<li class="toctree-l2"><a class="reference internal" href="#clock-and-reset-strategy">8. Clock and Reset Strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interface-specifications">9. Interface Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="#known-limitations-and-findings">10. Known Limitations and Findings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#test-coverage-summary">11. Test Coverage Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references">12. References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="systemc_design.html">Keraunos PCIE Tile SystemC/TLM2.0 Design Document</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Verification Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="testplan.html">Keraunos PCIE Tile SystemC/TLM2.0 Testplan</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Keraunos PCIe Tile Documentation</a></li>
      <li>Next: <a href="systemc_design.html" title="next chapter">Keraunos PCIE Tile SystemC/TLM2.0 Design Document</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section class="tex2jax_ignore mathjax_ignore" id="keraunos-pcie-tile-high-level-design">
<h1>Keraunos PCIe Tile - High-Level Design<a class="headerlink" href="#keraunos-pcie-tile-high-level-design" title="Permalink to this heading">¶</a></h1>
<p><strong>Version:</strong> 1.0<br />
<strong>Date:</strong> February 5, 2026<br />
<strong>Status:</strong> Released</p>
<hr class="docutils" />
<section id="introduction">
<h2>1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<section id="purpose">
<h3>1.1 Purpose<a class="headerlink" href="#purpose" title="Permalink to this heading">¶</a></h3>
<p>This document describes the high-level architecture of the Keraunos PCIe Tile, a SystemC/TLM2.0 model that provides PCIe connectivity between Network-on-Chip (NOC), System Management Network (SMN), and PCIe controller interfaces.</p>
</section>
<section id="scope">
<h3>1.2 Scope<a class="headerlink" href="#scope" title="Permalink to this heading">¶</a></h3>
<p>The Keraunos PCIe Tile integrates:</p>
<ul class="simple">
<li><p><strong>3 fabric switches</strong> for routing traffic between NOC, SMN, and PCIe domains</p></li>
<li><p><strong>8 Translation Lookaside Buffers (TLBs)</strong> for address translation (5 inbound, 3 outbound)</p></li>
<li><p><strong>MSI-X relay unit</strong> for interrupt handling</p></li>
<li><p><strong>System Information Interface (SII)</strong> for PCIe configuration tracking</p></li>
<li><p><strong>Configuration register block</strong> for tile-level control</p></li>
<li><p><strong>Clock and reset control</strong> infrastructure</p></li>
</ul>
</section>
<section id="key-terms">
<h3>1.3 Key Terms<a class="headerlink" href="#key-terms" title="Permalink to this heading">¶</a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Term</p></th>
<th class="head"><p>Definition</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>CII</strong></p></td>
<td><p>Configuration Intercept Interface - PCIe config space write detection</p></td>
</tr>
<tr class="row-odd"><td><p><strong>DECERR</strong></p></td>
<td><p>Decode Error - TLM address error response</p></td>
</tr>
<tr class="row-even"><td><p><strong>MSI-X</strong></p></td>
<td><p>Message Signaled Interrupts - Extended</p></td>
</tr>
<tr class="row-odd"><td><p><strong>NOC</strong></p></td>
<td><p>Network-on-Chip</p></td>
</tr>
<tr class="row-even"><td><p><strong>PBA</strong></p></td>
<td><p>Pending Bit Array (for MSI-X)</p></td>
</tr>
<tr class="row-odd"><td><p><strong>SII</strong></p></td>
<td><p>System Information Interface</p></td>
</tr>
<tr class="row-even"><td><p><strong>SMN</strong></p></td>
<td><p>System Management Network</p></td>
</tr>
<tr class="row-odd"><td><p><strong>TLB</strong></p></td>
<td><p>Translation Lookaside Buffer</p></td>
</tr>
<tr class="row-even"><td><p><strong>TLM</strong></p></td>
<td><p>Transaction Level Modeling</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<hr class="docutils" />
<section id="architecture-overview">
<h2>2. Architecture Overview<a class="headerlink" href="#architecture-overview" title="Permalink to this heading">¶</a></h2>
<section id="top-level-architecture">
<h3>2.1 Top-Level Architecture<a class="headerlink" href="#top-level-architecture" title="Permalink to this heading">¶</a></h3>
<p>The Keraunos PCIe Tile acts as a bridge between three major interconnect domains:</p>
<div class="mermaid">
            graph TB
    subgraph &quot;External Interfaces&quot;
        NOC[NOC Network&lt;br/&gt;Target/Initiator]
        SMN[SMN Network&lt;br/&gt;Target/Initiator]
        PCIE[PCIe Controller&lt;br/&gt;Target/Initiator]
    end
    
    subgraph &quot;Keraunos PCIe Tile&quot;
        subgraph &quot;Data Path&quot;
            NOCP[NOC-PCIE&lt;br/&gt;Switch]
            NOCI[NOC-IO&lt;br/&gt;Switch]
            SMNI[SMN-IO&lt;br/&gt;Switch]
            TLBI[Inbound TLBs&lt;br/&gt;5 instances]
            TLBO[Outbound TLBs&lt;br/&gt;3 instances]
            MSI[MSI Relay&lt;br/&gt;Unit]
        end
        
        subgraph &quot;Control Path&quot;
            CFG[Config&lt;br/&gt;Registers]
            SII[SII Block&lt;br/&gt;CII Tracking]
            CLK[Clock/Reset&lt;br/&gt;Control]
        end
    end
    
    NOC --&gt;|Data Traffic| NOCI
    NOCI --&gt; TLBO --&gt; NOCP --&gt; PCIE
    PCIE --&gt; NOCP --&gt; TLBI --&gt; NOCI --&gt; NOC
    
    SMN --&gt;|Config Access| SMNI
    SMNI --&gt; CFG
    SMNI --&gt; SII
    SMNI --&gt; TLBI
    SMNI --&gt; TLBO
    SMNI --&gt; MSI
    
    PCIE --&gt;|CII Signals| SII
    NOC --&gt;|MSI Input| MSI
    
    CLK -.-&gt;|Reset/Clock| NOCP
    CLK -.-&gt;|Reset/Clock| NOCI
    CLK -.-&gt;|Reset/Clock| SMNI
    
    style NOCP fill:#e1f5ff
    style NOCI fill:#e1f5ff
    style SMNI fill:#e1f5ff
    style TLBI fill:#fff4e1
    style TLBO fill:#fff4e1
    style MSI fill:#ffe1f5
    style SII fill:#ffe1f5
    style CFG fill:#e1ffe1
    style CLK fill:#e1ffe1
        </div></section>
<section id="design-principles">
<h3>2.2 Design Principles<a class="headerlink" href="#design-principles" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p><strong>C++ Implementation:</strong> All internal components are C++ classes (not SystemC modules) for performance and simplicity.</p></li>
<li><p><strong>Function Callbacks:</strong> Internal communication uses C++ function callbacks instead of TLM sockets.</p></li>
<li><p><strong>RAII Memory Management:</strong> Smart pointers (<code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code>) for automatic resource cleanup.</p></li>
<li><p><strong>Address-Based Routing:</strong> Upper address bits [63:60] determine routing paths.</p></li>
<li><p><strong>Signal-Based Control:</strong> Control plane uses <code class="docutils literal notranslate"><span class="pre">sc_signal</span></code> for isolation, reset, and configuration tracking.</p></li>
</ol>
</section>
</section>
<hr class="docutils" />
<section id="theory-of-operation">
<h2>3. Theory of Operation<a class="headerlink" href="#theory-of-operation" title="Permalink to this heading">¶</a></h2>
<p>This section describes the operational modes and transaction flows of the Keraunos PCIe Tile.</p>
<section id="operational-modes">
<h3>3.1 Operational Modes<a class="headerlink" href="#operational-modes" title="Permalink to this heading">¶</a></h3>
<p>The PCIe Tile operates in several distinct modes:</p>
<section id="normal-operation-mode">
<h4>Normal Operation Mode<a class="headerlink" href="#normal-operation-mode" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p><strong>System Ready</strong>: <code class="docutils literal notranslate"><span class="pre">system_ready</span></code> register bit set to 1</p></li>
<li><p><strong>Application Paths Enabled</strong>: <code class="docutils literal notranslate"><span class="pre">pcie_inbound_app_enable</span></code> and <code class="docutils literal notranslate"><span class="pre">pcie_outbound_app_enable</span></code> set as needed</p></li>
<li><p><strong>No Isolation</strong>: <code class="docutils literal notranslate"><span class="pre">isolate_req</span></code> signal deasserted</p></li>
<li><p><strong>Clocks Running</strong>: Both <code class="docutils literal notranslate"><span class="pre">pcie_core_clk</span></code> and <code class="docutils literal notranslate"><span class="pre">axi_clk</span></code> active</p></li>
<li><p><strong>No Reset</strong>: <code class="docutils literal notranslate"><span class="pre">cold_reset_n</span></code> and <code class="docutils literal notranslate"><span class="pre">warm_reset_n</span></code> asserted (active high)</p></li>
</ul>
<p>In this mode, all data paths are operational and transactions flow freely between NOC, PCIe, and SMN domains.</p>
</section>
<section id="isolation-mode">
<h4>Isolation Mode<a class="headerlink" href="#isolation-mode" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p><strong>Triggered By</strong>: Assertion of <code class="docutils literal notranslate"><span class="pre">isolate_req</span></code> signal</p></li>
<li><p><strong>Effect</strong>: Clears <code class="docutils literal notranslate"><span class="pre">system_ready</span></code>, <code class="docutils literal notranslate"><span class="pre">pcie_inbound_app_enable</span></code>, and <code class="docutils literal notranslate"><span class="pre">pcie_outbound_app_enable</span></code></p></li>
<li><p><strong>Data Path</strong>: All PCIe controller transactions return <code class="docutils literal notranslate"><span class="pre">TLM_ADDRESS_ERROR_RESPONSE</span></code> (DECERR)</p></li>
<li><p><strong>Recovery Limitation</strong>: Deasserting <code class="docutils literal notranslate"><span class="pre">isolate_req</span></code> does NOT automatically restore enables (requires cold reset + software reconfiguration)</p></li>
<li><p><strong>Use Case</strong>: Power domain isolation, fault containment</p></li>
</ul>
</section>
<section id="bypass-mode">
<h4>Bypass Mode<a class="headerlink" href="#bypass-mode" title="Permalink to this heading">¶</a></h4>
<ul class="simple">
<li><p><strong>Condition</strong>: <code class="docutils literal notranslate"><span class="pre">system_ready=0</span></code> but <code class="docutils literal notranslate"><span class="pre">pcie_inbound_app_enable=1</span></code> or <code class="docutils literal notranslate"><span class="pre">pcie_outbound_app_enable=1</span></code></p></li>
<li><p><strong>Routing</strong>: Uses route 0xE or 0xF to access status register directly</p></li>
<li><p><strong>Purpose</strong>: Allow status monitoring without full system initialization</p></li>
<li><p><strong>Limited Functionality</strong>: Only status register readable; normal data paths blocked</p></li>
</ul>
</section>
<section id="reset-modes">
<h4>Reset Modes<a class="headerlink" href="#reset-modes" title="Permalink to this heading">¶</a></h4>
<p><strong>Cold Reset:</strong></p>
<ul class="simple">
<li><p><strong>Trigger</strong>: <code class="docutils literal notranslate"><span class="pre">cold_reset_n</span></code> signal deasserted (active low)</p></li>
<li><p><strong>Scope</strong>: Resets SII block (<code class="docutils literal notranslate"><span class="pre">pcie_sii_reset_ctrl_</span></code>) and reset control module (<code class="docutils literal notranslate"><span class="pre">pcie_reset_ctrl_</span></code>)</p></li>
<li><p><strong>Does NOT Reset</strong>: Configuration registers, TLB entries, switch enables</p></li>
<li><p><strong>Recovery</strong>: Requires software reconfiguration after reset</p></li>
</ul>
<p><strong>Warm Reset:</strong></p>
<ul class="simple">
<li><p><strong>Trigger</strong>: <code class="docutils literal notranslate"><span class="pre">warm_reset_n</span></code> signal deasserted (active low)</p></li>
<li><p><strong>Scope</strong>: Similar to cold reset but may preserve certain configuration state</p></li>
<li><p><strong>Note</strong>: Current implementation behavior similar to cold reset</p></li>
</ul>
</section>
</section>
<section id="initialization-and-boot-sequence">
<h3>3.2 Initialization and Boot Sequence<a class="headerlink" href="#initialization-and-boot-sequence" title="Permalink to this heading">¶</a></h3>
<div class="mermaid">
            sequenceDiagram
    participant SMN as SMN Host
    participant Tile as PCIe Tile
    participant Switch as NOC-PCIE Switch
    participant TLB as TLB Units
    participant SII as SII Block
    participant PCIE as PCIe Controller

    Note over Tile: Power-On / Cold Reset
    SMN-&gt;&gt;Tile: Deassert cold_reset_n
    Tile-&gt;&gt;SII: Reset SII state
    Tile-&gt;&gt;Switch: system_ready=0, enables=0
    
    Note over Tile: Configuration Phase
    SMN-&gt;&gt;Switch: Write system_ready=1
    Switch-&gt;&gt;Switch: Enable routing logic
    
    SMN-&gt;&gt;TLB: Configure inbound TLB entries
    Note over TLB: Set valid bits, page masks, base addresses
    
    SMN-&gt;&gt;TLB: Configure outbound TLB entries
    Note over TLB: Set application path translations
    
    SMN-&gt;&gt;Switch: Write pcie_inbound_app_enable=1
    SMN-&gt;&gt;Switch: Write pcie_outbound_app_enable=1
    Switch-&gt;&gt;Switch: Enable application data paths
    
    Note over Tile: Normal Operation
    PCIE-&gt;&gt;Switch: Inbound transaction
    Switch-&gt;&gt;TLB: Address translation
    TLB-&gt;&gt;Switch: Translated address
    Switch-&gt;&gt;PCIE: Transaction complete
        </div><p><strong>Initialization Steps:</strong></p>
<ol class="arabic simple">
<li><p><strong>Reset Phase</strong></p>
<ul class="simple">
<li><p>Assert <code class="docutils literal notranslate"><span class="pre">cold_reset_n</span></code> to bring tile to known state</p></li>
<li><p>SII block clears all CII tracking state</p></li>
<li><p>Switch enables default to 0</p></li>
</ul>
</li>
<li><p><strong>System Ready Configuration</strong></p>
<ul class="simple">
<li><p>SMN writes <code class="docutils literal notranslate"><span class="pre">system_ready=1</span></code> to status register (offset 0x0)</p></li>
<li><p>Enables basic routing logic in switches</p></li>
<li><p>Status register becomes readable via routes 0xE and 0xF</p></li>
</ul>
</li>
<li><p><strong>TLB Configuration</strong></p>
<ul class="simple">
<li><p>Configure inbound TLBs (Sys In0, Sys In1, App In0/1/2)</p></li>
<li><p>Set valid bits, page sizes, base addresses, address masks</p></li>
<li><p>Configure outbound TLBs (Sys Out, App Out0/1)</p></li>
<li><p>Set AxUSER fields for NOC routing</p></li>
</ul>
</li>
<li><p><strong>Data Path Enablement</strong></p>
<ul class="simple">
<li><p>Write <code class="docutils literal notranslate"><span class="pre">pcie_inbound_app_enable=1</span></code> for PCIe→NOC application paths</p></li>
<li><p>Write <code class="docutils literal notranslate"><span class="pre">pcie_outbound_app_enable=1</span></code> for NOC→PCIe application paths</p></li>
<li><p>System enters normal operation mode</p></li>
</ul>
</li>
</ol>
</section>
<section id="inbound-data-flow-pcie-to-noc">
<h3>3.3 Inbound Data Flow (PCIe to NOC)<a class="headerlink" href="#inbound-data-flow-pcie-to-noc" title="Permalink to this heading">¶</a></h3>
<p><strong>Transaction Path: PCIe Controller → NOC-PCIE Switch → Inbound TLB → NOC-IO Switch → NOC</strong></p>
<div class="mermaid">
            sequenceDiagram
    participant PCIE as PCIe Controller
    participant NOCP as NOC-PCIE Switch
    participant TLB as Inbound TLB
    participant NOCI as NOC-IO Switch
    participant NOC as NOC Network

    PCIE-&gt;&gt;NOCP: b_transport(addr[63:0], data)
    Note over NOCP: Check system_ready
    
    alt system_ready == 0
        NOCP-&gt;&gt;PCIE: TLM_ADDRESS_ERROR_RESPONSE
    else Route bits [63:60]
        NOCP-&gt;&gt;NOCP: Decode route (0x0,0x1,0x4,0x6,0x7)
        
        alt Application path (0x0, 0x1, 0x6, 0x7)
            Note over NOCP: Check pcie_inbound_app_enable
            alt Enable == 0
                NOCP-&gt;&gt;PCIE: TLM_ADDRESS_ERROR_RESPONSE
            else Enable == 1
                NOCP-&gt;&gt;TLB: translate_and_forward(addr)
                Note over TLB: Calculate index = (addr &gt;&gt; shift) &amp; page_mask
                Note over TLB: Check valid bit
                
                alt valid == 0
                    TLB-&gt;&gt;NOCP: TLM_ADDRESS_ERROR_RESPONSE
                    NOCP-&gt;&gt;PCIE: DECERR
                else valid == 1
                    TLB-&gt;&gt;TLB: new_addr = entry.addr + offset
                    TLB-&gt;&gt;TLB: Set AxUSER field
                    TLB-&gt;&gt;NOCI: forward(new_addr, AxUSER)
                    NOCI-&gt;&gt;NOC: b_transport(translated_addr)
                    NOC-&gt;&gt;NOCI: TLM_OK_RESPONSE
                    NOCI-&gt;&gt;TLB: Success
                    TLB-&gt;&gt;NOCP: Success
                    NOCP-&gt;&gt;PCIE: TLM_OK_RESPONSE
                end
            end
        else System path (0x4)
            NOCP-&gt;&gt;TLB: translate_and_forward(addr)
            Note over TLB: System TLB (smaller pages)
            TLB-&gt;&gt;NOCI: forward(translated_addr)
            NOCI-&gt;&gt;NOC: b_transport
            NOC-&gt;&gt;PCIE: Response propagates back
        end
    end
        </div><p><strong>Key Steps:</strong></p>
<ol class="arabic simple">
<li><p><strong>PCIe Controller Transaction</strong></p>
<ul class="simple">
<li><p>Transaction arrives at <code class="docutils literal notranslate"><span class="pre">pcie_controller_target</span></code> socket</p></li>
<li><p>64-bit address with route field [63:60]</p></li>
</ul>
</li>
<li><p><strong>NOC-PCIE Switch Routing</strong></p>
<ul class="simple">
<li><p>Check <code class="docutils literal notranslate"><span class="pre">system_ready</span></code> flag (blocks if 0)</p></li>
<li><p>Decode route bits [63:60]</p></li>
<li><p>For application paths: check <code class="docutils literal notranslate"><span class="pre">pcie_inbound_app_enable</span></code></p></li>
<li><p>For system paths: always allowed if <code class="docutils literal notranslate"><span class="pre">system_ready=1</span></code></p></li>
</ul>
</li>
<li><p><strong>TLB Translation</strong></p>
<ul class="simple">
<li><p>Extract page index: <code class="docutils literal notranslate"><span class="pre">(addr</span> <span class="pre">&gt;&gt;</span> <span class="pre">shift)</span> <span class="pre">&amp;</span> <span class="pre">page_mask</span></code></p></li>
<li><p>Look up TLB entry</p></li>
<li><p>Check <code class="docutils literal notranslate"><span class="pre">valid</span></code> bit</p></li>
<li><p>Calculate translated address: <code class="docutils literal notranslate"><span class="pre">base_addr</span> <span class="pre">+</span> <span class="pre">offset</span></code></p></li>
<li><p>Set AxUSER field for NOC routing</p></li>
</ul>
</li>
<li><p><strong>NOC-IO Switch Forwarding</strong></p>
<ul class="simple">
<li><p>Forward translated address to NOC</p></li>
<li><p>Preserve AxUSER field</p></li>
<li><p>Return response to PCIe controller</p></li>
</ul>
</li>
</ol>
</section>
<section id="outbound-data-flow-noc-to-pcie">
<h3>3.4 Outbound Data Flow (NOC to PCIe)<a class="headerlink" href="#outbound-data-flow-noc-to-pcie" title="Permalink to this heading">¶</a></h3>
<p><strong>Transaction Path: NOC → NOC-IO Switch → Outbound TLB → NOC-PCIE Switch → PCIe Controller</strong></p>
<div class="mermaid">
            sequenceDiagram
    participant NOC as NOC Network
    participant NOCI as NOC-IO Switch
    participant TLB as Outbound TLB
    participant NOCP as NOC-PCIE Switch
    participant PCIE as PCIe Controller

    NOC-&gt;&gt;NOCI: b_transport(noc_addr, data)
    NOCI-&gt;&gt;TLB: translate_address()
    
    Note over TLB: Calculate TLB index
    Note over TLB: Check valid bit
    
    alt valid == 0
        TLB-&gt;&gt;NOCI: TLM_ADDRESS_ERROR_RESPONSE
        NOCI-&gt;&gt;NOC: DECERR
    else valid == 1
        TLB-&gt;&gt;TLB: pcie_addr = entry.addr + offset
        TLB-&gt;&gt;TLB: Convert 64-bit to 52-bit
        
        alt Application path
            Note over NOCP: Check pcie_outbound_app_enable
            alt Enable == 0
                NOCP-&gt;&gt;NOCI: TLM_ADDRESS_ERROR_RESPONSE
                NOCI-&gt;&gt;NOC: DECERR
            else Enable == 1
                NOCP-&gt;&gt;PCIE: b_transport(pcie_addr)
                PCIE-&gt;&gt;NOCP: TLM_OK_RESPONSE
                NOCP-&gt;&gt;NOCI: Success
                NOCI-&gt;&gt;NOC: TLM_OK_RESPONSE
            end
        else System path
            NOCP-&gt;&gt;PCIE: b_transport(pcie_addr)
            PCIE-&gt;&gt;NOC: Response propagates back
        end
    end
        </div><p><strong>Key Steps:</strong></p>
<ol class="arabic simple">
<li><p><strong>NOC Transaction</strong></p>
<ul class="simple">
<li><p>Arrives at <code class="docutils literal notranslate"><span class="pre">noc_n_target</span></code> socket</p></li>
<li><p>NOC-specific addressing</p></li>
</ul>
</li>
<li><p><strong>NOC-IO Switch Processing</strong></p>
<ul class="simple">
<li><p>Routes to appropriate outbound TLB</p></li>
</ul>
</li>
<li><p><strong>Outbound TLB Translation</strong></p>
<ul class="simple">
<li><p>Translate NOC address to PCIe address space</p></li>
<li><p>Check valid bit</p></li>
<li><p>Convert 64-bit internal address to 52-bit PCIe address</p></li>
</ul>
</li>
<li><p><strong>NOC-PCIE Switch Gating</strong></p>
<ul class="simple">
<li><p>For application paths: check <code class="docutils literal notranslate"><span class="pre">pcie_outbound_app_enable</span></code></p></li>
<li><p>Forward to PCIe controller if enabled</p></li>
</ul>
</li>
</ol>
</section>
<section id="configuration-access-flow">
<h3>3.5 Configuration Access Flow<a class="headerlink" href="#configuration-access-flow" title="Permalink to this heading">¶</a></h3>
<p><strong>Transaction Path: SMN → SMN-IO Switch → Configuration Targets</strong></p>
<div class="mermaid">
            sequenceDiagram
    participant SMN as SMN Host
    participant SMNI as SMN-IO Switch
    participant TGT as Config Target
    participant SII as SII Block
    participant MSI as MSI Relay
    participant TLB as TLB Config

    SMN-&gt;&gt;SMNI: b_transport(smn_addr, data, cmd)
    
    Note over SMNI: Decode address bits [31:28]
    
    alt Config Register Block
        SMNI-&gt;&gt;TGT: forward(offset 0x0-0xFFF)
        TGT-&gt;&gt;TGT: Read/Write register
        Note over TGT: system_ready, enables, isolation
        TGT-&gt;&gt;SMNI: Response
        SMNI-&gt;&gt;SMN: TLM_OK_RESPONSE
        
    else SII Configuration
        SMNI-&gt;&gt;SII: process_apb_access(addr, data)
        Note over SII: CORE_CONTROL, CFG_MODIFIED, BUS_DEV_NUM
        alt Write to CFG_MODIFIED (RW1C)
            SII-&gt;&gt;SII: Clear modified bits
            SII-&gt;&gt;SII: Update config_update interrupt
        end
        SII-&gt;&gt;SMNI: Response
        
    else MSI Relay Configuration
        SMNI-&gt;&gt;MSI: process_msi_config(addr, data)
        Note over MSI: Configure MSI-X table, PBA, masks
        Note over MSI: Address passthrough limits functionality
        MSI-&gt;&gt;SMNI: Response
        
    else TLB Configuration
        SMNI-&gt;&gt;TLB: process_tlb_config(addr, data)
        Note over TLB: Set valid bits, masks, base addresses
        Note over TLB: Address passthrough affects offset calculation
        TLB-&gt;&gt;SMNI: Response
        
    else Unknown address
        SMNI-&gt;&gt;SMN: TLM_ADDRESS_ERROR_RESPONSE
    end
        </div><p><strong>Configuration Targets:</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Address Range [31:28]</p></th>
<th class="head"><p>Target</p></th>
<th class="head"><p>Functionality</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>Config Registers</p></td>
<td><p>system_ready, enables, isolation</p></td>
</tr>
<tr class="row-odd"><td><p>0x1</p></td>
<td><p>SII Block</p></td>
<td><p>CORE_CONTROL, CFG_MODIFIED, BUS_DEV_NUM</p></td>
</tr>
<tr class="row-even"><td><p>0x2</p></td>
<td><p>Reserved</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-odd"><td><p>0x3-0x7</p></td>
<td><p>TLB Config</p></td>
<td><p>Inbound/Outbound TLB entries</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>MSI Relay</p></td>
<td><p>MSI-X table, PBA, masks</p></td>
</tr>
</tbody>
</table>
<p><strong>Known Limitation:</strong> SMN-IO switch passes full SystemC addresses to internal callbacks instead of stripping base addresses. This causes configuration writes to MSI, SII, and TLB to be processed with incorrect offsets.</p>
</section>
<section id="msi-interrupt-generation-flow">
<h3>3.6 MSI Interrupt Generation Flow<a class="headerlink" href="#msi-interrupt-generation-flow" title="Permalink to this heading">¶</a></h3>
<p><strong>Transaction Path: NOC MSI Input → MSI Relay → PCIe Controller (MSI Output)</strong></p>
<div class="mermaid">
            sequenceDiagram
    participant NOC as NOC (MSI Source)
    participant MSI as MSI Relay Unit
    participant Tile as PCIe Tile
    participant PCIE as PCIe Controller

    NOC-&gt;&gt;MSI: Write to msi_input (0x18800000)
    Note over MSI: process_msi_input() called
    Note over MSI: Address passthrough: offset != 0
    
    alt offset == 0 (not met due to passthrough)
        MSI-&gt;&gt;MSI: Extract vector number
        MSI-&gt;&gt;MSI: Check per-vector mask
        MSI-&gt;&gt;MSI: Check global mask
        MSI-&gt;&gt;MSI: Set PBA bit
        MSI-&gt;&gt;MSI: Increment msi_outstanding
        MSI-&gt;&gt;MSI: Trigger process_pending_msis()
        
        Note over Tile: signal_update_process()
        Tile-&gt;&gt;MSI: Call process_pending_msis()
        
        alt MSI-X enabled AND not masked AND PBA set
            MSI-&gt;&gt;MSI: Read MSI-X table entry
            MSI-&gt;&gt;MSI: Prepare MSI transaction
            MSI-&gt;&gt;PCIE: b_transport(msi_addr, msi_data)
            PCIE-&gt;&gt;MSI: TLM_OK_RESPONSE
            MSI-&gt;&gt;MSI: Clear PBA bit
            MSI-&gt;&gt;MSI: Decrement msi_outstanding
        end
        
    else offset != 0 (actual behavior)
        MSI-&gt;&gt;NOC: TLM_OK_RESPONSE
        Note over MSI: PBA not updated (limitation)
    end
        </div><p><strong>MSI Flow Steps:</strong></p>
<ol class="arabic simple">
<li><p><strong>MSI Input Write</strong></p>
<ul class="simple">
<li><p>NOC writes to <code class="docutils literal notranslate"><span class="pre">msi_input_target</span></code> socket</p></li>
<li><p>Vector number encoded in write data</p></li>
</ul>
</li>
<li><p><strong>MSI Relay Processing</strong></p>
<ul class="simple">
<li><p>Check per-vector mask bit</p></li>
<li><p>Check global mask (<code class="docutils literal notranslate"><span class="pre">msix_mask_all_</span></code>)</p></li>
<li><p>Set corresponding PBA (Pending Bit Array) bit</p></li>
<li><p>Increment <code class="docutils literal notranslate"><span class="pre">msi_outstanding</span></code> counter</p></li>
</ul>
</li>
<li><p><strong>MSI Generation</strong> (via <code class="docutils literal notranslate"><span class="pre">process_pending_msis()</span></code>)</p>
<ul class="simple">
<li><p>Called by tile’s <code class="docutils literal notranslate"><span class="pre">signal_update_process()</span></code></p></li>
<li><p>Check MSI-X enabled (<code class="docutils literal notranslate"><span class="pre">msix_enable_</span></code>)</p></li>
<li><p>For each pending PBA bit:</p>
<ul>
<li><p>Read MSI-X table entry (address, data, mask)</p></li>
<li><p>If not masked, generate MSI transaction to PCIe</p></li>
<li><p>Clear PBA bit on successful delivery</p></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>Current Limitation:</strong> Address passthrough causes <code class="docutils literal notranslate"><span class="pre">process_msi_input</span></code> to receive full address 0x18800000 instead of offset 0, preventing PBA updates. MSI output path cannot be fully exercised in current test environment.</p>
</section>
<section id="cii-tracking-and-configuration-update">
<h3>3.7 CII Tracking and Configuration Update<a class="headerlink" href="#cii-tracking-and-configuration-update" title="Permalink to this heading">¶</a></h3>
<p><strong>Configuration Intercept Interface (CII) Flow:</strong></p>
<div class="mermaid">
            sequenceDiagram
    participant PCIE as PCIe Controller
    participant Tile as PCIe Tile
    participant SII as SII Block
    participant SMN as SMN Host

    Note over PCIE: PCIe config space write occurs
    PCIE-&gt;&gt;Tile: Assert pcie_cii_hv signal
    PCIE-&gt;&gt;Tile: Set pcie_cii_addr[7:0]
    PCIE-&gt;&gt;Tile: Set pcie_cii_type[3:0]
    
    Note over Tile: signal_update_process()
    Tile-&gt;&gt;SII: update()
    
    Note over SII: Read CII input signals
    alt pcie_cii_hv == 1
        SII-&gt;&gt;SII: Check type == 0x04 (config write)
        alt type == 0x04
            SII-&gt;&gt;SII: Check addr &lt; 0x80 (first 128B)
            alt addr &lt; 0x80
                SII-&gt;&gt;SII: reg_index = addr[6:2]
                SII-&gt;&gt;SII: cfg_modified_[reg_index] = 1
                SII-&gt;&gt;SII: Assert config_update interrupt
                SII-&gt;&gt;Tile: config_update = 1
                Tile-&gt;&gt;SMN: Interrupt signaled
                
                Note over SMN: Software handles interrupt
                SMN-&gt;&gt;SII: Read CFG_MODIFIED register
                SII-&gt;&gt;SMN: Return modified bitmask
                SMN-&gt;&gt;SII: Write to CFG_MODIFIED (RW1C)
                SII-&gt;&gt;SII: Clear specified bits
                alt All bits cleared
                    SII-&gt;&gt;SII: Deassert config_update
                    SII-&gt;&gt;Tile: config_update = 0
                end
            end
        end
    end
    
    Note over Tile: Reset clears all state
    alt pcie_controller_reset_n == 0
        SII-&gt;&gt;SII: cfg_modified_ = 0
        SII-&gt;&gt;SII: config_update = 0
    end
        </div><p><strong>CII Tracking Details:</strong></p>
<ol class="arabic simple">
<li><p><strong>Detection Phase</strong></p>
<ul class="simple">
<li><p>PCIe controller asserts <code class="docutils literal notranslate"><span class="pre">pcie_cii_hv</span></code> (handshake valid)</p></li>
<li><p>Provides address (<code class="docutils literal notranslate"><span class="pre">pcie_cii_addr</span></code>) and type (<code class="docutils literal notranslate"><span class="pre">pcie_cii_type</span></code>)</p></li>
<li><p>Type 0x04 indicates configuration write</p></li>
</ul>
</li>
<li><p><strong>Filtering</strong></p>
<ul class="simple">
<li><p>Only track first 128 bytes (addr &lt; 0x80)</p></li>
<li><p>Covers standard PCIe config space registers</p></li>
<li><p>Calculate register index: <code class="docutils literal notranslate"><span class="pre">addr[6:2]</span></code> (32-bit aligned)</p></li>
</ul>
</li>
<li><p><strong>State Update</strong></p>
<ul class="simple">
<li><p>Set corresponding bit in 32-bit <code class="docutils literal notranslate"><span class="pre">cfg_modified_</span></code> bitmask</p></li>
<li><p>Assert <code class="docutils literal notranslate"><span class="pre">config_update</span></code> output signal (sticky)</p></li>
<li><p>Interrupt remains asserted until software clears</p></li>
</ul>
</li>
<li><p><strong>Software Clear</strong> (RW1C - Read/Write 1 to Clear)</p>
<ul class="simple">
<li><p>SMN reads <code class="docutils literal notranslate"><span class="pre">CFG_MODIFIED</span></code> register to see which registers changed</p></li>
<li><p>SMN writes 1s to clear specific bits</p></li>
<li><p>When all bits cleared, <code class="docutils literal notranslate"><span class="pre">config_update</span></code> deasserts</p></li>
</ul>
</li>
<li><p><strong>Reset Behavior</strong></p>
<ul class="simple">
<li><p>Controller reset (<code class="docutils literal notranslate"><span class="pre">pcie_controller_reset_n=0</span></code>) clears all state</p></li>
<li><p>Both <code class="docutils literal notranslate"><span class="pre">cfg_modified_</span></code> and <code class="docutils literal notranslate"><span class="pre">config_update</span></code> reset to 0</p></li>
</ul>
</li>
</ol>
</section>
<section id="isolation-and-recovery">
<h3>3.8 Isolation and Recovery<a class="headerlink" href="#isolation-and-recovery" title="Permalink to this heading">¶</a></h3>
<p><strong>Isolation Sequence:</strong></p>
<div class="mermaid">
            sequenceDiagram
    participant EXT as External Control
    participant Tile as PCIe Tile
    participant CFG as Config Registers
    participant Switch as NOC-PCIE Switch
    participant PCIE as PCIe Controller

    Note over Tile: Normal Operation
    EXT-&gt;&gt;Tile: Assert isolate_req signal
    
    Note over Tile: signal_update_process()
    Tile-&gt;&gt;CFG: set_isolate_req(true)
    CFG-&gt;&gt;CFG: system_ready = 0
    CFG-&gt;&gt;CFG: pcie_inbound_app_enable = 0
    CFG-&gt;&gt;CFG: pcie_outbound_app_enable = 0
    CFG-&gt;&gt;Switch: Update enable signals
    
    Note over Switch: All PCIe transactions blocked
    PCIE-&gt;&gt;Switch: b_transport(addr)
    Switch-&gt;&gt;PCIE: TLM_ADDRESS_ERROR_RESPONSE
    
    Note over Tile: Attempt Recovery
    EXT-&gt;&gt;Tile: Deassert isolate_req signal
    Tile-&gt;&gt;CFG: set_isolate_req(false)
    CFG-&gt;&gt;CFG: isolate_req_ = 0
    Note over CFG: Enables NOT restored
    
    Note over Switch: Still blocked (limitation)
    PCIE-&gt;&gt;Switch: b_transport(addr)
    Switch-&gt;&gt;PCIE: TLM_ADDRESS_ERROR_RESPONSE
    
    Note over Tile: Full Recovery Sequence
    EXT-&gt;&gt;Tile: Cold reset cycle
    Note over Tile: Reset does NOT restore enables
    EXT-&gt;&gt;CFG: SMN write system_ready=1
    EXT-&gt;&gt;CFG: SMN write pcie_inbound_app_enable=1
    EXT-&gt;&gt;CFG: SMN write pcie_outbound_app_enable=1
    Note over Switch: Normal operation restored
        </div><p><strong>Isolation Behavior:</strong></p>
<ul class="simple">
<li><p><strong>Trigger</strong>: <code class="docutils literal notranslate"><span class="pre">isolate_req</span></code> signal assertion</p></li>
<li><p><strong>Effect</strong>: Clears all enable flags in <code class="docutils literal notranslate"><span class="pre">ConfigRegBlock</span></code></p></li>
<li><p><strong>Data Path</strong>: All PCIe traffic returns DECERR</p></li>
<li><p><strong>Critical Limitation</strong>: <code class="docutils literal notranslate"><span class="pre">set_isolate_req(false)</span></code> does NOT restore enables</p></li>
<li><p><strong>Recovery Requires</strong>: Cold reset + full SMN reconfiguration</p></li>
</ul>
<p>This is a known architectural limitation documented in the test plan.</p>
</section>
<section id="error-handling">
<h3>3.9 Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this heading">¶</a></h3>
<p><strong>Error Conditions and Responses:</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Condition</p></th>
<th class="head"><p>Detection Point</p></th>
<th class="head"><p>Response</p></th>
<th class="head"><p>Recovery</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Invalid TLB Entry</strong></p></td>
<td><p>TLB translate</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TLM_ADDRESS_ERROR_RESPONSE</span></code></p></td>
<td><p>Configure valid TLB entry</p></td>
</tr>
<tr class="row-odd"><td><p><strong>System Not Ready</strong></p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TLM_ADDRESS_ERROR_RESPONSE</span></code></p></td>
<td><p>Write <code class="docutils literal notranslate"><span class="pre">system_ready=1</span></code></p></td>
</tr>
<tr class="row-even"><td><p><strong>Inbound Path Disabled</strong></p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TLM_ADDRESS_ERROR_RESPONSE</span></code></p></td>
<td><p>Write <code class="docutils literal notranslate"><span class="pre">pcie_inbound_app_enable=1</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><strong>Outbound Path Disabled</strong></p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TLM_ADDRESS_ERROR_RESPONSE</span></code></p></td>
<td><p>Write <code class="docutils literal notranslate"><span class="pre">pcie_outbound_app_enable=1</span></code></p></td>
</tr>
<tr class="row-even"><td><p><strong>Unknown Route</strong></p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TLM_ADDRESS_ERROR_RESPONSE</span></code></p></td>
<td><p>Use valid route (0x0,0x1,0x4,0x6,0x7,0xE,0xF)</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Unmapped SMN Address</strong></p></td>
<td><p>SMN-IO Switch</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TLM_ADDRESS_ERROR_RESPONSE</span></code></p></td>
<td><p>Use valid SMN address range</p></td>
</tr>
<tr class="row-even"><td><p><strong>Bad TLM Command</strong></p></td>
<td><p>Switch routing</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TLM_COMMAND_ERROR_RESPONSE</span></code></p></td>
<td><p>Use READ or WRITE command</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Isolation Active</strong></p></td>
<td><p>Config Registers</p></td>
<td><p>All paths blocked</p></td>
<td><p>Full recovery sequence required</p></td>
</tr>
<tr class="row-even"><td><p><strong>Page Boundary Cross</strong></p></td>
<td><p>TLB indexing</p></td>
<td><p>May access invalid entry</p></td>
<td><p>Align transactions to page boundaries</p></td>
</tr>
</tbody>
</table>
<p><strong>Error Response Flow:</strong></p>
<p>All error responses propagate back through the transaction chain:</p>
<ul class="simple">
<li><p>Switch/TLB detects error</p></li>
<li><p>Sets <code class="docutils literal notranslate"><span class="pre">trans.set_response_status(TLM_ADDRESS_ERROR_RESPONSE)</span></code> or <code class="docutils literal notranslate"><span class="pre">TLM_COMMAND_ERROR_RESPONSE</span></code></p></li>
<li><p>Returns to initiator</p></li>
<li><p>No retry mechanism (single-shot transactions)</p></li>
<li><p>Software must detect and handle errors</p></li>
</ul>
</section>
<section id="operating-mode-summary">
<h3>3.10 Operating Mode Summary<a class="headerlink" href="#operating-mode-summary" title="Permalink to this heading">¶</a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Mode</p></th>
<th class="head"><p>system_ready</p></th>
<th class="head"><p>inbound_enable</p></th>
<th class="head"><p>outbound_enable</p></th>
<th class="head"><p>isolate_req</p></th>
<th class="head"><p>Data Flow</p></th>
<th class="head"><p>Use Case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Normal</strong></p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>Full bidirectional</p></td>
<td><p>Standard operation</p></td>
</tr>
<tr class="row-odd"><td><p><strong>System Only</strong></p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>System paths only</p></td>
<td><p>Pre-application init</p></td>
</tr>
<tr class="row-even"><td><p><strong>Inbound Only</strong></p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>PCIe→NOC only</p></td>
<td><p>Receive-only mode</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Outbound Only</strong></p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>NOC→PCIe only</p></td>
<td><p>Transmit-only mode</p></td>
</tr>
<tr class="row-even"><td><p><strong>Bypass</strong></p></td>
<td><p>0</p></td>
<td><p>x</p></td>
<td><p>x</p></td>
<td><p>0</p></td>
<td><p>Status register only</p></td>
<td><p>Pre-init diagnostics</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Isolated</strong></p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>All blocked</p></td>
<td><p>Fault containment</p></td>
</tr>
<tr class="row-even"><td><p><strong>Reset</strong></p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>All blocked</p></td>
<td><p>Coming out of reset</p></td>
</tr>
</tbody>
</table>
<p><strong>Mode Transitions:</strong></p>
<ul class="simple">
<li><p><strong>Reset → Normal</strong>: Requires software configuration sequence</p></li>
<li><p><strong>Normal → Isolated</strong>: Automatic on <code class="docutils literal notranslate"><span class="pre">isolate_req</span></code> assertion</p></li>
<li><p><strong>Isolated → Normal</strong>: Requires full recovery (reset + reconfig)</p></li>
<li><p><strong>Normal ↔ System Only</strong>: Software enable/disable of application paths</p></li>
<li><p><strong>Any → Reset</strong>: Hardware signal (<code class="docutils literal notranslate"><span class="pre">cold_reset_n</span></code>, <code class="docutils literal notranslate"><span class="pre">warm_reset_n</span></code>)</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="detailed-block-diagram">
<h2>4. Detailed Block Diagram<a class="headerlink" href="#detailed-block-diagram" title="Permalink to this heading">¶</a></h2>
<section id="complete-system-architecture">
<h3>3.1 Complete System Architecture<a class="headerlink" href="#complete-system-architecture" title="Permalink to this heading">¶</a></h3>
<div class="mermaid">
            graph TB
    subgraph &quot;NOC Domain&quot;
        NOCN[NOC Network]
    end
    
    subgraph &quot;SMN Domain&quot;
        SMNN[SMN Network]
    end
    
    subgraph &quot;PCIe Domain&quot;
        PCTRL[PCIe Controller]
    end
    
    subgraph &quot;Keraunos PCIe Tile&quot;
        subgraph &quot;NOC-PCIE Switch&quot;
            NOCP1[Route Decoder&lt;br/&gt;bits 63:60]
            NOCP2[Status Register&lt;br/&gt;routes 0xE/0xF]
            NOCP3[Isolation Gate]
        end
        
        subgraph &quot;Inbound TLBs&quot;
            TLBS[TLB Sys In0&lt;br/&gt;16KB pages]
            TLBA0[TLB App In0 instances 0-3&lt;br/&gt;16MB pages]
            TLBA1[TLB App In1&lt;br/&gt;8GB pages]
        end
        
        subgraph &quot;Outbound TLBs&quot;
            TLBSO[TLB Sys Out0&lt;br/&gt;16KB pages]
            TLBAO0[TLB App Out0&lt;br/&gt;16MB pages]
            TLBAO1[TLB App Out1&lt;br/&gt;8GB pages]
        end
        
        subgraph &quot;NOC-IO Switch&quot;
            NOCI1[NOC Output]
            NOCI2[MSI Input Route]
            NOCI3[TLB App Out Route]
        end
        
        subgraph &quot;SMN-IO Switch&quot;
            SMNI1[Config Router&lt;br/&gt;0x18xxxxxx]
            SMNI2[TLB Config&lt;br/&gt;8 instances]
            SMNI3[Sys TLB Bypass]
        end
        
        subgraph &quot;Control &amp; Status&quot;
            CFG1[Config Registers&lt;br/&gt;0x18000000]
            SII1[SII Block&lt;br/&gt;0x18101000&lt;br/&gt;CII Tracking]
            MSI1[MSI Relay&lt;br/&gt;0x18800000&lt;br/&gt;16 vectors]
            PHY1[PCIe PHY&lt;br/&gt;0x18102000/3000]
        end
        
        subgraph &quot;Clock/Reset&quot;
            CLK1[Cold Reset]
            CLK2[Warm Reset]
            CLK3[Isolation Control]
        end
    end
    
    NOCN &lt;--&gt;|noc_n_target&lt;br/&gt;noc_n_initiator| NOCI1
    SMNN &lt;--&gt;|smn_n_target&lt;br/&gt;smn_n_initiator| SMNI1
    PCTRL &lt;--&gt;|pcie_controller_target&lt;br/&gt;pcie_controller_initiator| NOCP1
    
    NOCP1 --&gt; TLBS
    NOCP1 --&gt; TLBA0
    NOCP1 --&gt; TLBA1
    TLBS --&gt; NOCI1
    TLBA0 --&gt; NOCI1
    TLBA1 --&gt; NOCI1
    
    NOCI1 --&gt; TLBSO
    NOCI1 --&gt; TLBAO0
    NOCI1 --&gt; TLBAO1
    TLBSO --&gt; NOCP1
    TLBAO0 --&gt; NOCP1
    TLBAO1 --&gt; NOCP1
    
    NOCI2 --&gt; MSI1
    MSI1 --&gt; NOCP1
    
    SMNI1 --&gt; CFG1
    SMNI1 --&gt; SII1
    SMNI1 --&gt; MSI1
    SMNI1 --&gt; SMNI2
    SMNI2 -.-&gt;|Config| TLBS
    SMNI2 -.-&gt;|Config| TLBA0
    SMNI2 -.-&gt;|Config| TLBA1
    SMNI2 -.-&gt;|Config| TLBSO
    SMNI2 -.-&gt;|Config| TLBAO0
    SMNI2 -.-&gt;|Config| TLBAO1
    SMNI1 --&gt; PHY1
    
    PCTRL -.-&gt;|CII signals| SII1
    
    CLK1 -.-&gt;|Control| NOCP3
    CLK2 -.-&gt;|Control| CFG1
    CLK3 -.-&gt;|Control| NOCP3
    
    style NOCP1 fill:#e1f5ff
    style NOCI1 fill:#e1f5ff
    style SMNI1 fill:#e1f5ff
    style TLBS fill:#fff4e1
    style TLBA0 fill:#fff4e1
    style TLBA1 fill:#fff4e1
    style TLBSO fill:#fff4e1
    style TLBAO0 fill:#fff4e1
    style TLBAO1 fill:#fff4e1
    style MSI1 fill:#ffe1f5
    style SII1 fill:#ffe1f5
    style CFG1 fill:#e1ffe1
    style CLK1 fill:#f5e1e1
    style CLK2 fill:#f5e1e1
    style CLK3 fill:#f5e1e1
        </div></section>
</section>
<hr class="docutils" />
<section id="data-flow-paths">
<h2>5. Data Flow Paths<a class="headerlink" href="#data-flow-paths" title="Permalink to this heading">¶</a></h2>
<section id="inbound-data-flow-pcie-noc">
<h3>4.1 Inbound Data Flow (PCIe → NOC)<a class="headerlink" href="#inbound-data-flow-pcie-noc" title="Permalink to this heading">¶</a></h3>
<div class="mermaid">
            sequenceDiagram
    participant PC as PCIe Controller
    participant NPS as NOC-PCIE Switch
    participant TLB as Inbound TLB
    participant NIS as NOC-IO Switch
    participant NOC as NOC Network
    
    PC-&gt;&gt;NPS: Write(addr=0x1xxx, data)
    Note over NPS: Route decode: bits[63:60]=0x1
    NPS-&gt;&gt;NPS: Check isolation/enables
    NPS-&gt;&gt;TLB: TLB App In1
    Note over TLB: Index = (addr&gt;&gt;33) &amp; 0x3F = 0
    Note over TLB: Valid check: entry[0].valid = true
    TLB-&gt;&gt;TLB: Translate address
    Note over TLB: translated = (entry[0].addr&lt;&lt;12) | offset
    TLB-&gt;&gt;NIS: Forward with translated addr
    NIS-&gt;&gt;NOC: Route to NOC output
    NOC--&gt;&gt;NIS: TLM_OK_RESPONSE
    NIS--&gt;&gt;TLB: Response
    TLB--&gt;&gt;NPS: Response
    NPS--&gt;&gt;PC: TLM_OK_RESPONSE
        </div></section>
<section id="outbound-data-flow-noc-pcie">
<h3>4.2 Outbound Data Flow (NOC → PCIe)<a class="headerlink" href="#outbound-data-flow-noc-pcie" title="Permalink to this heading">¶</a></h3>
<div class="mermaid">
            sequenceDiagram
    participant NOC as NOC Network
    participant NIS as NOC-IO Switch
    participant TLB as Outbound TLB
    participant NPS as NOC-PCIE Switch
    participant PC as PCIe Controller
    
    NOC-&gt;&gt;NIS: Read(addr=0x10001xxx)
    Note over NIS: Route to TLB App Out0
    NIS-&gt;&gt;TLB: Forward transaction
    Note over TLB: Index = (addr&gt;&gt;24) &amp; 0x3F
    TLB-&gt;&gt;TLB: Translate address
    Note over TLB: Check entry valid, translate
    TLB-&gt;&gt;NPS: Forward to PCIe
    NPS-&gt;&gt;PC: TLM transaction
    PC--&gt;&gt;NPS: Data response
    NPS--&gt;&gt;TLB: Response
    TLB--&gt;&gt;NIS: Response
    NIS--&gt;&gt;NOC: TLM_OK_RESPONSE + data
        </div></section>
<section id="configuration-access-flow-smn-config">
<h3>4.3 Configuration Access Flow (SMN → Config)<a class="headerlink" href="#configuration-access-flow-smn-config" title="Permalink to this heading">¶</a></h3>
<div class="mermaid">
            sequenceDiagram
    participant SMN as SMN Network
    participant SIS as SMN-IO Switch
    participant CFG as Config Target
    
    SMN-&gt;&gt;SIS: Write(addr=0x18101004, data)
    Note over SIS: Route decode: base check
    alt Address = 0x18000000-0x18000FFF
        SIS-&gt;&gt;CFG: Config Reg Block
        Note over CFG: System control registers
    else Address = 0x18101000-0x1811xxxx
        SIS-&gt;&gt;CFG: SII Config (APB)
        Note over CFG: CII config registers
    else Address = 0x18200000-0x182Fxxxx
        SIS-&gt;&gt;CFG: TLB Config (8 instances)
        Note over CFG: TLB entry configuration
    else Address = 0x18800000-0x18800FFF
        SIS-&gt;&gt;CFG: MSI Relay Config
        Note over CFG: MSI-X table, PBA, mask
    end
    
    CFG--&gt;&gt;SIS: Response (may be DECERR)
    Note over CFG: Address passthrough issue:&lt;br/&gt;receives full addr, expects offset
    SIS--&gt;&gt;SMN: Response
        </div></section>
<section id="msi-generation-flow">
<h3>4.4 MSI Generation Flow<a class="headerlink" href="#msi-generation-flow" title="Permalink to this heading">¶</a></h3>
<div class="mermaid">
            sequenceDiagram
    participant NOC as NOC Network
    participant NIS as NOC-IO Switch
    participant MSI as MSI Relay
    participant NPS as NOC-PCIE Switch
    participant PC as PCIe Controller
    
    NOC-&gt;&gt;NIS: Write(addr=0x18800000, data=vector)
    Note over NIS: Detect MSI input address
    NIS-&gt;&gt;MSI: process_msi_input()
    Note over MSI: Check: msix_enable &amp;&amp;&lt;br/&gt;!global_mask &amp;&amp;&lt;br/&gt;!vector_mask[vector]
    
    alt MSI enabled and unmasked
        MSI-&gt;&gt;MSI: Read MSI-X table[vector]
        Note over MSI: Get address, data from table
        MSI-&gt;&gt;MSI: Increment outstanding counter
        MSI-&gt;&gt;NPS: Generate MSI transaction
        NPS-&gt;&gt;PC: MSI write(table_addr, table_data)
        PC--&gt;&gt;NPS: MSI delivered
        NPS--&gt;&gt;MSI: Complete
        MSI-&gt;&gt;MSI: Decrement outstanding
    else MSI masked or disabled
        Note over MSI: PBA bit should be set&lt;br/&gt;(blocked by address passthrough)
    end
    
    MSI--&gt;&gt;NIS: TLM_OK_RESPONSE
    NIS--&gt;&gt;NOC: Complete
        </div></section>
<section id="cii-interrupt-flow">
<h3>4.5 CII Interrupt Flow<a class="headerlink" href="#cii-interrupt-flow" title="Permalink to this heading">¶</a></h3>
<div class="mermaid">
            sequenceDiagram
    participant PC as PCIe Controller
    participant CII as CII Signals
    participant SII as SII Block
    participant INT as Interrupt Output
    
    Note over PC: Host writes to&lt;br/&gt;PCIe config space
    PC-&gt;&gt;CII: pcie_cii_hv = true
    PC-&gt;&gt;CII: pcie_cii_hdr_type = 0x04
    PC-&gt;&gt;CII: pcie_cii_hdr_addr = 0x010
    
    Note over CII: Signal propagation&lt;br/&gt;wait(SC_ZERO_TIME)
    
    CII-&gt;&gt;SII: signal_update_process()
    Note over SII: SiiBlock::update() called
    
    SII-&gt;&gt;SII: CII Tracking Phase
    Note over SII: Check: hv &amp;&amp; type==0x04 &amp;&amp;&lt;br/&gt;addr&lt;0x080
    SII-&gt;&gt;SII: reg_index = addr &gt;&gt; 2 = 4
    SII-&gt;&gt;SII: cii_new_bits = (1 &lt;&lt; 4)
    
    SII-&gt;&gt;SII: cfg_modified Update
    Note over SII: cfg_modified |= cii_new_bits
    
    SII-&gt;&gt;SII: Interrupt Generation
    Note over SII: config_int = (cfg_modified != 0)
    
    SII-&gt;&gt;INT: config_update = true
    Note over INT: Interrupt asserted
    
    Note over PC: Later: reset pulse or RW1C
    PC-&gt;&gt;SII: pcie_controller_reset_n = 0→1
    SII-&gt;&gt;SII: Clear cfg_modified
    SII-&gt;&gt;INT: config_update = false
        </div></section>
</section>
<hr class="docutils" />
<section id="module-descriptions">
<h2>6. Module Descriptions<a class="headerlink" href="#module-descriptions" title="Permalink to this heading">¶</a></h2>
<section id="noc-pcie-switch">
<h3>5.1 NOC-PCIE Switch<a class="headerlink" href="#noc-pcie-switch" title="Permalink to this heading">¶</a></h3>
<p><strong>Purpose:</strong> Routes traffic from PCIe controller to appropriate destination (TLBs, bypass paths, status register).</p>
<p><strong>Route Table:</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Route [63:60]</p></th>
<th class="head"><p>Destination</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>TLB App In0 [0]</p></td>
<td><p>Application TLB instance 0</p></td>
</tr>
<tr class="row-odd"><td><p>0x1</p></td>
<td><p>TLB App In1</p></td>
<td><p>Application TLB (large pages)</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>TLB Sys In0</p></td>
<td><p>System TLB</p></td>
</tr>
<tr class="row-odd"><td><p>0x8</p></td>
<td><p>Bypass App</p></td>
<td><p>Direct to NOC-IO</p></td>
</tr>
<tr class="row-even"><td><p>0x9</p></td>
<td><p>Bypass Sys</p></td>
<td><p>Direct to SMN-IO</p></td>
</tr>
<tr class="row-odd"><td><p>0xE, 0xF</p></td>
<td><p>Status Register</p></td>
<td><p>Read-only status (if system_ready)</p></td>
</tr>
<tr class="row-even"><td><p>Other</p></td>
<td><p>DECERR</p></td>
<td><p>TLM_ADDRESS_ERROR_RESPONSE</p></td>
</tr>
</tbody>
</table>
<p><strong>Status Register Format:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="n">system_ready</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span>    <span class="n">pcie_outbound_app_enable</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span>    <span class="n">pcie_inbound_app_enable</span>
<span class="p">[</span><span class="mi">31</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="n">Reserved</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="translation-lookaside-buffers">
<h3>5.2 Translation Lookaside Buffers<a class="headerlink" href="#translation-lookaside-buffers" title="Permalink to this heading">¶</a></h3>
<p><strong>TLB Configuration:</strong></p>
<div class="mermaid">
            graph LR
    subgraph &quot;Inbound TLBs - 5 instances&quot;
        TLBS[TLB Sys In0&lt;br/&gt;16KB pages&lt;br/&gt;shift=14, index 19:14]
        TLBA0[TLB App In0 instances 0-3&lt;br/&gt;16MB pages&lt;br/&gt;shift=24, index 29:24]
        TLBA1[TLB App In1&lt;br/&gt;8GB pages&lt;br/&gt;shift=33, index 38:33]
    end
    
    subgraph &quot;Outbound TLBs - 3 instances&quot;
        TLBSO[TLB Sys Out0&lt;br/&gt;16KB pages&lt;br/&gt;shift=14, index 19:14]
        TLBAO[TLB App Out0&lt;br/&gt;16MB pages&lt;br/&gt;shift=24, index 29:24]
        TLBAO1[TLB App Out1&lt;br/&gt;8GB pages&lt;br/&gt;shift=33, index 38:33]
    end
    
    subgraph &quot;TLB Entry Structure&quot;
        ENT[valid: 1 bit&lt;br/&gt;addr: 52 bits 63:12&lt;br/&gt;attr: 32 bits AxUSER]
    end
    
    style TLBS fill:#fff4e1
    style TLBA0 fill:#fff4e1
    style TLBA1 fill:#fff4e1
    style TLBSO fill:#fff4e1
    style TLBAO fill:#fff4e1
    style TLBAO1 fill:#fff4e1
    style ENT fill:#e1ffe1
        </div><p><strong>Translation Algorithm:</strong></p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span> <span class="pre">=</span> <span class="pre">(address</span> <span class="pre">&gt;&gt;</span> <span class="pre">page_shift)</span> <span class="pre">&amp;</span> <span class="pre">0x3F</span></code></p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">index</span> <span class="pre">&gt;=</span> <span class="pre">64</span></code> or <code class="docutils literal notranslate"><span class="pre">!entries[index].valid</span></code> → DECERR</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">translated_addr</span> <span class="pre">=</span> <span class="pre">(entries[index].addr</span> <span class="pre">&lt;&lt;</span> <span class="pre">12)</span> <span class="pre">|</span> <span class="pre">(address</span> <span class="pre">&amp;</span> <span class="pre">page_mask)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">axuser</span> <span class="pre">=</span> <span class="pre">entries[index].attr</span></code></p></li>
</ol>
</section>
<section id="msi-relay-unit">
<h3>5.3 MSI Relay Unit<a class="headerlink" href="#msi-relay-unit" title="Permalink to this heading">¶</a></h3>
<p><strong>Architecture:</strong></p>
<div class="mermaid">
            graph TB
    subgraph &quot;MSI Relay Components&quot;
        TBL[MSI-X Table&lt;br/&gt;16 entries&lt;br/&gt;address, data, mask]
        PBA[Pending Bit Array&lt;br/&gt;16 bits&lt;br/&gt;read-only]
        CTL[Control&lt;br/&gt;msix_enable&lt;br/&gt;msix_mask&lt;br/&gt;outstanding counter]
    end
    
    subgraph &quot;Inputs&quot;
        NOCI[NOC-IO Switch&lt;br/&gt;MSI input &#64; 0x18800000]
        SMNI[SMN-IO Switch&lt;br/&gt;Config &#64; 0x18800000]
    end
    
    subgraph &quot;Output&quot;
        NOCP[NOC-PCIE Switch&lt;br/&gt;MSI to PCIe]
    end
    
    NOCI --&gt;|process_msi_input| CTL
    SMNI -.-&gt;|config access&lt;br/&gt;blocked by passthrough| TBL
    CTL --&gt; TBL
    CTL --&gt; PBA
    TBL --&gt;|MSI generation| NOCP
    
    style TBL fill:#ffe1f5
    style PBA fill:#ffe1f5
    style CTL fill:#ffe1f5
        </div><p><strong>MSI-X Table Entry (16 bytes):</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">63</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>   <span class="n">Message</span> <span class="n">Address</span> <span class="p">(</span><span class="mi">64</span><span class="o">-</span><span class="n">bit</span><span class="p">)</span>
<span class="p">[</span><span class="mi">95</span><span class="p">:</span><span class="mi">64</span><span class="p">]</span>  <span class="n">Message</span> <span class="n">Data</span> <span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">bit</span><span class="p">)</span>
<span class="p">[</span><span class="mi">96</span><span class="p">]</span>     <span class="n">Per</span><span class="o">-</span><span class="n">Vector</span> <span class="n">Mask</span> <span class="p">(</span><span class="mi">1</span><span class="o">=</span><span class="n">masked</span><span class="p">)</span>
<span class="p">[</span><span class="mi">127</span><span class="p">:</span><span class="mi">97</span><span class="p">]</span> <span class="n">Reserved</span>
</pre></div>
</div>
</section>
<section id="system-information-interface-sii">
<h3>5.4 System Information Interface (SII)<a class="headerlink" href="#system-information-interface-sii" title="Permalink to this heading">¶</a></h3>
<p><strong>CII Tracking State Machine:</strong></p>
<div class="mermaid">
            stateDiagram-v2
    [*] --&gt; Idle: Reset
    
    Idle --&gt; WaitCII: Normal operation
    WaitCII --&gt; DetectWrite: CII handshake valid
    
    DetectWrite --&gt; CheckType: Read CII header
    CheckType --&gt; CheckAddr: Config write detected
    CheckType --&gt; WaitCII: Not config write
    
    CheckAddr --&gt; SetBit: First 128B of config space
    CheckAddr --&gt; WaitCII: Beyond 128B boundary
    
    SetBit --&gt; AssertInt: Set modified bit
    AssertInt --&gt; WaitCII: Assert interrupt
    
    WaitCII --&gt; ClearInt: Controller reset
    ClearInt --&gt; Idle: Clear all state
    
    note right of SetBit: Tracks 32 config registers
    note right of AssertInt: Sticky until reset or RW1C
        </div><p><strong>APB Registers:</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Register</p></th>
<th class="head"><p>Access</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0000</p></td>
<td><p>CORE_CONTROL</p></td>
<td><p>RW</p></td>
<td><p>Device type [2:0]: 0x4=RP</p></td>
</tr>
<tr class="row-odd"><td><p>0x0004</p></td>
<td><p>CFG_MODIFIED</p></td>
<td><p>RW1C</p></td>
<td><p>Config modified bitmask (32 bits)</p></td>
</tr>
<tr class="row-even"><td><p>0x0008</p></td>
<td><p>BUS_DEV_NUM</p></td>
<td><p>RW</p></td>
<td><p>Bus[15:8], Device[7:0] numbers</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<hr class="docutils" />
<section id="address-map">
<h2>7. Address Map<a class="headerlink" href="#address-map" title="Permalink to this heading">¶</a></h2>
<section id="inbound-address-routing">
<h3>6.1 Inbound Address Routing<a class="headerlink" href="#inbound-address-routing" title="Permalink to this heading">¶</a></h3>
<div class="mermaid">
            graph TD
    START[PCIe Transaction&lt;br/&gt;addr 63:0]
    
    START --&gt; ROUTE{Route bits&lt;br/&gt;63:60}
    
    ROUTE --&gt;|0x0| TLB0[TLB App In0 inst 0&lt;br/&gt;16MB pages]
    ROUTE --&gt;|0x1| TLB1[TLB App In1&lt;br/&gt;8GB pages]
    ROUTE --&gt;|0x4| TLB4[TLB Sys In0&lt;br/&gt;16KB pages]
    ROUTE --&gt;|0x8| BP8[Bypass App&lt;br/&gt;NOC-IO direct]
    ROUTE --&gt;|0x9| BP9[Bypass Sys&lt;br/&gt;SMN-IO direct]
    ROUTE --&gt;|0xE,0xF| STAT[Status Register&lt;br/&gt;Read-only]
    ROUTE --&gt;|Other| ERR[DECERR&lt;br/&gt;TLM_ADDRESS_ERROR]
    
    TLB0 --&gt; NOC[NOC Network]
    TLB1 --&gt; NOC
    TLB4 --&gt; NOC
    BP8 --&gt; NOC
    BP9 --&gt; SMN[SMN Network]
    STAT --&gt; RET[Return status word]
    
    style TLB0 fill:#fff4e1
    style TLB1 fill:#fff4e1
    style TLB4 fill:#fff4e1
    style BP8 fill:#e1f5ff
    style BP9 fill:#e1f5ff
    style STAT fill:#e1ffe1
    style ERR fill:#ffe1e1
        </div></section>
<section id="configuration-address-map">
<h3>6.2 Configuration Address Map<a class="headerlink" href="#configuration-address-map" title="Permalink to this heading">¶</a></h3>
<p><strong>SMN Configuration Space (base 0x18000000):</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Base Address</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Module</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x18000000</p></td>
<td><p>4KB</p></td>
<td><p>Config Reg Block</p></td>
<td><p>System control, enables</p></td>
</tr>
<tr class="row-odd"><td><p>0x18101000</p></td>
<td><p>64KB</p></td>
<td><p>SII APB</p></td>
<td><p>Device type, CFG_MODIFIED, bus/dev</p></td>
</tr>
<tr class="row-even"><td><p>0x18102000</p></td>
<td><p>4KB</p></td>
<td><p>PCIe PHY APB</p></td>
<td><p>PHY APB registers</p></td>
</tr>
<tr class="row-odd"><td><p>0x18103000</p></td>
<td><p>4KB</p></td>
<td><p>PCIe PHY AHB</p></td>
<td><p>PHY AHB registers</p></td>
</tr>
<tr class="row-even"><td><p>0x18200000</p></td>
<td><p>4KB</p></td>
<td><p>TLB Sys In0</p></td>
<td><p>TLB entry config (64×16B)</p></td>
</tr>
<tr class="row-odd"><td><p>0x18210000</p></td>
<td><p>4KB</p></td>
<td><p>TLB App In0 [0]</p></td>
<td><p>TLB entry config</p></td>
</tr>
<tr class="row-even"><td><p>0x18220000</p></td>
<td><p>4KB</p></td>
<td><p>TLB App In0 [1]</p></td>
<td><p>TLB entry config</p></td>
</tr>
<tr class="row-odd"><td><p>0x18230000</p></td>
<td><p>4KB</p></td>
<td><p>TLB App In0 [2]</p></td>
<td><p>TLB entry config</p></td>
</tr>
<tr class="row-even"><td><p>0x18240000</p></td>
<td><p>4KB</p></td>
<td><p>TLB App In0 [3]</p></td>
<td><p>TLB entry config</p></td>
</tr>
<tr class="row-odd"><td><p>0x18250000</p></td>
<td><p>4KB</p></td>
<td><p>TLB App In1</p></td>
<td><p>TLB entry config</p></td>
</tr>
<tr class="row-even"><td><p>0x18260000</p></td>
<td><p>4KB</p></td>
<td><p>TLB Sys Out0</p></td>
<td><p>TLB entry config</p></td>
</tr>
<tr class="row-odd"><td><p>0x18270000</p></td>
<td><p>4KB</p></td>
<td><p>TLB App Out0</p></td>
<td><p>TLB entry config</p></td>
</tr>
<tr class="row-even"><td><p>0x18280000</p></td>
<td><p>4KB</p></td>
<td><p>TLB App Out1</p></td>
<td><p>TLB entry config</p></td>
</tr>
<tr class="row-odd"><td><p>0x18800000</p></td>
<td><p>4KB</p></td>
<td><p>MSI Relay</p></td>
<td><p>MSI-X table, PBA, mask</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<hr class="docutils" />
<section id="clock-and-reset-strategy">
<h2>8. Clock and Reset Strategy<a class="headerlink" href="#clock-and-reset-strategy" title="Permalink to this heading">¶</a></h2>
<section id="reset-hierarchy">
<h3>7.1 Reset Hierarchy<a class="headerlink" href="#reset-hierarchy" title="Permalink to this heading">¶</a></h3>
<div class="mermaid">
            graph TD
    subgraph &quot;Reset Sources&quot;
        COLD[cold_reset_n&lt;br/&gt;Top-level reset]
        WARM[warm_reset_n&lt;br/&gt;Warm reset]
        PCIER[pcie_controller_reset_n&lt;br/&gt;PCIe-specific]
        ISOL[isolate_req&lt;br/&gt;Isolation control]
    end
    
    subgraph &quot;Reset Targets&quot;
        CLK[Clock/Reset Control&lt;br/&gt;pcie_sii_reset_ctrl&lt;br/&gt;pcie_reset_ctrl]
        SII[SII Block&lt;br/&gt;cfg_modified&lt;br/&gt;config_update]
        CFG[Config Registers&lt;br/&gt;system_ready&lt;br/&gt;enables]
    end
    
    COLD --&gt; CLK
    WARM --&gt; CLK
    PCIER --&gt; SII
    ISOL --&gt; CFG
    
    style COLD fill:#f5e1e1
    style WARM fill:#f5e1e1
    style PCIER fill:#f5e1e1
    style ISOL fill:#fff4e1
    style CLK fill:#e1ffe1
    style SII fill:#ffe1f5
    style CFG fill:#e1ffe1
        </div></section>
<section id="reset-effects">
<h3>7.2 Reset Effects<a class="headerlink" href="#reset-effects" title="Permalink to this heading">¶</a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Reset Signal</p></th>
<th class="head"><p>Affects</p></th>
<th class="head"><p>Preserves</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cold_reset_n</span></code></p></td>
<td><p>Clock/Reset control registers</p></td>
<td><p>Config, TLBs, enables, system_ready</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">warm_reset_n</span></code></p></td>
<td><p>Same as cold reset</p></td>
<td><p>Same as cold reset</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_controller_reset_n</span></code></p></td>
<td><p>SII cfg_modified, config_update</p></td>
<td><p>All other state</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">isolate_req</span></code></p></td>
<td><p>Clears all enable flags</p></td>
<td><p>TLB config, register values</p></td>
</tr>
</tbody>
</table>
</section>
<section id="isolation-sequence">
<h3>7.3 Isolation Sequence<a class="headerlink" href="#isolation-sequence" title="Permalink to this heading">¶</a></h3>
<div class="mermaid">
            sequenceDiagram
    participant EXT as External Control
    participant CFG as Config Reg Block
    participant SW as NOC-PCIE Switch
    
    Note over CFG: Initial State:&lt;br/&gt;system_ready=1&lt;br/&gt;inbound_enable=1&lt;br/&gt;outbound_enable=1
    
    EXT-&gt;&gt;CFG: isolate_req = 1
    Note over CFG: wait(SC_ZERO_TIME)
    CFG-&gt;&gt;CFG: system_ready = 0
    CFG-&gt;&gt;CFG: inbound_enable = 0
    CFG-&gt;&gt;CFG: outbound_enable = 0
    CFG-&gt;&gt;SW: Update enables
    Note over SW: All PCIe traffic → DECERR
    
    Note over EXT: Later: attempt recovery
    EXT-&gt;&gt;CFG: isolate_req = 0
    Note over CFG: wait(SC_ZERO_TIME)
    Note over CFG: Enables NOT restored!&lt;br/&gt;Permanent state loss
    
    Note over SW: Traffic still blocked&lt;br/&gt;No recovery mechanism
        </div></section>
</section>
<hr class="docutils" />
<section id="interface-specifications">
<h2>9. Interface Specifications<a class="headerlink" href="#interface-specifications" title="Permalink to this heading">¶</a></h2>
<section id="external-tlm-sockets">
<h3>8.1 External TLM Sockets<a class="headerlink" href="#external-tlm-sockets" title="Permalink to this heading">¶</a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Socket Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Width</p></th>
<th class="head"><p>Direction</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">noc_n_target</span></code></p></td>
<td><p>Target</p></td>
<td><p>64-bit</p></td>
<td><p>Inbound</p></td>
<td><p>NOC → Tile (outbound)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">noc_n_initiator</span></code></p></td>
<td><p>Target</p></td>
<td><p>64-bit</p></td>
<td><p>Outbound</p></td>
<td><p>Tile → NOC (inbound)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">smn_n_target</span></code></p></td>
<td><p>Target</p></td>
<td><p>64-bit</p></td>
<td><p>Inbound</p></td>
<td><p>SMN → Tile (config)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">smn_n_initiator</span></code></p></td>
<td><p>Target</p></td>
<td><p>64-bit</p></td>
<td><p>Outbound</p></td>
<td><p>Tile → SMN (bypass)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_controller_target</span></code></p></td>
<td><p>Target</p></td>
<td><p>64-bit</p></td>
<td><p>Inbound</p></td>
<td><p>PCIe → Tile</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_controller_initiator</span></code></p></td>
<td><p>Target</p></td>
<td><p>64-bit</p></td>
<td><p>Outbound</p></td>
<td><p>Tile → PCIe</p></td>
</tr>
</tbody>
</table>
</section>
<section id="control-and-status-signals">
<h3>8.2 Control and Status Signals<a class="headerlink" href="#control-and-status-signals" title="Permalink to this heading">¶</a></h3>
<p><strong>Input Signals:</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Signal Name</p></th>
<th class="head"><p>Width</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cold_reset_n</span></code></p></td>
<td><p>1</p></td>
<td><p>Cold reset (active low)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">warm_reset_n</span></code></p></td>
<td><p>1</p></td>
<td><p>Warm reset (active low)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">isolate_req</span></code></p></td>
<td><p>1</p></td>
<td><p>Isolation request</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_cii_hv</span></code></p></td>
<td><p>1</p></td>
<td><p>CII header valid</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_cii_hdr_type</span></code></p></td>
<td><p>5</p></td>
<td><p>CII header type</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_cii_hdr_addr</span></code></p></td>
<td><p>12</p></td>
<td><p>CII header address</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_core_clk</span></code></p></td>
<td><p>1</p></td>
<td><p>PCIe core clock</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_controller_reset_n</span></code></p></td>
<td><p>1</p></td>
<td><p>PCIe controller reset</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_flr_request</span></code></p></td>
<td><p>1</p></td>
<td><p>Function-level reset request</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_hot_reset</span></code></p></td>
<td><p>1</p></td>
<td><p>Hot reset indication</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_ras_error</span></code></p></td>
<td><p>1</p></td>
<td><p>RAS error indication</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_dma_completion</span></code></p></td>
<td><p>1</p></td>
<td><p>DMA completion</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_misc_int</span></code></p></td>
<td><p>1</p></td>
<td><p>Miscellaneous interrupt</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">axi_clk</span></code></p></td>
<td><p>1</p></td>
<td><p>AXI clock</p></td>
</tr>
</tbody>
</table>
<p><strong>Output Signals:</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Signal Name</p></th>
<th class="head"><p>Width</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_app_bus_num</span></code></p></td>
<td><p>8</p></td>
<td><p>Application bus number</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_app_dev_num</span></code></p></td>
<td><p>8</p></td>
<td><p>Application device number</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_device_type</span></code></p></td>
<td><p>1</p></td>
<td><p>0=EP, 1=RP</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pcie_sys_int</span></code></p></td>
<td><p>1</p></td>
<td><p>System interrupt</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">function_level_reset</span></code></p></td>
<td><p>1</p></td>
<td><p>FLR forwarded</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">hot_reset_requested</span></code></p></td>
<td><p>1</p></td>
<td><p>Hot reset forwarded</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">config_update</span></code></p></td>
<td><p>1</p></td>
<td><p>Config update interrupt (CII)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ras_error</span></code></p></td>
<td><p>1</p></td>
<td><p>RAS error forwarded</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">dma_completion</span></code></p></td>
<td><p>1</p></td>
<td><p>DMA completion forwarded</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">controller_misc_int</span></code></p></td>
<td><p>1</p></td>
<td><p>Misc interrupt forwarded</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">noc_timeout</span></code></p></td>
<td><p>3</p></td>
<td><p>NOC timeout status</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<hr class="docutils" />
<section id="known-limitations-and-findings">
<h2>10. Known Limitations and Findings<a class="headerlink" href="#known-limitations-and-findings" title="Permalink to this heading">¶</a></h2>
<section id="architecture-limitations">
<h3>9.1 Architecture Limitations<a class="headerlink" href="#architecture-limitations" title="Permalink to this heading">¶</a></h3>
<div class="mermaid">
            graph TB
    subgraph &quot;Known Issues&quot;
        PASS[Address Passthrough&lt;br/&gt;Full address vs offset]
        ISOL[Isolation Recovery&lt;br/&gt;No restore mechanism]
        MSI[MSI PBA&lt;br/&gt;Offset mismatch]
    end
    
    subgraph &quot;Impacts&quot;
        CFG[Config Writes&lt;br/&gt;Mostly blocked]
        REC[Isolation&lt;br/&gt;Single-use only]
        INT[MSI Interrupt&lt;br/&gt;PBA not set]
    end
    
    subgraph &quot;Workarounds&quot;
        DEF[Default Init&lt;br/&gt;Entry 0 valid]
        AVOID[Avoid Isolation&lt;br/&gt;in test env]
        RELAY[MSI Relay&lt;br/&gt;Still functional]
    end
    
    PASS --&gt; CFG
    ISOL --&gt; REC
    MSI --&gt; INT
    
    CFG -.-&gt;|Mitigation| DEF
    REC -.-&gt;|Mitigation| AVOID
    INT -.-&gt;|Mitigation| RELAY
    
    style PASS fill:#ffe1e1
    style ISOL fill:#ffe1e1
    style MSI fill:#ffe1e1
    style CFG fill:#fff4e1
    style REC fill:#fff4e1
    style INT fill:#fff4e1
    style DEF fill:#e1ffe1
    style AVOID fill:#e1ffe1
    style RELAY fill:#e1ffe1
        </div></section>
<section id="documented-findings">
<h3>9.2 Documented Findings<a class="headerlink" href="#documented-findings" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p><strong>Address Passthrough:</strong> SMN-IO/NOC-IO switches pass full addresses to callbacks instead of relative offsets → config writes largely non-functional</p></li>
<li><p><strong>TLB Configuration Blocked:</strong> TLB config writes routed to data paths instead of config callbacks</p></li>
<li><p><strong>MSI Relay Configuration Limited:</strong> MSI-X enable/mask are internal signals; config writes blocked by passthrough</p></li>
<li><p><strong>Signal Propagation (RESOLVED):</strong> <code class="docutils literal notranslate"><span class="pre">sc_core::wait(SC_ZERO_TIME)</span></code> required for signal changes to propagate</p></li>
<li><p><strong>Isolation Recovery Impossible:</strong> <code class="docutils literal notranslate"><span class="pre">isolate_req=false</span></code> does not restore enables</p></li>
<li><p><strong>CII Processing (RESOLVED):</strong> Restored via <code class="docutils literal notranslate"><span class="pre">SiiBlock::update()</span></code> method</p></li>
<li><p><strong>MSI PBA Not Verifiable:</strong> PBA bit set requires offset=0, but receives 0x18800000</p></li>
</ol>
</section>
</section>
<hr class="docutils" />
<section id="test-coverage-summary">
<h2>11. Test Coverage Summary<a class="headerlink" href="#test-coverage-summary" title="Permalink to this heading">¶</a></h2>
<section id="test-suite-overview">
<h3>10.1 Test Suite Overview<a class="headerlink" href="#test-suite-overview" title="Permalink to this heading">¶</a></h3>
<p><strong>76 test cases, 251 assertions, 0 failures</strong></p>
<div class="mermaid">
            pie title Test Distribution
    &quot;E2E Tests (41)&quot; : 41
    &quot;Directed Tests (35)&quot; : 35
        </div><div class="mermaid">
            graph LR
    subgraph &quot;Test Categories&quot;
        E2E[E2E Tests&lt;br/&gt;41 tests]
        DIR[Directed Tests&lt;br/&gt;35 tests]
    end
    
    subgraph &quot;E2E Breakdown&quot;
        E1[Inbound TLB: 10]
        E2[Outbound TLB: 9]
        E3[Bypass: 2]
        E4[MSI: 8]
        E5[SII: 4]
        E6[Switch: 4]
        E7[Power/Isolation: 2]
        E8[Integration: 2]
    end
    
    subgraph &quot;Directed Breakdown&quot;
        D1[TLB Unit: 8]
        D2[MSI Unit: 5]
        D3[Switch Unit: 7]
        D4[Config: 3]
        D5[SII: 6]
        D6[Signals: 3]
        D7[Reset: 2]
        D8[Integration: 1]
    end
    
    E2E --&gt; E1
    E2E --&gt; E2
    E2E --&gt; E3
    E2E --&gt; E4
    E2E --&gt; E5
    E2E --&gt; E6
    E2E --&gt; E7
    E2E --&gt; E8
    
    DIR --&gt; D1
    DIR --&gt; D2
    DIR --&gt; D3
    DIR --&gt; D4
    DIR --&gt; D5
    DIR --&gt; D6
    DIR --&gt; D7
    DIR --&gt; D8
    
    style E2E fill:#e1f5ff
    style DIR fill:#fff4e1
        </div></section>
<section id="coverage-metrics">
<h3>10.2 Coverage Metrics<a class="headerlink" href="#coverage-metrics" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>Functional Coverage:</strong> 100% of testable features</p></li>
<li><p><strong>Route Coverage:</strong> All 16 route values exercised (0x0-0xF)</p></li>
<li><p><strong>TLB Boundary Coverage:</strong> Entry 0, 1, 63 tested</p></li>
<li><p><strong>Error Path Coverage:</strong> DECERR, isolation blocking, invalid TLB entries</p></li>
<li><p><strong>Signal Coverage:</strong> All input/output signals exercised</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="references">
<h2>12. References<a class="headerlink" href="#references" title="Permalink to this heading">¶</a></h2>
<section id="related-documentation">
<h3>11.1 Related Documentation<a class="headerlink" href="#related-documentation" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>SystemC Design Document:</strong> Detailed low-level implementation</p></li>
<li><p><strong>Test Plan:</strong> Comprehensive verification strategy and results</p></li>
<li><p><strong>Test Implementation:</strong> 76 test cases in <code class="docutils literal notranslate"><span class="pre">Keranous_pcie_tileTest.cc</span></code></p></li>
</ul>
</section>
<section id="source-code-organization">
<h3>11.2 Source Code Organization<a class="headerlink" href="#source-code-organization" title="Permalink to this heading">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Keraunos_PCIe_tile/
├── SystemC/
│   ├── include/         (15 header files)
│   └── src/             (15 implementation files)
├── Tests/
│   └── Unittests/
│       ├── Keranous_pcie_tileTest.cc        (76 tests)
│       └── Keranous_pcie_tileTestHarness.h
└── doc/
    ├── Keraunos_PCIe_Tile_HLD.md
    ├── Keraunos_PCIE_Tile_SystemC_Design_Document.md
    └── Keraunos_PCIE_Tile_Testplan.md
</pre></div>
</div>
<hr class="docutils" />
<p><strong>Document Control:</strong></p>
<ul class="simple">
<li><p><strong>Version:</strong> 1.0</p></li>
<li><p><strong>Date:</strong> February 5, 2026</p></li>
<li><p><strong>Status:</strong> Released</p></li>
<li><p><strong>Next Review:</strong> Upon DUT architecture changes or test plan updates</p></li>
</ul>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2026, Keraunos PCIe Tile Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/hld.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>