<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Synopsys Simulation Probes (SimProbe) Usage Guide &mdash; Keraunos PCIe Tile 2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="https://unpkg.com/mermaid@10.6.1/dist/mermaid.min.js"></script>
        <script>
mermaid.initialize({
    startOnLoad: true,
    theme: 'default',
    themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#000',
        primaryBorderColor: '#1976d2',
        lineColor: '#1976d2',
        secondaryColor: '#fff4e1',
        tertiaryColor: '#e8f5e9'
    },
    flowchart: {
        useMaxWidth: true,
        htmlLabels: true,
        curve: 'basis',
        padding: 15
    },
    sequence: {
        useMaxWidth: true,
        diagramMarginX: 50,
        diagramMarginY: 10,
        actorMargin: 50,
        boxMargin: 10,
        boxTextMargin: 5,
        noteMargin: 10,
        messageMargin: 35
    },
    gantt: {
        useMaxWidth: true,
        barHeight: 20,
        barGap: 4,
        topPadding: 50,
        leftPadding: 75,
        gridLineStartPadding: 35
    },
    class: {
        useMaxWidth: true
    },
    state: {
        useMaxWidth: true
    }
});
</script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Keraunos PCIe Tile
          </a>
              <div class="version">
                2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Keraunos_System_Architecture.html">Keraunos System Architecture</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#pcie-tile-integration-in-keraunos-e100-chiplet-ecosystem">PCIe Tile Integration in Keraunos-E100 Chiplet Ecosystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#executive-summary">Executive Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#table-of-contents">Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#system-overview">1. System Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#grendel-chiplet-ecosystem">1.1 Grendel Chiplet Ecosystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#keraunos-e100-role">1.2 Keraunos-E100 Role</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#keraunos-e100-chiplet-architecture">2. Keraunos-E100 Chiplet Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#high-level-block-diagram">2.1 High-Level Block Diagram</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#key-subsystems">2.2 Key Subsystems</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_System_Architecture.html#chiplet-harness">2.2.1 Chiplet Harness</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_System_Architecture.html#pcie-subsystem">2.2.2 PCIe Subsystem</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_System_Architecture.html#hsio-high-speed-i-o-tiles">2.2.3 HSIO (High-Speed I/O) Tiles</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_System_Architecture.html#noc-infrastructure">2.2.4 NOC Infrastructure</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#pcie-tile-position-in-the-system">3. PCIe Tile Position in the System</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#pcie-tile-overview">3.1 PCIe Tile Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#architectural-position">3.2 Architectural Position</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#key-interfaces">3.3 Key Interfaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#connectivity-architecture">4. Connectivity Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#inbound-data-path-host-chip">4.1 Inbound Data Path (Host → Chip)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#outbound-data-path-chip-host">4.2 Outbound Data Path (Chip → Host)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#configuration-path-smn-pcie-tile-registers">4.3 Configuration Path (SMN → PCIe Tile Registers)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#msi-interrupt-path-chip-host">4.4 MSI Interrupt Path (Chip → Host)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#data-flow-paths">5. Data Flow Paths</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#end-to-end-data-flow-example-host-dma-to-quasar">5.1 End-to-End Data Flow Example: Host DMA to Quasar</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#multi-hop-data-flow-quasar-pcie-host-pcie-quasar">5.2 Multi-Hop Data Flow: Quasar → PCIe → Host → PCIe → Quasar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#address-space-integration">6. Address Space Integration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#system-address-map">6.1 System Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#pcie-bar-base-address-register-mapping">6.2 PCIe BAR (Base Address Register) Mapping</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#address-translation-stages">6.3 Address Translation Stages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#system-use-cases">7. System Use Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#use-case-1-model-initialization">7.1 Use Case 1: Model Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#use-case-2-inference-execution">7.2 Use Case 2: Inference Execution</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#use-case-3-package-to-package-communication">7.3 Use Case 3: Package-to-Package Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#use-case-4-system-management">7.4 Use Case 4: System Management</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#appendices">8. Appendices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#acronyms-and-abbreviations">8.1 Acronyms and Abbreviations</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#reference-documents">8.2 Reference Documents</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#revision-history">8.3 Revision History</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html">Keraunos PCIe Tile - High-Level Design Document</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#table-of-contents">Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#introduction">1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#purpose">1.1 Purpose</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#scope">1.2 Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#definitions-and-acronyms">1.3 Definitions and Acronyms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#architecture-overview">2. Architecture Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#top-level-architecture">2.1 Top-Level Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#design-principles">2.2 Design Principles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#block-diagram">3. Block Diagram</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#tile-level-block-diagram">3.1 Tile-Level Block Diagram</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#data-flow-paths">3.2 Data Flow Paths</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#module-descriptions">4. Module Descriptions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#noc-pcie-switch">4.1 NOC-PCIE Switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#noc-io-switch">4.2 NOC-IO Switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#smn-io-switch">4.3 SMN-IO Switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#translation-lookaside-buffers-tlbs">4.4 Translation Lookaside Buffers (TLBs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#msi-relay-unit">4.5 MSI Relay Unit</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#system-information-interface-sii-block">4.6 System Information Interface (SII) Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#configuration-register-block">4.7 Configuration Register Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#clock-and-reset-control">4.8 Clock and Reset Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#pcie-phy-model">4.9 PCIe PHY Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#pll-cgm-clock-generation-module">4.10 PLL/CGM (Clock Generation Module)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#interface-specifications">5. Interface Specifications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#external-tlm-sockets">5.1 External TLM Sockets</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#control-input-signals">5.2 Control Input Signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#output-signals">5.3 Output Signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#internal-signals">5.4 Internal Signals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#address-map">6. Address Map</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#inbound-address-map-pcie-noc-smn">6.1 Inbound Address Map (PCIe → NOC/SMN)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#configuration-address-map-smn">6.2 Configuration Address Map (SMN)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#msi-relay-address-map-0x18800000">6.3 MSI Relay Address Map (0x18800000)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#data-flow">7. Data Flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#inbound-data-flow-pcie-noc">7.1 Inbound Data Flow (PCIe → NOC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#outbound-data-flow-noc-pcie">7.2 Outbound Data Flow (NOC → PCIe)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#configuration-access-flow-smn-config-registers">7.3 Configuration Access Flow (SMN → Config Registers)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#msi-generation-flow-noc-pcie-via-msi-relay">7.4 MSI Generation Flow (NOC → PCIe via MSI Relay)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#cii-interrupt-flow-pcie-config-write-config-update">7.5 CII Interrupt Flow (PCIe Config Write → config_update)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#clock-and-reset-strategy">8. Clock and Reset Strategy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#clock-domains">8.1 Clock Domains</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#reset-strategy">8.2 Reset Strategy</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#power-on-initialization">8.3 Power-On Initialization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#configuration-and-control">9. Configuration and Control</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#tile-initialization-sequence">9.1 Tile Initialization Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#runtime-control">9.2 Runtime Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#status-monitoring">9.3 Status Monitoring</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#references">10. References</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#related-documents">10.1 Related Documents</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#source-code-organization">10.2 Source Code Organization</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#key-design-decisions">10.3 Key Design Decisions</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#known-limitations-and-findings">10.4 Known Limitations and Findings</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#appendix-a-signal-timing-diagrams">Appendix A: Signal Timing Diagrams</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#a-1-cii-interrupt-timing">A.1 CII Interrupt Timing</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#a-2-isolation-sequence">A.2 Isolation Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#a-3-cold-reset-cycle">A.3 Cold Reset Cycle</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#appendix-b-address-decode-examples">Appendix B: Address Decode Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#b-1-inbound-tlb-translation-tlb-sys-in0">B.1 Inbound TLB Translation (TLB Sys In0)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#b-2-status-register-access">B.2 Status Register Access</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#b-3-smn-config-write-address-passthrough-issue">B.3 SMN Config Write (Address Passthrough Issue)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#appendix-c-test-coverage-summary">Appendix C: Test Coverage Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html">Keraunos PCIE Tile SystemC/TLM2.0 Design Document</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#sphinx-setup-instructions">Sphinx Setup Instructions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#install-required-extensions">1. Install Required Extensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configure-conf-py">2. Configure <code class="docutils literal notranslate"><span class="pre">conf.py</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#build-html-documentation">3. Build HTML Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#alternative-use-make">4. Alternative: Use make</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#key-implementation-features">⭐ Key Implementation Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#table-of-contents">Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#introduction">1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#purpose">1.1 Purpose</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scope">1.2 Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#references">1.3 References</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#implementation-version">1.4 Implementation Version</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#refactored-architecture-overview-new">1.5 Refactored Architecture Overview ⭐ NEW</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#why-refactoring-was-necessary">1.5.1 Why Refactoring Was Necessary</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#refactored-architecture-pattern">1.5.2 Refactored Architecture Pattern</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#original-design-socket-based">Original Design (Socket-Based):</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#refactored-design-function-based">Refactored Design (Function-Based):</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#function-callback-communication-pattern">1.5.3 Function Callback Communication Pattern</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#callback-type-definition">Callback Type Definition:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#setting-up-callbacks-wire-components">Setting Up Callbacks (Wire Components):</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#benefits-of-function-callbacks">Benefits of Function Callbacks:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#smart-pointer-memory-management">1.5.4 Smart Pointer Memory Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scml2-memory-integration">1.5.5 SCML2 Memory Integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#temporal-decoupling-support">1.5.6 Temporal Decoupling Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#modern-c-best-practices-applied">1.5.7 Modern C++ Best Practices Applied</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#file-organization">1.5.8 File Organization</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#component-communication-pattern">1.5.9 Component Communication Pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#null-safety-pattern">1.5.10 Null Safety Pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#performance-characteristics">1.5.11 Performance Characteristics</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#code-example-complete-transaction-path">1.5.12 Code Example - Complete Transaction Path</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#system-overview">2. System Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#keraunos-pcie-tile-context">2.1 Keraunos PCIE Tile Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#modeled-components">2.2 Modeled Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#design-objectives">2.3 Design Objectives</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#architecture">3. Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#overall-structure">3.1 Overall Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#component-hierarchy">3.2 Component Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#data-flow">3.3 Data Flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-traffic-flow">Inbound Traffic Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#outbound-traffic-flow">Outbound Traffic Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-flow">MSI Flow</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#component-design">4. Component Design</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlb-common-structures">4.1 TLB Common Structures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbentry-structure">4.1.1 TlbEntry Structure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-tlb-design">4.2 Inbound TLB Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#overview-and-use-cases">4.2.1 Overview and Use Cases</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbsysin0-system-management-inbound-tlb">4.2.2 TLBSysIn0 - System Management Inbound TLB</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbappin0-application-inbound-tlb-bar0-1">4.2.3 TLBAppIn0 - Application Inbound TLB (BAR0/1)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbappin1-application-inbound-tlb-bar4-5">4.2.4 TLBAppIn1 - Application Inbound TLB (BAR4/5)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-tlb-translation-flow">4.2.5 Inbound TLB Translation Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#address-translation-examples">4.2.6 Address Translation Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#axuser-field-format">4.2.7 AxUSER Field Format</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-and-initialization">4.2.8 Configuration and Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#error-handling">4.2.9 Error Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#integration-with-system">4.2.10 Integration with System</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#outbound-tlb-design">4.3 Outbound TLB Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id1">4.3.1 Overview and Use Cases</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbsysout0-system-management-outbound-tlb">4.3.2 TLBSysOut0 - System Management Outbound TLB</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbappout0-application-outbound-tlb-high-address">4.3.3 TLBAppOut0 - Application Outbound TLB (High Address)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbappout1-application-outbound-tlb-dbi-access">4.3.4 TLBAppOut1 - Application Outbound TLB (DBI Access)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#outbound-tlb-translation-flow">4.3.5 Outbound TLB Translation Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id2">4.3.6 Address Translation Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id3">4.3.7 Configuration and Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id4">4.3.8 Error Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id5">4.3.9 Integration with System</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-relay-unit-design">4.4 MSI Relay Unit Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#overview">4.4.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id6">4.4.2 Architecture</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-x-table-entry">4.4.3 MSI-X Table Entry</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pending-bit-array-pba">4.4.4 Pending Bit Array (PBA)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-thrower-logic">4.4.5 MSI Thrower Logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#register-map">4.4.6 Register Map</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#intra-tile-fabric-switch-design">4.5 Intra-Tile Fabric Switch Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#noc-pcie-switch">4.5.1 NOC-PCIE Switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#noc-io-switch">4.5.2 NOC-IO Switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#smn-io-switch">4.5.3 SMN-IO Switch</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#system-information-interface-sii-block">4.6 System Information Interface (SII) Block</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id7">4.6.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#architecture-and-operation">4.6.2 Architecture and Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#cii-tracking-implementation">4.6.3 CII Tracking Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id8">4.6.4 Register Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#clock-domain-crossing">4.6.5 Clock Domain Crossing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#interrupt-generation-and-routing">4.6.6 Interrupt Generation and Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#interface-specification">4.6.7 Interface Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#implementation-details">4.6.8 Implementation Details</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-register-block">4.7 Configuration Register Block</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id9">4.7.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#status-registers">4.7.2 Status Registers</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#isolation-behavior">4.7.3 Isolation Behavior</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#clock-reset-control-module">4.8 Clock &amp; Reset Control Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id10">4.8.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#clock-domains">4.8.2 Clock Domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#reset-sequence">4.8.3 Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#interface">4.8.4 Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pll-cgm-clock-generation-module">4.9 PLL/CGM (Clock Generation Module)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id11">4.9.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pll-lock">4.9.2 PLL Lock</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id12">4.9.3 Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pcie-phy-model">4.10 PCIE PHY Model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id13">4.10.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#features">4.10.2 Features</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id14">4.10.3 Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#external-interface-modules">4.11 External Interface Modules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#noc-n-interface">4.11.1 NOC-N Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#smn-n-interface">4.11.2 SMN-N Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#top-level-keraunos-pcie-tile-module">4.12 Top-Level Keraunos PCIE Tile Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id15">4.12.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#external-interfaces">4.12.2 External Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#internal-connections">4.12.3 Internal Connections</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#interface-specifications">5. Interface Specifications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlm2-0-interfaces">5.1 TLM2.0 Interfaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#axi4-target-socket-inbound-tlbs">5.1.1 AXI4 Target Socket (Inbound TLBs)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#axi4-initiator-socket-all-tlbs">5.1.2 AXI4 Initiator Socket (All TLBs)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#apb-target-socket-configuration">5.1.3 APB Target Socket (Configuration)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#axi4-lite-initiator-socket-msi-relay">5.1.4 AXI4-Lite Initiator Socket (MSI Relay)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#systemc-signals">5.2 SystemC Signals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#control-signals">5.2.1 Control Signals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#address-translation-interfaces">5.3 Address Translation Interfaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlb-lookup-methods">5.3.1 TLB Lookup Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-methods">5.3.2 Configuration Methods</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id16">6. Implementation Details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#address-translation-algorithms">6.1 Address Translation Algorithms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-translation-tlbsysin0">6.1.1 Inbound Translation (TLBSysIn0)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#outbound-translation-tlbappout0">6.1.2 Outbound Translation (TLBAppOut0)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id17">6.2 Error Handling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#invalid-tlb-entry">6.2.1 Invalid TLB Entry</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#out-of-range-index">6.2.2 Out-of-Range Index</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-relay-unit-state-machine">6.3 MSI Relay Unit State Machine</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#threading-model">6.4 Threading Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#memory-modeling">6.5 Memory Modeling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#modeling-approach">7. Modeling Approach</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#abstraction-level">7.1 Abstraction Level</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scml2-usage">7.2 SCML2 Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#socket-type-selection-rationale">7.2.1 Socket Type Selection Rationale</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlm2-0-compliance">7.3 TLM2.0 Compliance</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#design-patterns">7.4 Design Patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#performance-considerations">8. Performance Considerations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#simulation-performance">8.1 Simulation Performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#optimization-opportunities">8.2 Optimization Opportunities</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scalability">8.3 Scalability</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#dependencies-and-requirements">9. Dependencies and Requirements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#software-dependencies">9.1 Software Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#hardware-dependencies">9.2 Hardware Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#integration-requirements">9.3 Integration Requirements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#detailed-implementation-architecture">9. Detailed Implementation Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#class-hierarchy-and-relationships">9.1 Class Hierarchy and Relationships</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#top-level-module-only-sc-module">Top-Level Module (Only sc_module):</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#internal-component-pattern">Internal Component Pattern:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#communication-architecture">9.2 Communication Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#transaction-flow-pattern">Transaction Flow Pattern:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#memory-management-architecture">9.3 Memory Management Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#smart-pointer-ownership-tree">Smart Pointer Ownership Tree:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#callback-wiring-implementation">9.4 Callback Wiring Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#complete-wiring-example">Complete Wiring Example:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scml2-memory-usage-pattern">9.5 SCML2 Memory Usage Pattern</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-storage-implementation">Configuration Storage Implementation:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#component-lifecycle">9.6 Component Lifecycle</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#initialization-sequence">Initialization Sequence:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#transaction-processing-flow">9.7 Transaction Processing Flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-pcie-transaction-example">Inbound PCIe Transaction Example:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#routing-decision-implementation">9.8 Routing Decision Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#noc-pcie-switch-routing-logic">NOC-PCIE Switch Routing Logic:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlb-translation-implementation">9.9 TLB Translation Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#translation-algorithm">Translation Algorithm:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#error-handling-strategy">9.10 Error Handling Strategy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#layered-error-response">Layered Error Response:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-register-implementation">9.11 Configuration Register Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#register-access-pattern">Register Access Pattern:</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#implementation-guide">10. Implementation Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#building-the-design">10.1 Building the Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#prerequisites">Prerequisites:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#build-commands">Build Commands:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#build-output">Build Output:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#running-tests">10.2 Running Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#unit-tests-auto-generated">Unit Tests (Auto-Generated):</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-coverage">Test Coverage:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#adding-new-components">10.3 Adding New Components</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pattern-for-c-class-components">Pattern for C++ Class Components:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#debugging-and-troubleshooting">10.4 Debugging and Troubleshooting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#common-issues-and-solutions">Common Issues and Solutions:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#debug-tools">Debug Tools:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#performance-tuning">10.5 Performance Tuning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#temporal-decoupling-configuration">Temporal Decoupling Configuration:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#adding-timing-annotations">Adding Timing Annotations:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-development-guide">10.6 Test Development Guide</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#adding-new-test-cases">Adding New Test Cases:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-management">10.7 Configuration Management</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlb-configuration-example">TLB Configuration Example:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#integration-with-vdk-platform">10.8 Integration with VDK Platform</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#module-instantiation-in-platform">Module Instantiation in Platform:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#memory-management-best-practices">10.9 Memory Management Best Practices</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#raii-pattern-already-applied">RAII Pattern (Already Applied):</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#coding-standards-applied">10.10 Coding Standards Applied</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#modern-c-17-features-used">Modern C++17 Features Used:</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-infrastructure">11. Test Infrastructure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-framework-overview">11.1 Test Framework Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-categories-33-tests">11.2 Test Categories (33 Tests)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-execution-results">11.3 Test Execution Results</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-api-examples">11.4 Test API Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#coverage-goals">11.5 Coverage Goals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#migration-from-original-design">12. Migration from Original Design</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#for-developers-familiar-with-original">12.1 For Developers Familiar with Original</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#api-migration-guide">12.2 API Migration Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#backward-compatibility-notes">12.3 Backward Compatibility Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#known-limitations-and-future-work">13. Known Limitations and Future Work</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#current-limitations">13.1 Current Limitations</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#future-enhancements">13.2 Future Enhancements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#lessons-learned-and-best-practices">14. Lessons Learned and Best Practices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#architecture-decisions">14.1 Architecture Decisions</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#design-patterns-applied">14.2 Design Patterns Applied</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#recommendations-for-similar-projects">14.3 Recommendations for Similar Projects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#appendix-a-implemented-components-summary">Appendix A: Implemented Components Summary</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#a-1-complete-component-list">A.1 Complete Component List</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#a-2-component-statistics">A.2 Component Statistics</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#a-3-scml-compliance">A.3 SCML Compliance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#appendix-b-address-map-summary">Appendix B: Address Map Summary</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-1-tlb-configuration-space">B.1 TLB Configuration Space</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-2-msi-relay-unit-address-map">B.2 MSI Relay Unit Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-3-sii-block-address-map">B.3 SII Block Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-4-config-register-block-address-map">B.4 Config Register Block Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-5-smn-io-switch-address-map">B.5 SMN-IO Switch Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-6-noc-io-switch-address-map">B.6 NOC-IO Switch Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-7-noc-pcie-switch-routing-map">B.7 NOC-PCIE Switch Routing Map</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#appendix-c-acronyms-and-abbreviations">Appendix C: Acronyms and Abbreviations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html">Keraunos PCIE Tile SystemC/TLM2.0 Testplan</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#table-of-contents">Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#introduction">1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#purpose">1.1 Purpose</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#scope">1.2 Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-objectives">1.3 Test Objectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#references">1.4 References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-traceability-matrix">1.5 Test Traceability Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-environment">2. Test Environment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#testbench-structure">2.1 Testbench Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-components">2.2 Test Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-tools">2.3 Test Tools</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-strategy">3. Test Strategy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-levels">3.1 Test Levels</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-methodology">3.2 Test Methodology</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-phases">3.3 Test Phases</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#inbound-tlb-test-cases">4. Inbound TLB Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlbsysin0-test-cases">4.1 TLBSysIn0 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-sys-001-basic-address-translation">TC_INBOUND_SYS_001: Basic Address Translation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-sys-002-invalid-entry-detection">TC_INBOUND_SYS_002: Invalid Entry Detection</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-sys-003-index-calculation">TC_INBOUND_SYS_003: Index Calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-sys-004-page-boundary-crossing">TC_INBOUND_SYS_004: Page Boundary Crossing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-sys-005-axuser-field-mapping">TC_INBOUND_SYS_005: AxUSER Field Mapping</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-sys-006-system-ready-bypass">TC_INBOUND_SYS_006: System Ready Bypass</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlbappin0-test-cases">4.2 TLBAppIn0 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-app0-001-bar0-1-translation">TC_INBOUND_APP0_001: BAR0/1 Translation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-app0-002-multiple-instance-support">TC_INBOUND_APP0_002: Multiple Instance Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-app0-003-16mb-page-size">TC_INBOUND_APP0_003: 16MB Page Size</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-app0-004-non-cacheable-and-qosid">TC_INBOUND_APP0_004: Non-Cacheable and QoSID</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlbappin1-test-cases">4.3 TLBAppIn1 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-app1-001-bar4-5-translation">TC_INBOUND_APP1_001: BAR4/5 Translation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-app1-002-8gb-page-size">TC_INBOUND_APP1_002: 8GB Page Size</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-app1-003-dram-mapping">TC_INBOUND_APP1_003: DRAM Mapping</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#outbound-tlb-test-cases">5. Outbound TLB Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlbsysout0-test-cases">5.1 TLBSysOut0 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-sys-001-dbi-access-translation">TC_OUTBOUND_SYS_001: DBI Access Translation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-sys-002-64kb-page-size">TC_OUTBOUND_SYS_002: 64KB Page Size</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-sys-003-all-16-entries">TC_OUTBOUND_SYS_003: All 16 Entries</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlbappout0-test-cases">5.2 TLBAppOut0 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-app0-001-high-address-translation-256tb">TC_OUTBOUND_APP0_001: High Address Translation (&gt;=256TB)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-app0-002-address-range-check">TC_OUTBOUND_APP0_002: Address Range Check</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-app0-003-16tb-page-size">TC_OUTBOUND_APP0_003: 16TB Page Size</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlbappout1-test-cases">5.3 TLBAppOut1 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-app1-001-low-address-translation-256tb">TC_OUTBOUND_APP1_001: Low Address Translation (&lt;256TB)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-app1-002-dbi-access-from-application">TC_OUTBOUND_APP1_002: DBI Access from Application</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#msi-relay-unit-test-cases">6. MSI Relay Unit Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#register-access-tests">6.1 Register Access Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-001-msi-receiver-write">TC_MSI_RELAY_001: MSI Receiver Write</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-002-msi-x-table-configuration">TC_MSI_RELAY_002: MSI-X Table Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-003-outstanding-count">TC_MSI_RELAY_003: Outstanding Count</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#msi-generation-tests">6.2 MSI Generation Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-004-basic-msi-generation">TC_MSI_RELAY_004: Basic MSI Generation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-005-msi-x-enable-control">TC_MSI_RELAY_005: MSI-X Enable Control</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-006-global-mask-control">TC_MSI_RELAY_006: Global Mask Control</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-007-vector-mask-control">TC_MSI_RELAY_007: Vector Mask Control</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-008-invalid-entry-handling">TC_MSI_RELAY_008: Invalid Entry Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-009-multiple-pending-interrupts">TC_MSI_RELAY_009: Multiple Pending Interrupts</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-010-setip-signal">TC_MSI_RELAY_010: SetIP Signal</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-011-all-16-vectors">TC_MSI_RELAY_011: All 16 Vectors</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#integration-test-cases">7. Integration Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlb-msi-relay-integration">7.1 TLB + MSI Relay Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-integration-001-msi-x-table-access-via-tlb">TC_INTEGRATION_001: MSI-X Table Access via TLB</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-integration-002-msi-generation-through-fabric">TC_INTEGRATION_002: MSI Generation Through Fabric</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#multiple-tlb-integration">7.2 Multiple TLB Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-integration-003-concurrent-tlb-operations">TC_INTEGRATION_003: Concurrent TLB Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-integration-004-outbound-inbound-round-trip">TC_INTEGRATION_004: Outbound + Inbound Round Trip</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#switch-test-cases">8. Switch Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#noc-pcie-switch-test-cases">8.1 NOC-PCIE Switch Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-pcie-001-address-routing-based-on-axaddr-63-60">TC_SWITCH_NOC_PCIE_001: Address Routing Based on AxADDR[63:60]</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-pcie-002-status-register-special-routing">TC_SWITCH_NOC_PCIE_002: Status Register Special Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-pcie-003-isolation-support">TC_SWITCH_NOC_PCIE_003: Isolation Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-pcie-004-inbound-enable-control">TC_SWITCH_NOC_PCIE_004: Inbound Enable Control</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#enable-gating-test-cases-new-feb-2026">8.4 Enable Gating Test Cases (NEW - Feb 2026)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-negative-enable-001-inbound-enable-blocks-pcienoc-traffic">TC_NEGATIVE_ENABLE_001: Inbound Enable Blocks PCIe→NOC Traffic</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-negative-enable-002-outbound-enable-blocks-nocpcie-traffic">TC_NEGATIVE_ENABLE_002: Outbound Enable Blocks NOC→PCIe Traffic</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-negative-enable-003-both-enables-disabled-complete-isolation">TC_NEGATIVE_ENABLE_003: Both Enables Disabled - Complete Isolation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-negative-enable-004-both-enables-active-positive-control">TC_NEGATIVE_ENABLE_004: Both Enables Active - Positive Control</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#enable-gating-implementation-architecture">8.5 Enable Gating Implementation Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-pcie-005-bypass-path-routing">TC_SWITCH_NOC_PCIE_005: Bypass Path Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-pcie-006-address-conversion-64-bit-to-52-bit">TC_SWITCH_NOC_PCIE_006: Address Conversion (64-bit to 52-bit)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#noc-io-switch-test-cases">8.2 NOC-IO Switch Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-io-001-local-resource-routing">TC_SWITCH_NOC_IO_001: Local Resource Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-io-002-external-noc-routing">TC_SWITCH_NOC_IO_002: External NOC Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-io-003-high-address-routing-axaddr-51-48">TC_SWITCH_NOC_IO_003: High Address Routing (AxADDR[51:48])</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-io-004-timeout-detection">TC_SWITCH_NOC_IO_004: Timeout Detection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#smn-io-switch-test-cases">8.3 SMN-IO Switch Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-smn-io-001-address-based-routing">TC_SWITCH_SMN_IO_001: Address-Based Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-smn-io-002-serdes-routing">TC_SWITCH_SMN_IO_002: SerDes Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-smn-io-003-external-smn-routing">TC_SWITCH_SMN_IO_003: External SMN Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-smn-io-004-timeout-detection">TC_SWITCH_SMN_IO_004: Timeout Detection</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#sii-block-test-cases">9. SII Block Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#id1">9.1 Register Access Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-sii-001-configuration-register-access">TC_SII_001: Configuration Register Access</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-sii-002-cii-tracking">TC_SII_002: CII Tracking</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-sii-003-bus-device-number-assignment">TC_SII_003: Bus/Device Number Assignment</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#config-register-block-test-cases">10. Config Register Block Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#id2">10.1 Register Access Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-config-reg-001-tlb-configuration-space-access">TC_CONFIG_REG_001: TLB Configuration Space Access</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-config-reg-002-system-ready-register">TC_CONFIG_REG_002: System Ready Register</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-config-reg-003-pcie-enable-registers">TC_CONFIG_REG_003: PCIE Enable Registers</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-config-reg-004-isolation-behavior">TC_CONFIG_REG_004: Isolation Behavior</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#clock-reset-test-cases">11. Clock &amp; Reset Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#clock-generation-tests">11.1 Clock Generation Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-clock-reset-001-reference-clock-generation">TC_CLOCK_RESET_001: Reference Clock Generation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-clock-reset-002-pcie-clock-generation">TC_CLOCK_RESET_002: PCIE Clock Generation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#reset-sequence-tests">11.2 Reset Sequence Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-clock-reset-003-cold-reset-sequence">TC_CLOCK_RESET_003: Cold Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-clock-reset-004-warm-reset-sequence">TC_CLOCK_RESET_004: Warm Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-clock-reset-005-isolation-behavior">TC_CLOCK_RESET_005: Isolation Behavior</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#pll-cgm-test-cases">12. PLL/CGM Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#pll-lock-tests">12.1 PLL Lock Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-pll-cgm-001-pll-lock-sequence">TC_PLL_CGM_001: PLL Lock Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-pll-cgm-002-pll-configuration">TC_PLL_CGM_002: PLL Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#pcie-phy-test-cases">13. PCIE PHY Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#phy-configuration-tests">13.1 PHY Configuration Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-phy-001-apb-configuration-access">TC_PHY_001: APB Configuration Access</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-phy-002-ahb-firmware-download">TC_PHY_002: AHB Firmware Download</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-phy-003-lane-reversal-support">TC_PHY_003: Lane Reversal Support</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#external-interface-test-cases">14. External Interface Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#noc-n-interface-tests">14.1 NOC-N Interface Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-external-noc-001-transaction-forwarding">TC_EXTERNAL_NOC_001: Transaction Forwarding</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#smn-n-interface-tests">14.2 SMN-N Interface Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-external-smn-001-transaction-forwarding">TC_EXTERNAL_SMN_001: Transaction Forwarding</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#top-level-integration-test-cases">15. Top-Level Integration Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#full-tile-integration">15.1 Full Tile Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-top-level-001-complete-reset-sequence">TC_TOP_LEVEL_001: Complete Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-top-level-002-end-to-end-transaction-flow">TC_TOP_LEVEL_002: End-to-End Transaction Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-top-level-003-msi-end-to-end-flow">TC_TOP_LEVEL_003: MSI End-to-End Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-top-level-004-isolation-sequence">TC_TOP_LEVEL_004: Isolation Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-top-level-005-multiple-clock-domain-operation">TC_TOP_LEVEL_005: Multiple Clock Domain Operation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#end-to-end-test-cases">16. End-to-End Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#inbound-data-paths-pcie-noc-smn">16.1 Inbound Data Paths (PCIe → NOC/SMN)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-inbound-001-pcie-read-tlb-app0-noc-n">TC_E2E_INBOUND_001: PCIe Read → TLB App0 → NOC-N</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-inbound-002-pcie-write-tlb-app1-noc-n">TC_E2E_INBOUND_002: PCIe Write → TLB App1 → NOC-N</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-inbound-003-pcie-tlb-sys-smn-n">TC_E2E_INBOUND_003: PCIe → TLB Sys → SMN-N</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-inbound-004-pcie-bypass-app-path">TC_E2E_INBOUND_004: PCIe Bypass App Path</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-inbound-005-pcie-bypass-sys-path">TC_E2E_INBOUND_005: PCIe Bypass Sys Path</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#outbound-data-paths-noc-smn-pcie">16.2 Outbound Data Paths (NOC/SMN → PCIe)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-outbound-001-noc-n-tlb-app-out0-pcie">TC_E2E_OUTBOUND_001: NOC-N → TLB App Out0 → PCIe</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-outbound-002-smn-n-tlb-sys-out0-pcie">TC_E2E_OUTBOUND_002: SMN-N → TLB Sys Out0 → PCIe</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-outbound-003-noc-n-tlb-app-out1-pcie-dbi">TC_E2E_OUTBOUND_003: NOC-N → TLB App Out1 → PCIe DBI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#configuration-paths-smn-tlb-sii-msi-config">16.3 Configuration Paths (SMN → TLB/SII/MSI Config)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-config-001-smn-n-tlb-config">TC_E2E_CONFIG_001: SMN-N → TLB Config</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-config-002-smn-n-sii-config">TC_E2E_CONFIG_002: SMN-N → SII Config</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-config-003-smn-n-msi-relay-config">TC_E2E_CONFIG_003: SMN-N → MSI Relay Config</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#msi-interrupt-flows">16.4 MSI Interrupt Flows</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-msi-001-msi-generation-noc-n">TC_E2E_MSI_001: MSI Generation → NOC-N</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-msi-002-downstream-msi-input-processing">TC_E2E_MSI_002: Downstream MSI Input → Processing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#status-register-access">16.5 Status Register Access</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-status-001-status-register-read-route-0xe">TC_E2E_STATUS_001: Status Register Read (Route 0xE)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-status-002-status-register-disabled-access">TC_E2E_STATUS_002: Status Register Disabled Access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#isolation-and-error-handling">16.6 Isolation and Error Handling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-isolation-001-global-isolation">TC_E2E_ISOLATION_001: Global Isolation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-isolation-002-config-access-during-isolation">TC_E2E_ISOLATION_002: Config Access During Isolation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#multi-path-concurrent-traffic">16.7 Multi-Path Concurrent Traffic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-concurrent-001-simultaneous-inbound-outbound">TC_E2E_CONCURRENT_001: Simultaneous Inbound + Outbound</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-concurrent-002-multiple-tlb-simultaneous-access">TC_E2E_CONCURRENT_002: Multiple TLB Simultaneous Access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#reset-and-initialization-sequences">16.8 Reset and Initialization Sequences</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-reset-001-cold-reset-sequence">TC_E2E_RESET_001: Cold Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-reset-002-warm-reset-sequence">TC_E2E_RESET_002: Warm Reset Sequence</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#complete-transaction-flows">16.9 Complete Transaction Flows</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-flow-001-pcie-memory-read-noc-memory-response">TC_E2E_FLOW_001: PCIe Memory Read → NOC → Memory → Response</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-flow-002-pcie-memory-write-noc-memory-completion">TC_E2E_FLOW_002: PCIe Memory Write → NOC → Memory → Completion</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-flow-003-noc-memory-read-pcie-controller">TC_E2E_FLOW_003: NOC Memory Read → PCIe Controller</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-flow-004-smn-config-write-pcie-dbi">TC_E2E_FLOW_004: SMN Config Write → PCIe DBI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#error-injection-and-recovery">16.10 Error Injection and Recovery</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-error-001-invalid-tlb-entry">TC_E2E_ERROR_001: Invalid TLB Entry</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-error-002-timeout-handling">TC_E2E_ERROR_002: Timeout Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-error-003-address-decode-error">TC_E2E_ERROR_003: Address Decode Error</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#msi-x-end-to-end-flow">16.11 MSI-X End-to-End Flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-msix-001-complete-msi-x-interrupt-flow">TC_E2E_MSIX_001: Complete MSI-X Interrupt Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-msix-002-multiple-vector-interrupts">TC_E2E_MSIX_002: Multiple Vector Interrupts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#clock-domain-crossing">16.12 Clock Domain Crossing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-cdc-001-axi-clock-pcie-clock">TC_E2E_CDC_001: AXI Clock → PCIe Clock</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#performance-and-stress-tests">16.13 Performance and Stress Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-perf-001-maximum-throughput-test">TC_E2E_PERF_001: Maximum Throughput Test</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-stress-001-address-space-sweep">TC_E2E_STRESS_001: Address Space Sweep</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-stress-002-tlb-entry-exhaustion">TC_E2E_STRESS_002: TLB Entry Exhaustion</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#power-management">16.14 Power Management</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-power-001-isolation-mode-entry-exit">TC_E2E_POWER_001: Isolation Mode Entry/Exit</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#system-integration-scenarios">16.15 System Integration Scenarios</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-system-001-boot-sequence">TC_E2E_SYSTEM_001: Boot Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-system-002-shutdown-sequence">TC_E2E_SYSTEM_002: Shutdown Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-system-003-error-recovery-scenario">TC_E2E_SYSTEM_003: Error Recovery Scenario</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#refactored-architecture-validation">16.16 Refactored Architecture Validation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-refactor-001-function-callback-chain">TC_E2E_REFACTOR_001: Function Callback Chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-refactor-002-no-internal-sockets-remain">TC_E2E_REFACTOR_002: No Internal Sockets Remain</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#coverage-goals">17. Coverage Goals</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#id3">16. Coverage Goals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#functional-coverage">16.1 Functional Coverage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlb-coverage">TLB Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#msi-relay-coverage">MSI Relay Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#switch-coverage">Switch Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#sii-coverage">SII Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#config-register-coverage">Config Register Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#clock-reset-coverage">Clock/Reset Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#phy-coverage">PHY Coverage</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#code-coverage">16.2 Code Coverage</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#specification-coverage">16.3 Specification Coverage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-infrastructure">17. Test Infrastructure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#testbench-components">9.1 Testbench Components</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#stimulus-generator">Stimulus Generator</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#monitor">Monitor</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#reference-model">Reference Model</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-utilities">9.2 Test Utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-configuration">9.3 Test Configuration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#regression-testing">18. Regression Testing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#regression-suite">10.1 Regression Suite</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#regression-criteria">10.2 Regression Criteria</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#continuous-integration">10.3 Continuous Integration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#appendix-a-unit-integration-test-case-summary-sections-4-15">Appendix A: Unit/Integration Test Case Summary (Sections 4-15)</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#appendix-a-2-end-to-end-test-case-summary-section-16-implemented-in-keranous-pcie-tiletest-cc">Appendix A.2: End-to-End Test Case Summary (Section 16) — Implemented in <code class="docutils literal notranslate"><span class="pre">Keranous_pcie_tileTest.cc</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#appendix-b-test-execution-plan">Appendix B: Test Execution Plan</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#phase-1-unit-tests-weeks-1-3">Phase 1: Unit Tests (Weeks 1-3)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#phase-2-functional-tests-weeks-4-5">Phase 2: Functional Tests (Weeks 4-5)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#phase-3-integration-tests-weeks-6-7">Phase 3: Integration Tests (Weeks 6-7)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#phase-4-system-tests-week-8">Phase 4: System Tests (Week 8)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#phase-5-regression-week-9">Phase 5: Regression (Week 9)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ENABLE_GATING_DESIGN.html">Enable Gating Feature - Design Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#register-interface">Register Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#implementation">Implementation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#signal-propagation">Signal Propagation</a></li>
<li class="toctree-l3"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#key-features">Key Features</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#test-coverage">Test Coverage</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Keraunos PCIe Tile</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Synopsys Simulation Probes (SimProbe) Usage Guide</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Synopsys_SimProbe_Usage_Guide.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="synopsys-simulation-probes-simprobe-usage-guide">
<h1>Synopsys Simulation Probes (SimProbe) Usage Guide<a class="headerlink" href="#synopsys-simulation-probes-simprobe-usage-guide" title="Permalink to this heading"></a></h1>
<section id="backdoor-memory-access-and-other-use-cases">
<h2>Backdoor Memory Access and Other Use Cases<a class="headerlink" href="#backdoor-memory-access-and-other-use-cases" title="Permalink to this heading"></a></h2>
<p><strong>Reference:</strong> VP Simulation Probes Python Interface Reference Manual, Version V-2024.03<br />
<strong>Tool:</strong> Synopsys Virtualizer / Platform Architect<br />
<strong>Python Version:</strong> 3.10.4</p>
</section>
<hr class="docutils" />
<section id="table-of-contents">
<h2>Table of Contents<a class="headerlink" href="#table-of-contents" title="Permalink to this heading"></a></h2>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#overview"><span class="std std-doc">Overview</span></a></p></li>
<li><p><a class="reference internal" href="#architecture-and-setup"><span class="std std-doc">Architecture and Setup</span></a></p></li>
<li><p><span class="xref myst">Backdoor Memory Loading – Primary Use Case</span></p>
<ul class="simple">
<li><p>3.1 <a class="reference internal" href="#using-coreprobe-for-backdoor-memory-access"><span class="std std-doc">Using CoreProbe for Backdoor Memory Access</span></a></p></li>
<li><p>3.2 <a class="reference internal" href="#using-coreprobe-load-image-for-image-loading"><span class="std std-doc">Using CoreProbe.load_image() for Image Loading</span></a></p></li>
<li><p>3.3 <a class="reference internal" href="#using-memoryprobe-for-direct-memory-read-write"><span class="std std-doc">Using MemoryProbe for Direct Memory Read/Write</span></a></p></li>
<li><p>3.4 <a class="reference internal" href="#using-initiatorsocketprobe-for-debug-transactions"><span class="std std-doc">Using InitiatorSocketProbe for Debug Transactions</span></a></p></li>
<li><p>3.5 <span class="xref myst">Using BasicInitiatorSocketProbe (Utility Wrapper)</span></p></li>
<li><p>3.6 <a class="reference internal" href="#using-ihexreader-for-intel-hex-file-loading"><span class="std std-doc">Using IHexReader for Intel HEX File Loading</span></a></p></li>
<li><p>3.7 <a class="reference internal" href="#using-splinearmemory-for-linear-memory-access"><span class="std std-doc">Using SpLinearMemory for Linear Memory Access</span></a></p></li>
<li><p>3.8 <a class="reference internal" href="#integrating-simprobe-scripts-with-vp-config"><span class="std std-doc">Integrating SimProbe Scripts with VP Config</span></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#other-simprobe-use-cases"><span class="std std-doc">Other SimProbe Use Cases</span></a></p>
<ul class="simple">
<li><p>4.1 <a class="reference internal" href="#signal-probing-and-fault-injection"><span class="std std-doc">Signal Probing and Fault Injection</span></a></p></li>
<li><p>4.2 <a class="reference internal" href="#clock-manipulation"><span class="std std-doc">Clock Manipulation</span></a></p></li>
<li><p>4.3 <a class="reference internal" href="#processor-core-introspection"><span class="std std-doc">Processor Core Introspection</span></a></p></li>
<li><p>4.4 <a class="reference internal" href="#tlm2-transaction-observation-and-manipulation"><span class="std std-doc">TLM2 Transaction Observation and Manipulation</span></a></p></li>
<li><p>4.5 <a class="reference internal" href="#memory-content-observation"><span class="std std-doc">Memory Content Observation</span></a></p></li>
<li><p>4.6 <a class="reference internal" href="#software-function-tracing"><span class="std std-doc">Software Function Tracing</span></a></p></li>
<li><p>4.7 <a class="reference internal" href="#register-probing"><span class="std std-doc">Register Probing</span></a></p></li>
<li><p>4.8 <a class="reference internal" href="#gda-trace-creation-data-analysis"><span class="std std-doc">GDA Trace Creation (Data Analysis)</span></a></p></li>
<li><p>4.9 <a class="reference internal" href="#profiling"><span class="std std-doc">Profiling</span></a></p></li>
<li><p>4.10 <a class="reference internal" href="#simulation-control"><span class="std std-doc">Simulation Control</span></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#complete-backdoor-memory-loading-examples"><span class="std std-doc">Complete Backdoor Memory Loading Examples</span></a></p></li>
<li><p><a class="reference internal" href="#summary-of-key-apis-for-backdoor-access"><span class="std std-doc">Summary of Key APIs for Backdoor Access</span></a></p></li>
</ol>
</section>
<hr class="docutils" />
<section id="overview">
<h2>1. Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>Synopsys <strong>Simulation Probes</strong> (commonly referred to as <strong>SimProbe</strong>) is a Python-based instrumentation framework for Synopsys Virtual Prototypes (VPs). It provides a rich API allowing users to interact with, observe, and manipulate simulation models at runtime without modifying the model source code.</p>
<p>The framework is structured into three layers:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Layer</p></th>
<th class="head"><p>Module</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Setup Interface</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim_setup</span></code></p></td>
<td><p>Configure probes at startup (before simulation begins)</p></td>
</tr>
<tr class="row-odd"><td><p>Core Interface</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim</span></code></p></td>
<td><p>Runtime probing, observation, and manipulation</p></td>
</tr>
<tr class="row-even"><td><p>Utilities</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim_utils</span></code></p></td>
<td><p>Higher-level convenience wrappers and helper classes</p></td>
</tr>
</tbody>
</table>
<p><strong>Key capability:</strong> SimProbe enables <strong>backdoor access</strong> to memory – the ability to read/write memory contents directly (via debug transactions) without going through the normal bus protocol pipeline. This is critical for:</p>
<ul class="simple">
<li><p>Pre-loading firmware/software images before simulation starts</p></li>
<li><p>Initializing memory with test data</p></li>
<li><p>Runtime memory inspection without disturbing simulation timing</p></li>
<li><p>Fault injection by modifying memory contents on-the-fly</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="architecture-and-setup">
<h2>2. Architecture and Setup<a class="headerlink" href="#architecture-and-setup" title="Permalink to this heading"></a></h2>
<section id="script-types">
<h3>2.1 Script Types<a class="headerlink" href="#script-types" title="Permalink to this heading"></a></h3>
<p>SimProbe scripts operate in two contexts:</p>
<ol class="arabic simple">
<li><p><strong>Simulation Startup Script</strong> – Runs during elaboration, uses <code class="docutils literal notranslate"><span class="pre">sim_setup</span></code> module</p></li>
<li><p><strong>SystemC Thread Script</strong> – Runs during simulation as a SystemC thread, uses <code class="docutils literal notranslate"><span class="pre">sim</span></code> and <code class="docutils literal notranslate"><span class="pre">sim_utils</span></code> modules</p></li>
</ol>
</section>
<section id="creating-a-systemc-thread-script">
<h3>2.2 Creating a SystemC Thread Script<a class="headerlink" href="#creating-a-systemc-thread-script" title="Permalink to this heading"></a></h3>
<p>In the <strong>Simulation Startup Script</strong> (<code class="docutils literal notranslate"><span class="pre">sim_setup</span></code>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim_setup</span>

<span class="c1"># Create a standalone SystemC thread script that runs at simulation begin</span>
<span class="n">sim_setup</span><span class="o">.</span><span class="n">create_standalone_sc_thread</span><span class="p">(</span>
    <span class="s1">&#39;path/to/my_script.py&#39;</span><span class="p">,</span>          <span class="c1"># Path to script (relative to simulation executable)</span>
    <span class="p">[</span><span class="s1">&#39;arg1&#39;</span><span class="p">,</span> <span class="s1">&#39;arg2&#39;</span><span class="p">],</span>                 <span class="c1"># Optional arguments (accessible via sys.argv)</span>
    <span class="s1">&#39;my_thread_name&#39;</span>                  <span class="c1"># Optional thread name</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="simulation-lifecycle-callbacks">
<h3>2.3 Simulation Lifecycle Callbacks<a class="headerlink" href="#simulation-lifecycle-callbacks" title="Permalink to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim_setup</span>

<span class="k">def</span> <span class="nf">on_sim_begin</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Simulation has started -- memories are now accessible&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">on_sim_end</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Simulation ending -- dump final state&quot;</span><span class="p">)</span>

<span class="n">sim_setup</span><span class="o">.</span><span class="n">add_begin_of_simulation_callback</span><span class="p">(</span><span class="n">on_sim_begin</span><span class="p">)</span>
<span class="n">sim_setup</span><span class="o">.</span><span class="n">add_end_of_simulation_callback</span><span class="p">(</span><span class="n">on_sim_end</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="backdoor-memory-loading-primary-use-case">
<h2>3. Backdoor Memory Loading – Primary Use Case<a class="headerlink" href="#backdoor-memory-loading-primary-use-case" title="Permalink to this heading"></a></h2>
<p>Backdoor memory access allows reading and writing memory contents via <strong>debug transactions</strong> that bypass the normal TLM2 transport pipeline. This means:</p>
<ul class="simple">
<li><p><strong>No simulation time is consumed</strong> (zero-delay access)</p></li>
<li><p><strong>No side effects</strong> on bus arbitration, caches, or peripheral behavior</p></li>
<li><p><strong>Ideal for initialization</strong>, firmware loading, and runtime inspection</p></li>
</ul>
<p>There are several mechanisms to achieve backdoor memory loading in SimProbe:</p>
<hr class="docutils" />
<section id="using-coreprobe-for-backdoor-memory-access">
<h3>3.1 Using CoreProbe for Backdoor Memory Access<a class="headerlink" href="#using-coreprobe-for-backdoor-memory-access" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">CoreProbe</span></code> class provides direct access to a processor core’s memory space. This is the most common method for loading data into memory associated with a CPU core.</p>
<section id="constructor">
<h4>3.1.1 Constructor<a class="headerlink" href="#constructor" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="c1"># Attach to a processor core by its hierarchical name</span>
<span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="writing-data-to-core-memory-backdoor">
<h4>3.1.2 Writing Data to Core Memory (Backdoor)<a class="headerlink" href="#writing-data-to-core-memory-backdoor" title="Permalink to this heading"></a></h4>
<p><strong><code class="docutils literal notranslate"><span class="pre">set_memory_value()</span></code></strong> performs a debug write access (backdoor) to the core’s memory.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">)</span>

<span class="c1"># Write a 4-byte value to address 0x2000_0000</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">([</span><span class="mh">0xDE</span><span class="p">,</span> <span class="mh">0xAD</span><span class="p">,</span> <span class="mh">0xBE</span><span class="p">,</span> <span class="mh">0xEF</span><span class="p">])</span>
<span class="n">num_units</span> <span class="o">=</span> <span class="mi">4</span>           <span class="c1"># Number of MAUs (Minimum Addressable Units) to write</span>
<span class="n">bytes_written</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">set_memory_value</span><span class="p">(</span><span class="mh">0x20000000</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_units</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wrote </span><span class="si">{</span><span class="n">bytes_written</span><span class="si">}</span><span class="s2"> MAUs to memory&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">addr</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>Target memory address</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">buf</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bytearray</span></code></p></td>
<td><p>Data to write</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">num_units</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>Number of MAUs to write</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">unit_size</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code> (optional)</p></td>
<td><p>Chunk size for access (in MAUs)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">mem_space</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str</span></code> (optional)</p></td>
<td><p>Memory space name (use <code class="docutils literal notranslate"><span class="pre">get_memory_space_names()</span></code> to list)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="reading-data-from-core-memory-backdoor">
<h4>3.1.3 Reading Data from Core Memory (Backdoor)<a class="headerlink" href="#reading-data-from-core-memory-backdoor" title="Permalink to this heading"></a></h4>
<p><strong><code class="docutils literal notranslate"><span class="pre">get_memory_value()</span></code></strong> performs a debug read access (backdoor).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read 16 bytes from address 0x2000_0000</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_memory_value</span><span class="p">(</span><span class="mh">0x20000000</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Memory content: </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="software-data-view-memory-access">
<h4>3.1.4 Software Data View Memory Access<a class="headerlink" href="#software-data-view-memory-access" title="Permalink to this heading"></a></h4>
<p>For architectures with MMUs or memory translation, use the software data view methods:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read via software data view (uses virtual addresses)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_software_data_view_memory_value</span><span class="p">(</span><span class="mh">0x80000000</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="c1"># Write via software data view</span>
<span class="n">core</span><span class="o">.</span><span class="n">set_software_data_view_memory_value</span><span class="p">(</span><span class="mh">0x80000000</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">([</span><span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">]),</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="querying-available-memory-spaces">
<h4>3.1.5 Querying Available Memory Spaces<a class="headerlink" href="#querying-available-memory-spaces" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">spaces</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_memory_space_names</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Available memory spaces: </span><span class="si">{</span><span class="n">spaces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="c1"># e.g., [&#39;default&#39;, &#39;physical&#39;, &#39;virtual&#39;, &#39;secure&#39;, &#39;non-secure&#39;]</span>
</pre></div>
</div>
</section>
<section id="bulk-data-loading-example-binary-file-to-memory">
<h4>3.1.6 Bulk Data Loading Example (Binary File to Memory)<a class="headerlink" href="#bulk-data-loading-example-binary-file-to-memory" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="k">def</span> <span class="nf">load_binary_to_memory</span><span class="p">(</span><span class="n">core_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">base_address</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load a raw binary file into core memory via backdoor access.&quot;&quot;&quot;</span>
    <span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="n">core_name</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

    <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">4096</span>  <span class="c1"># Write in 4KB chunks for efficiency</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">]</span>
        <span class="n">num_units</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">core</span><span class="o">.</span><span class="n">set_memory_value</span><span class="p">(</span><span class="n">base_address</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">num_units</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="n">chunk_size</span>

    <span class="n">sim</span><span class="o">.</span><span class="n">print_message</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> bytes from </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2"> to 0x</span><span class="si">{</span><span class="n">base_address</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Usage</span>
<span class="n">load_binary_to_memory</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">,</span> <span class="s1">&#39;firmware.bin&#39;</span><span class="p">,</span> <span class="mh">0x20000000</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="using-coreprobe-load-image-for-image-loading">
<h3>3.2 Using CoreProbe.load_image() for Image Loading<a class="headerlink" href="#using-coreprobe-load-image-for-image-loading" title="Permalink to this heading"></a></h3>
<p>The <strong><code class="docutils literal notranslate"><span class="pre">load_image()</span></code></strong> method is a high-level API that loads complete software images (ELF, Intel HEX, S-Record, etc.) into the core’s memory. This is typically the primary mechanism for firmware loading.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">)</span>

<span class="c1"># Load an ELF image with symbol/debug info</span>
<span class="n">success</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">load_image</span><span class="p">(</span>
    <span class="s1">&#39;firmware/application.elf&#39;</span><span class="p">,</span>   <span class="c1"># Path relative to simulation executable</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>                      <span class="c1"># Address offset (added to all symbol addresses)</span>
    <span class="n">debug_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>               <span class="c1"># Load symbol information</span>
    <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;elf&#39;</span>                   <span class="c1"># File format (auto-detected if omitted)</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">success</span><span class="p">:</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">print_message</span><span class="p">(</span><span class="s2">&quot;Image loaded successfully&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Supported formats</strong> (auto-detected by file extension/header):</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Format</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ELF</p></td>
<td><p>Executable and Linkable Format</p></td>
</tr>
<tr class="row-odd"><td><p>Intel HEX</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.hex</span></code> / <code class="docutils literal notranslate"><span class="pre">.ihex</span></code> files</p></td>
</tr>
<tr class="row-even"><td><p>S-Record</p></td>
<td><p>Motorola S-Record (<code class="docutils literal notranslate"><span class="pre">.srec</span></code>)</p></td>
</tr>
<tr class="row-odd"><td><p>Binary</p></td>
<td><p>Raw binary</p></td>
</tr>
</tbody>
</table>
<p><strong>Parameters:</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">path</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p></td>
<td><p>(required)</p></td>
<td><p>Path to the image file</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">offset</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0</span></code></p></td>
<td><p>Address offset for all symbols</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">debug_info</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p></td>
<td><p>Whether to load symbol/debug info</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">format</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p></td>
<td><p>(auto)</p></td>
<td><p>Image file format</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><strong>Note:</strong> Loading a software image involves reading a large file. Consider performance implications when calling this at runtime.</p>
</div></blockquote>
</section>
<hr class="docutils" />
<section id="using-memoryprobe-for-direct-memory-read-write">
<h3>3.3 Using MemoryProbe for Direct Memory Read/Write<a class="headerlink" href="#using-memoryprobe-for-direct-memory-read-write" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">MemoryProbe</span></code> class provides direct backdoor access to <strong>SCML2 memory objects</strong> (or objects implementing the <code class="docutils literal notranslate"><span class="pre">MemoryVisibilityAPI</span></code> IPT) by their SystemC hierarchical name.</p>
<section id="id1">
<h4>3.3.1 Constructor<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="c1"># Create a MemoryProbe for a 4-byte region of a memory object</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">MemoryProbe</span><span class="p">(</span>
    <span class="s1">&#39;top.memory_subsystem.sram&#39;</span><span class="p">,</span>  <span class="c1"># Hierarchical name of the SCML2 memory</span>
    <span class="n">size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>                        <span class="c1"># Size in bytes: 1, 2, 4, or 8</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">0</span>                       <span class="c1"># Byte offset from start of memory</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="backdoor-read-debug-read">
<h4>3.3.2 Backdoor Read (Debug Read)<a class="headerlink" href="#backdoor-read-debug-read" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read value -- no behavior side effects (debug read)</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Memory value: 0x</span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Read as signed integer</span>
<span class="n">signed_value</span> <span class="o">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">as_signed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="backdoor-write-debug-write">
<h4>3.3.3 Backdoor Write (Debug Write)<a class="headerlink" href="#backdoor-write-debug-write" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Write value -- no behavior side effects (debug write)</span>
<span class="n">mem</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="mh">0xDEADBEEF</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="clamping-memory-values">
<h4>3.3.4 Clamping Memory Values<a class="headerlink" href="#clamping-memory-values" title="Permalink to this heading"></a></h4>
<p>Clamping forces a memory location to return a fixed value on all reads, while backing up actual writes. This is useful for fault injection.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Clamp all bits to current value</span>
<span class="n">mem</span><span class="o">.</span><span class="n">set_clamp</span><span class="p">()</span>

<span class="c1"># Clamp with a specific value</span>
<span class="n">mem</span><span class="o">.</span><span class="n">set_clamp_with_value</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">)</span>

<span class="c1"># Clamp with a specific value and mask (only clamp bits set to 1 in mask)</span>
<span class="n">mem</span><span class="o">.</span><span class="n">set_clamp_with_value</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="mh">0xFF00FF00</span><span class="p">)</span>

<span class="c1"># Release the clamp -- memory returns to last written value</span>
<span class="n">mem</span><span class="o">.</span><span class="n">release_clamp</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="triggering-read-write-behavior">
<h4>3.3.5 Triggering Read/Write Behavior<a class="headerlink" href="#triggering-read-write-behavior" title="Permalink to this heading"></a></h4>
<p>Unlike pure debug access, these methods invoke the memory’s registered SCML2 callbacks:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Trigger read behavior (invokes SCML2 read callback)</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">call_read_behavior</span><span class="p">()</span>

<span class="c1"># Trigger write behavior with a specific value</span>
<span class="n">mem</span><span class="o">.</span><span class="n">call_write_behavior_with_value</span><span class="p">(</span><span class="mh">0xCAFEBABE</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="iterating-over-a-memory-region">
<h4>3.3.6 Iterating Over a Memory Region<a class="headerlink" href="#iterating-over-a-memory-region" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="k">def</span> <span class="nf">dump_memory_region</span><span class="p">(</span><span class="n">mem_name</span><span class="p">,</span> <span class="n">start_offset</span><span class="p">,</span> <span class="n">num_words</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dump a region of memory word-by-word via backdoor access.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_words</span><span class="p">):</span>
        <span class="n">probe</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">MemoryProbe</span><span class="p">(</span><span class="n">mem_name</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">start_offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">probe</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  [0x</span><span class="si">{</span><span class="n">start_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">] = 0x</span><span class="si">{</span><span class="n">val</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">dump_memory_region</span><span class="p">(</span><span class="s1">&#39;top.sram&#39;</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="using-initiatorsocketprobe-for-debug-transactions">
<h3>3.4 Using InitiatorSocketProbe for Debug Transactions<a class="headerlink" href="#using-initiatorsocketprobe-for-debug-transactions" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">InitiatorSocketProbe</span></code> attaches to a TLM2/AMBA-PV initiator socket and allows performing both debug and non-debug bus transactions. This is useful when you need to access memory through the actual bus interconnect (e.g., to target address-decoded peripherals).</p>
<section id="debug-write-backdoor-via-bus">
<h4>3.4.1 Debug Write (Backdoor via Bus)<a class="headerlink" href="#debug-write-backdoor-via-bus" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="c1"># Attach to an initiator socket</span>
<span class="n">isock</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">InitiatorSocketProbe</span><span class="p">(</span><span class="s1">&#39;top.bus_master.initiator_socket&#39;</span><span class="p">)</span>

<span class="c1"># Perform a debug write (backdoor, no timing)</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">([</span><span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">])</span>
<span class="n">bytes_written</span> <span class="o">=</span> <span class="n">isock</span><span class="o">.</span><span class="n">debug_write</span><span class="p">(</span>
    <span class="n">addr</span><span class="o">=</span><span class="mh">0x40000000</span><span class="p">,</span>   <span class="c1"># Target address</span>
    <span class="n">data_len</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>         <span class="c1"># Number of bytes</span>
    <span class="n">buf</span><span class="o">=</span><span class="n">data</span>            <span class="c1"># Data buffer</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="debug-read-backdoor-via-bus">
<h4>3.4.2 Debug Read (Backdoor via Bus)<a class="headerlink" href="#debug-read-backdoor-via-bus" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Perform a debug read (backdoor, no timing)</span>
<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">bytes_read</span> <span class="o">=</span> <span class="n">isock</span><span class="o">.</span><span class="n">debug_read</span><span class="p">(</span>
    <span class="n">addr</span><span class="o">=</span><span class="mh">0x40000000</span><span class="p">,</span>
    <span class="n">data_len</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">buf</span><span class="o">=</span><span class="n">buf</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read data: </span><span class="si">{</span><span class="n">buf</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="non-debug-timed-transactions">
<h4>3.4.3 Non-Debug (Timed) Transactions<a class="headerlink" href="#non-debug-timed-transactions" title="Permalink to this heading"></a></h4>
<p>These consume simulation time and go through the full transport pipeline:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Timed write transaction (blocks the SystemC thread)</span>
<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">([</span><span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xBB</span><span class="p">,</span> <span class="mh">0xCC</span><span class="p">,</span> <span class="mh">0xDD</span><span class="p">])</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">isock</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
    <span class="n">time</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;ns&#39;</span><span class="p">),</span>       <span class="c1"># Timing annotation</span>
    <span class="n">addr</span><span class="o">=</span><span class="mh">0x40000000</span><span class="p">,</span>
    <span class="n">data_len</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">buf</span><span class="o">=</span><span class="n">buf</span>
<span class="p">)</span>

<span class="c1"># Timed read transaction</span>
<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">isock</span><span class="o">.</span><span class="n">read</span><span class="p">(</span>
    <span class="n">time</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;ns&#39;</span><span class="p">),</span>
    <span class="n">addr</span><span class="o">=</span><span class="mh">0x40000000</span><span class="p">,</span>
    <span class="n">data_len</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">buf</span><span class="o">=</span><span class="n">buf</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="using-basicinitiatorsocketprobe-utility-wrapper">
<h3>3.5 Using BasicInitiatorSocketProbe (Utility Wrapper)<a class="headerlink" href="#using-basicinitiatorsocketprobe-utility-wrapper" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">BasicInitiatorSocketProbe</span></code> from <code class="docutils literal notranslate"><span class="pre">sim_utils</span></code> provides convenience methods that abstract away bytearray handling:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sim_utils</span> <span class="kn">import</span> <span class="n">BasicInitiatorSocketProbe</span>

<span class="n">probe</span> <span class="o">=</span> <span class="n">BasicInitiatorSocketProbe</span><span class="p">(</span><span class="s1">&#39;top.bus_master.initiator_socket&#39;</span><span class="p">)</span>

<span class="c1"># Fixed-size debug reads (return integers by default)</span>
<span class="n">val8</span>  <span class="o">=</span> <span class="n">probe</span><span class="o">.</span><span class="n">debug_read1</span><span class="p">(</span><span class="mh">0x40000000</span><span class="p">)</span>   <span class="c1"># Read 1 byte</span>
<span class="n">val16</span> <span class="o">=</span> <span class="n">probe</span><span class="o">.</span><span class="n">debug_read2</span><span class="p">(</span><span class="mh">0x40000000</span><span class="p">)</span>   <span class="c1"># Read 2 bytes</span>
<span class="n">val32</span> <span class="o">=</span> <span class="n">probe</span><span class="o">.</span><span class="n">debug_read4</span><span class="p">(</span><span class="mh">0x40000000</span><span class="p">)</span>   <span class="c1"># Read 4 bytes</span>
<span class="n">val64</span> <span class="o">=</span> <span class="n">probe</span><span class="o">.</span><span class="n">debug_read8</span><span class="p">(</span><span class="mh">0x40000000</span><span class="p">)</span>   <span class="c1"># Read 8 bytes</span>

<span class="c1"># Fixed-size debug writes</span>
<span class="n">probe</span><span class="o">.</span><span class="n">debug_write1</span><span class="p">(</span><span class="mh">0x40000000</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">)</span>            <span class="c1"># Write 1 byte</span>
<span class="n">probe</span><span class="o">.</span><span class="n">debug_write2</span><span class="p">(</span><span class="mh">0x40000000</span><span class="p">,</span> <span class="mh">0xBEEF</span><span class="p">)</span>          <span class="c1"># Write 2 bytes</span>
<span class="n">probe</span><span class="o">.</span><span class="n">debug_write4</span><span class="p">(</span><span class="mh">0x40000000</span><span class="p">,</span> <span class="mh">0xDEADBEEF</span><span class="p">)</span>      <span class="c1"># Write 4 bytes</span>
<span class="n">probe</span><span class="o">.</span><span class="n">debug_write8</span><span class="p">(</span><span class="mh">0x40000000</span><span class="p">,</span> <span class="mh">0xCAFEBABEDEADBEEF</span><span class="p">)</span>  <span class="c1"># Write 8 bytes</span>

<span class="c1"># Memory fill -- fill a region with a pattern</span>
<span class="n">probe</span><span class="o">.</span><span class="n">mem_fill</span><span class="p">(</span><span class="mh">0x20000000</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">([</span><span class="mh">0x00</span><span class="p">]))</span>   <span class="c1"># Zero-fill 4KB</span>

<span class="c1"># Memory copy -- copy data between addresses</span>
<span class="n">probe</span><span class="o">.</span><span class="n">mem_copy</span><span class="p">(</span><span class="n">src_addr</span><span class="o">=</span><span class="mh">0x20000000</span><span class="p">,</span> <span class="n">dst_addr</span><span class="o">=</span><span class="mh">0x30000000</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mh">0x1000</span><span class="p">)</span>

<span class="c1"># Read a null-terminated string from memory</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">probe</span><span class="o">.</span><span class="n">get_string</span><span class="p">(</span><span class="mh">0x20001000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;String at memory: </span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<section id="loading-a-binary-file-via-initiatorsocketprobe">
<h4>3.5.1 Loading a Binary File via InitiatorSocketProbe<a class="headerlink" href="#loading-a-binary-file-via-initiatorsocketprobe" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sim_utils</span> <span class="kn">import</span> <span class="n">BasicInitiatorSocketProbe</span>

<span class="k">def</span> <span class="nf">load_binary_via_bus</span><span class="p">(</span><span class="n">socket_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">base_address</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load a binary file into memory via debug transactions on the bus.&quot;&quot;&quot;</span>
    <span class="n">probe</span> <span class="o">=</span> <span class="n">BasicInitiatorSocketProbe</span><span class="p">(</span><span class="n">socket_name</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

    <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">256</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">]</span>
        <span class="n">probe</span><span class="o">.</span><span class="n">debug_write</span><span class="p">(</span><span class="n">base_address</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span> <span class="n">chunk</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="n">chunk_size</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> bytes to 0x</span><span class="si">{</span><span class="n">base_address</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2"> via </span><span class="si">{</span><span class="n">socket_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Usage</span>
<span class="n">load_binary_via_bus</span><span class="p">(</span><span class="s1">&#39;top.bus.init_socket&#39;</span><span class="p">,</span> <span class="s1">&#39;test_data.bin&#39;</span><span class="p">,</span> <span class="mh">0x80000000</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="using-ihexreader-for-intel-hex-file-loading">
<h3>3.6 Using IHexReader for Intel HEX File Loading<a class="headerlink" href="#using-ihexreader-for-intel-hex-file-loading" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">sim_utils</span></code> library includes <code class="docutils literal notranslate"><span class="pre">IHexReader</span></code> for parsing and loading Intel HEX format files:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sim_utils</span> <span class="kn">import</span> <span class="n">IHexReader</span>

<span class="c1"># Create an IHexReader for a .hex file</span>
<span class="n">reader</span> <span class="o">=</span> <span class="n">IHexReader</span><span class="p">(</span><span class="s1">&#39;firmware.hex&#39;</span><span class="p">)</span>

<span class="c1"># Read the records from the file</span>
<span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c1"># The reader provides parsed data records that can be</span>
<span class="c1"># iterated and written to memory via any of the above probes</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="using-splinearmemory-for-linear-memory-access">
<h3>3.7 Using SpLinearMemory for Linear Memory Access<a class="headerlink" href="#using-splinearmemory-for-linear-memory-access" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">SpLinearMemory</span></code> provides a linear memory abstraction that can be used as a staging buffer:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sim_utils</span> <span class="kn">import</span> <span class="n">SpLinearMemory</span>

<span class="c1"># Create a linear memory of 4KB</span>
<span class="n">linear_mem</span> <span class="o">=</span> <span class="n">SpLinearMemory</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">4096</span><span class="p">)</span>

<span class="c1"># Write data into linear memory</span>
<span class="n">linear_mem</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nb">bytearray</span><span class="p">([</span><span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">]))</span>

<span class="c1"># Read data from linear memory</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">linear_mem</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="integrating-simprobe-scripts-with-vp-config">
<h3>3.8 Integrating SimProbe Scripts with VP Config<a class="headerlink" href="#integrating-simprobe-scripts-with-vp-config" title="Permalink to this heading"></a></h3>
<p>SimProbe scripts are <strong>invoked from the VP Config (vpconfig) initialization infrastructure</strong>. The VP Config editor provides multiple script entry points at which SimProbe functionality can be registered and executed. Understanding these entry points is essential for properly orchestrating backdoor memory loading and other SimProbe operations within the simulation lifecycle.</p>
<section id="vp-config-script-entry-points-overview">
<h4>3.8.1 VP Config Script Entry Points Overview<a class="headerlink" href="#vp-config-script-entry-points-overview" title="Permalink to this heading"></a></h4>
<p>The VP Config editor provides <strong>three distinct script entry points</strong>, each serving a different purpose in the simulation lifecycle:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Entry Point</p></th>
<th class="head"><p>Executed By</p></th>
<th class="head"><p>Timing</p></th>
<th class="head"><p>Available API</p></th>
<th class="head"><p>Typical Use</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Simulation Startup Scripts</strong></p></td>
<td><p>Simulation process</p></td>
<td><p>Before <code class="docutils literal notranslate"><span class="pre">sc_main()</span></code> (earliest)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim_setup</span></code> only</p></td>
<td><p>Register threads, callbacks, set up environment</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Simulation Script Callbacks</strong></p></td>
<td><p>Simulation interpreter</p></td>
<td><p>At lifecycle events (Begin/End of Sim, etc.)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim</span></code> (full API)</p></td>
<td><p>Memory initialization, state setup</p></td>
</tr>
<tr class="row-even"><td><p><strong>Standalone SystemC Thread Scripts</strong></p></td>
<td><p>Separate SystemC threads</p></td>
<td><p>After simulation begins</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim</span></code> and <code class="docutils literal notranslate"><span class="pre">sim_utils</span></code> (full API)</p></td>
<td><p>Runtime probing, monitoring, fault injection</p></td>
</tr>
</tbody>
</table>
<p>The following diagram illustrates the invocation flow:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>VP Config (vpconfig)
  |
  |-- Simulation Startup Script: startup.py        [uses sim_setup]
  |     |-- Creates threads via create_standalone_sc_thread()
  |     |-- Registers callbacks via add_begin_of_simulation_callback()
  |     &#39;-- Sets up environment variables and paths
  |
  |-- Simulation Script Callbacks:
  |     |-- Begin of Simulation scripts             [uses sim — full API]
  |     |-- End of Simulation scripts               [uses sim — full API]
  |     &#39;-- Advanced: about_to_suspend, checkpointing, restore
  |
  &#39;-- Standalone SystemC Thread Scripts table:
        |-- monitor_script.py                       [uses sim, sim_utils]
        |-- backdoor_loader.py                      [uses sim, sim_utils]
        &#39;-- fault_injector.py                       [uses sim, sim_utils]
</pre></div>
</div>
</section>
<section id="simulation-startup-scripts-via-sim-setup-module">
<h4>3.8.2 Simulation Startup Scripts (via <code class="docutils literal notranslate"><span class="pre">sim_setup</span></code> Module)<a class="headerlink" href="#simulation-startup-scripts-via-sim-setup-module" title="Permalink to this heading"></a></h4>
<p>The <strong>Simulation Startup Script</strong> is the earliest entry point. It is specified in the VP Config <strong>Overview tab</strong> under the “Simulation Startup Script” field (under the Details menu). It is executed by the simulation process <strong>before <code class="docutils literal notranslate"><span class="pre">sc_main()</span></code> is called</strong> and must complete before simulation creation can continue.</p>
<p>From this script, you import the <code class="docutils literal notranslate"><span class="pre">sim_setup</span></code> module and can:</p>
<ul class="simple">
<li><p>Create standalone SystemC thread scripts (which later use the full <code class="docutils literal notranslate"><span class="pre">sim</span></code> and <code class="docutils literal notranslate"><span class="pre">sim_utils</span></code> APIs)</p></li>
<li><p>Register lifecycle callbacks (begin-of-simulation, end-of-simulation, checkpointing, etc.)</p></li>
<li><p>Set up file system paths and environment variables</p></li>
<li><p>Initialize simulation-wide state</p></li>
</ul>
<p><strong>Example: Simulation Startup Script (<code class="docutils literal notranslate"><span class="pre">startup.py</span></code>) specified in VP Config:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim_setup</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Resolve script paths relative to this startup script&#39;s directory</span>
<span class="n">script_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>

<span class="c1"># Register a SimProbe thread script to run at simulation begin</span>
<span class="n">backdoor_script</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">script_dir</span><span class="p">,</span> <span class="s1">&#39;backdoor_loader.py&#39;</span><span class="p">)</span>
<span class="n">sim_setup</span><span class="o">.</span><span class="n">create_standalone_sc_thread</span><span class="p">(</span>
    <span class="n">backdoor_script</span><span class="p">,</span>
    <span class="p">[</span><span class="s1">&#39;firmware/app.elf&#39;</span><span class="p">,</span> <span class="s1">&#39;0x20000000&#39;</span><span class="p">],</span>   <span class="c1"># Arguments via sys.argv</span>
    <span class="s1">&#39;backdoor_loader&#39;</span>                      <span class="c1"># Thread name</span>
<span class="p">)</span>

<span class="c1"># Register a begin-of-simulation callback for quick initialization</span>
<span class="k">def</span> <span class="nf">on_begin_of_sim</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Simulation starting — all model hierarchy is now constructed&quot;</span><span class="p">)</span>

<span class="n">sim_setup</span><span class="o">.</span><span class="n">add_begin_of_simulation_callback</span><span class="p">(</span><span class="n">on_begin_of_sim</span><span class="p">)</span>

<span class="c1"># Register an end-of-simulation callback for cleanup</span>
<span class="k">def</span> <span class="nf">on_end_of_sim</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Simulation ending — dumping final state&quot;</span><span class="p">)</span>

<span class="n">sim_setup</span><span class="o">.</span><span class="n">add_end_of_simulation_callback</span><span class="p">(</span><span class="n">on_end_of_sim</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Key <code class="docutils literal notranslate"><span class="pre">sim_setup</span></code> methods available in the Startup Script:</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">create_standalone_sc_thread(path,</span> <span class="pre">[args],</span> <span class="pre">[name])</span></code></p></td>
<td><p>Register a Python script to run as a standalone SystemC thread</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">add_begin_of_simulation_callback(cb)</span></code></p></td>
<td><p>Register a callback invoked after SystemC elaboration</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">add_end_of_simulation_callback(cb)</span></code></p></td>
<td><p>Register a callback invoked at simulation shutdown</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">add_about_to_suspend_callback(cb)</span></code></p></td>
<td><p>Register a callback invoked before simulation suspends</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">add_begin_of_checkpointing_callback(cb)</span></code></p></td>
<td><p>Register a callback invoked before checkpointing</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">add_end_of_checkpointing_callback(cb)</span></code></p></td>
<td><p>Register a callback invoked after checkpointing</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">add_end_of_restore_callback(cb)</span></code></p></td>
<td><p>Register a callback invoked after restoring a checkpoint</p></td>
</tr>
</tbody>
</table>
</section>
<section id="simulation-script-callbacks-begin-end-of-simulation">
<h4>3.8.3 Simulation Script Callbacks (Begin/End of Simulation)<a class="headerlink" href="#simulation-script-callbacks-begin-end-of-simulation" title="Permalink to this heading"></a></h4>
<p>The VP Config editor provides dedicated <strong>tables</strong> where you can directly list Python scripts that will be executed at specific lifecycle points. These scripts run in the main simulation interpreter and have access to the full <code class="docutils literal notranslate"><span class="pre">sim</span></code> API.</p>
<p>The most commonly used callbacks are:</p>
<ul class="simple">
<li><p><strong>Begin of Simulation</strong> – invoked after the SystemC hierarchy is constructed and elaborated</p></li>
<li><p><strong>End of Simulation</strong> – invoked at simulation shutdown</p></li>
</ul>
<p>Additional callbacks are available under the <strong>Advanced</strong> section of the VP Config editor:</p>
<ul class="simple">
<li><p><strong>About to Suspend</strong> – invoked before simulation suspends</p></li>
<li><p><strong>Begin/End of Checkpointing</strong> – invoked around checkpoint operations</p></li>
<li><p><strong>End of Restore</strong> – invoked after restoring a checkpoint</p></li>
</ul>
<p><strong>Example: Begin-of-Simulation callback script for backdoor memory initialization (<code class="docutils literal notranslate"><span class="pre">init_memory.py</span></code>):</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="c1"># This script is listed in the VP Config &quot;Begin of Simulation&quot; callback table.</span>
<span class="c1"># At this point, the full SystemC hierarchy is elaborated and sim API is available.</span>

<span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">)</span>

<span class="c1"># Load firmware via backdoor</span>
<span class="n">success</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">load_image</span><span class="p">(</span><span class="s1">&#39;firmware/app.elf&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">debug_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;elf&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">success</span><span class="p">:</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">print_message</span><span class="p">(</span><span class="s2">&quot;Firmware loaded successfully at begin-of-simulation&quot;</span><span class="p">)</span>

<span class="c1"># Initialize a shared memory region with test data</span>
<span class="n">mem</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">MemoryProbe</span><span class="p">(</span><span class="s1">&#39;top.shared_sram&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">mem</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">)</span>  <span class="c1"># Clear first word</span>

<span class="n">sim</span><span class="o">.</span><span class="n">print_message</span><span class="p">(</span><span class="s2">&quot;Memory initialization complete&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="standalone-systemc-thread-scripts-in-vp-config">
<h4>3.8.4 Standalone SystemC Thread Scripts in VP Config<a class="headerlink" href="#standalone-systemc-thread-scripts-in-vp-config" title="Permalink to this heading"></a></h4>
<p>The VP Config editor includes a <strong>Standalone SystemC Threads</strong> table where you can directly list Python scripts to be executed as independent SystemC threads. Each script runs in its own Python sub-interpreter context and SystemC thread, with full access to <code class="docutils literal notranslate"><span class="pre">sim</span></code> and <code class="docutils literal notranslate"><span class="pre">sim_utils</span></code> libraries.</p>
<p>Scripts listed in this table are automatically created as SystemC thread scripts at simulation start – there is no need to explicitly call <code class="docutils literal notranslate"><span class="pre">sim_setup.create_standalone_sc_thread()</span></code> for them.</p>
<blockquote>
<div><p><strong>Note:</strong> Variables, methods, and imported libraries are local to each standalone SystemC thread script and cannot be accessed from other scripts. To share functionality between thread scripts, use the <code class="docutils literal notranslate"><span class="pre">ThreadInterface</span></code> class or inter-thread message passing via <code class="docutils literal notranslate"><span class="pre">sim.post_message()</span></code>.</p>
</div></blockquote>
</section>
<section id="specifying-scripts-from-the-command-line">
<h4>3.8.5 Specifying Scripts from the Command Line<a class="headerlink" href="#specifying-scripts-from-the-command-line" title="Permalink to this heading"></a></h4>
<p>When launching the simulation from a command line (without the Virtualizer Studio IDE), the Simulation Startup Script can be specified via the <code class="docutils literal notranslate"><span class="pre">--snps_startup_script</span></code> parameter:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Using vpsession</span>
vpsession<span class="w"> </span>sim<span class="w"> </span>-snps_startup_script<span class="w"> </span>startup.py

<span class="c1"># The script_path can be absolute or relative to the simulation directory</span>
vpsession<span class="w"> </span>sim<span class="w"> </span>-snps_startup_script<span class="w"> </span>/path/to/startup.py
</pre></div>
</div>
</section>
<section id="recommended-architecture-for-backdoor-memory-loading-via-vp-config">
<h4>3.8.6 Recommended Architecture for Backdoor Memory Loading via VP Config<a class="headerlink" href="#recommended-architecture-for-backdoor-memory-loading-via-vp-config" title="Permalink to this heading"></a></h4>
<p>The recommended architecture for using SimProbe to load data via backdoor access from VP Config is a <strong>layered approach</strong> that separates concerns across the different entry points:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>VP Config
  |
  |-- Simulation Startup Script: startup.py          [sim_setup]
  |     |-- Creates thread: backdoor_loader.py
  |     |-- Creates thread: monitor_script.py
  |     &#39;-- Registers callback: on_begin_of_sim()
  |
  |-- Begin of Simulation Callback Scripts:
  |     &#39;-- init_memory.py                            [sim — backdoor writes]
  |
  |-- End of Simulation Callback Scripts:
  |     &#39;-- dump_state.py                             [sim — state dump]
  |
  &#39;-- Standalone SystemC Thread Scripts:
        |-- backdoor_loader.py                        [sim, sim_utils — firmware load]
        &#39;-- monitor_script.py                         [sim, sim_utils — runtime monitoring]
</pre></div>
</div>
<p><strong>Separation of concerns:</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Layer</p></th>
<th class="head"><p>Responsibility</p></th>
<th class="head"><p>API</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Startup Script</p></td>
<td><p>Orchestration: register threads and callbacks</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim_setup</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Begin-of-Sim Callbacks</p></td>
<td><p>One-time initialization: load firmware, set initial register values</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim</span></code></p></td>
</tr>
<tr class="row-even"><td><p>SystemC Thread Scripts</p></td>
<td><p>Runtime operations: monitoring, fault injection, test stimuli</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim</span></code>, <code class="docutils literal notranslate"><span class="pre">sim_utils</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>End-of-Sim Callbacks</p></td>
<td><p>Cleanup: dump final state, close log files</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="key-constraint-sim-setup-vs-sim-module">
<h4>3.8.7 Key Constraint: <code class="docutils literal notranslate"><span class="pre">sim_setup</span></code> vs <code class="docutils literal notranslate"><span class="pre">sim</span></code> Module<a class="headerlink" href="#key-constraint-sim-setup-vs-sim-module" title="Permalink to this heading"></a></h4>
<p>A critical constraint to understand is that the <strong>Simulation Startup Script</strong> (which runs before <code class="docutils literal notranslate"><span class="pre">sc_main()</span></code>) can <strong>only</strong> use the <code class="docutils literal notranslate"><span class="pre">sim_setup</span></code> module. It <strong>cannot</strong> directly use runtime probe classes such as <code class="docutils literal notranslate"><span class="pre">sim.CoreProbe</span></code>, <code class="docutils literal notranslate"><span class="pre">sim.MemoryProbe</span></code>, <code class="docutils literal notranslate"><span class="pre">sim.InitiatorSocketProbe</span></code>, or any <code class="docutils literal notranslate"><span class="pre">sim_utils</span></code> utilities.</p>
<p>Those runtime probes are only available:</p>
<ol class="arabic simple">
<li><p>Inside <strong>SystemC Thread Scripts</strong> (created via <code class="docutils literal notranslate"><span class="pre">sim_setup.create_standalone_sc_thread()</span></code> or listed in the VP Config Standalone SystemC Threads table)</p></li>
<li><p>Inside <strong>begin-of-simulation callback</strong> scripts (registered via <code class="docutils literal notranslate"><span class="pre">sim_setup.add_begin_of_simulation_callback()</span></code> or listed in the VP Config Begin of Simulation callback table)</p></li>
<li><p>Inside any other <strong>lifecycle callback</strong> scripts that execute during simulation runtime</p></li>
</ol>
<p><strong>The typical pattern is therefore:</strong></p>
<ol class="arabic simple">
<li><p>The VP Config Simulation Startup Script uses <code class="docutils literal notranslate"><span class="pre">sim_setup</span></code> to <em>register</em> SimProbe scripts and callbacks</p></li>
<li><p>The actual backdoor memory operations happen when those registered scripts execute at simulation begin or during runtime</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># WRONG — will fail in a Simulation Startup Script:</span>
<span class="kn">import</span> <span class="nn">sim</span>
<span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">)</span>  <span class="c1"># ERROR: sim module not available here</span>

<span class="c1"># CORRECT — register a thread that will use sim at runtime:</span>
<span class="kn">import</span> <span class="nn">sim_setup</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">script_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>
<span class="n">sim_setup</span><span class="o">.</span><span class="n">create_standalone_sc_thread</span><span class="p">(</span>
    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">script_dir</span><span class="p">,</span> <span class="s1">&#39;load_firmware.py&#39;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="complete-example-vp-config-driven-backdoor-loading">
<h4>3.8.8 Complete Example: VP Config-Driven Backdoor Loading<a class="headerlink" href="#complete-example-vp-config-driven-backdoor-loading" title="Permalink to this heading"></a></h4>
<p><strong>File 1: <code class="docutils literal notranslate"><span class="pre">startup.py</span></code></strong> (Simulation Startup Script – specified in VP Config Overview tab)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Simulation Startup Script: Registers all SimProbe threads and callbacks.</span>
<span class="sd">Specified in VP Config &gt; Overview &gt; Simulation Startup Script field.</span>
<span class="sd">Uses sim_setup module only.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sim_setup</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="n">script_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>

<span class="c1"># 1. Register a begin-of-simulation callback for quick memory init</span>
<span class="k">def</span> <span class="nf">init_shared_memory</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">sim</span>
    <span class="c1"># Initialize shared memory region to zero</span>
    <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
        <span class="n">mem</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">MemoryProbe</span><span class="p">(</span><span class="s1">&#39;top.shared_sram&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">mem</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">print_message</span><span class="p">(</span><span class="s2">&quot;Shared memory zeroed at begin-of-simulation&quot;</span><span class="p">)</span>

<span class="n">sim_setup</span><span class="o">.</span><span class="n">add_begin_of_simulation_callback</span><span class="p">(</span><span class="n">init_shared_memory</span><span class="p">)</span>

<span class="c1"># 2. Register the firmware loader as a standalone SystemC thread</span>
<span class="n">firmware_loader</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">script_dir</span><span class="p">,</span> <span class="s1">&#39;load_firmware.py&#39;</span><span class="p">)</span>
<span class="n">sim_setup</span><span class="o">.</span><span class="n">create_standalone_sc_thread</span><span class="p">(</span>
    <span class="n">firmware_loader</span><span class="p">,</span>
    <span class="p">[</span><span class="s1">&#39;firmware/app.elf&#39;</span><span class="p">,</span> <span class="s1">&#39;0x20000000&#39;</span><span class="p">],</span>
    <span class="s1">&#39;firmware_loader&#39;</span>
<span class="p">)</span>

<span class="c1"># 3. Register a monitoring thread</span>
<span class="n">monitor_script</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">script_dir</span><span class="p">,</span> <span class="s1">&#39;bus_monitor.py&#39;</span><span class="p">)</span>
<span class="n">sim_setup</span><span class="o">.</span><span class="n">create_standalone_sc_thread</span><span class="p">(</span>
    <span class="n">monitor_script</span><span class="p">,</span>
    <span class="p">[],</span>
    <span class="s1">&#39;bus_monitor&#39;</span>
<span class="p">)</span>

<span class="c1"># 4. Register an end-of-simulation callback for state dump</span>
<span class="k">def</span> <span class="nf">dump_final_state</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">sim</span>
    <span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">)</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_core_register_value</span><span class="p">(</span><span class="s1">&#39;PC&#39;</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">print_message</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final PC: 0x</span><span class="si">{</span><span class="n">pc</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">print_message</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Instructions executed: </span><span class="si">{</span><span class="n">core</span><span class="o">.</span><span class="n">number_of_executed_instructions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">sim_setup</span><span class="o">.</span><span class="n">add_end_of_simulation_callback</span><span class="p">(</span><span class="n">dump_final_state</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>File 2: <code class="docutils literal notranslate"><span class="pre">load_firmware.py</span></code></strong> (SystemC Thread Script – registered by startup.py)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">SystemC Thread Script: Loads firmware into memory via backdoor access.</span>
<span class="sd">Registered by startup.py via sim_setup.create_standalone_sc_thread().</span>
<span class="sd">Uses sim and sim_utils modules.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sim</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">sim_utils</span> <span class="kn">import</span> <span class="n">INFO_MSG</span><span class="p">,</span> <span class="n">FATAL_MSG</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Parse arguments passed from startup.py</span>
    <span class="n">firmware_path</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;firmware/app.elf&#39;</span>
    <span class="n">base_addr_str</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="s1">&#39;0x20000000&#39;</span>
    <span class="n">base_addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">base_addr_str</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

    <span class="n">INFO_MSG</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading firmware: </span><span class="si">{</span><span class="n">firmware_path</span><span class="si">}</span><span class="s2"> at 0x</span><span class="si">{</span><span class="n">base_addr</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">)</span>

        <span class="c1"># Load ELF image with symbol info via backdoor</span>
        <span class="n">success</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">load_image</span><span class="p">(</span><span class="n">firmware_path</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">debug_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
            <span class="n">INFO_MSG</span><span class="p">(</span><span class="s2">&quot;Firmware loaded successfully&quot;</span><span class="p">)</span>
            <span class="c1"># Verify reset vector</span>
            <span class="n">reset_vec</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_memory_value</span><span class="p">(</span><span class="n">base_addr</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">INFO_MSG</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reset vector at 0x</span><span class="si">{</span><span class="n">base_addr</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">reset_vec</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">FATAL_MSG</span><span class="p">(</span><span class="s2">&quot;Failed to load firmware image&quot;</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">FATAL_MSG</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Firmware load error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>File 3: <code class="docutils literal notranslate"><span class="pre">bus_monitor.py</span></code></strong> (SystemC Thread Script – registered by startup.py)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">SystemC Thread Script: Monitors bus traffic during simulation.</span>
<span class="sd">Registered by startup.py via sim_setup.create_standalone_sc_thread().</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sim</span>
<span class="kn">from</span> <span class="nn">sim_utils</span> <span class="kn">import</span> <span class="n">INFO_MSG</span>

<span class="c1"># Set up bus transaction observation</span>
<span class="n">trace</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">SocketTraceProbe</span><span class="p">(</span><span class="s1">&#39;top.bus.target_socket&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">on_transaction_begin</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="n">INFO_MSG</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Bus transaction: addr=0x</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">address</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">, &quot;</span>
             <span class="sa">f</span><span class="s2">&quot;type=</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">, size=</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">data_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">observer</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">create_observer</span><span class="p">(</span><span class="n">begin_cb</span><span class="o">=</span><span class="n">on_transaction_begin</span><span class="p">)</span>

<span class="n">INFO_MSG</span><span class="p">(</span><span class="s2">&quot;Bus monitor armed — observing transactions&quot;</span><span class="p">)</span>

<span class="c1"># Keep the thread alive for the duration of the simulation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">wait_until</span><span class="p">((</span><span class="mi">1000</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="script-path-resolution-in-vp-config">
<h4>3.8.9 Script Path Resolution in VP Config<a class="headerlink" href="#script-path-resolution-in-vp-config" title="Permalink to this heading"></a></h4>
<p>When specifying script paths in the VP Config, paths can be expressed in several ways:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Path Type</p></th>
<th class="head"><p>Syntax</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Relative to vpconfig dir</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">${vpconfigDir}/my_script.py</span></code></p></td>
<td><p>Resolved relative to the VP Config file location</p></td>
</tr>
<tr class="row-odd"><td><p>Relative to script library</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">${LIBRARY_ID}/scripts/my_script.py</span></code></p></td>
<td><p>Resolved via the script library manager</p></td>
</tr>
<tr class="row-even"><td><p>Absolute path</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">/path/to/my_script.py</span></code></p></td>
<td><p>Absolute filesystem path</p></td>
</tr>
<tr class="row-odd"><td><p>Relative to sim executable</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">my_script.py</span></code></p></td>
<td><p>Resolved relative to the simulation executable directory</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><strong>Note:</strong> The working directory for Simulation Startup Scripts and SystemC thread scripts is the directory of the simulation executable, <strong>not</strong> the VP Config directory. Use <code class="docutils literal notranslate"><span class="pre">os.path.dirname(os.path.abspath(__file__))</span></code> to resolve paths relative to the script’s own location.</p>
</div></blockquote>
</section>
<section id="script-library-integration">
<h4>3.8.10 Script Library Integration<a class="headerlink" href="#script-library-integration" title="Permalink to this heading"></a></h4>
<p>SimProbe scripts can also be packaged as part of <strong>script libraries</strong> and delivered alongside IP libraries. A script library is defined by an <code class="docutils literal notranslate"><span class="pre">*.iplib</span></code> file:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;format&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;ip_libraries&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span>
<span class="w">        </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;MY_SCRIPT_LIBRARY&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;package_allowed&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;scripts_dir&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;scripts&quot;</span>
<span class="w">    </span><span class="p">}],</span>
<span class="w">    </span><span class="nt">&quot;examples&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span>
<span class="w">        </span><span class="nt">&quot;script_type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;sim_probe&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;is_template&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;description&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Backdoor memory loader template&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;categories&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;memory&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;initialization&quot;</span><span class="p">],</span>
<span class="w">        </span><span class="nt">&quot;files&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;templates/backdoor_loader_template.py&quot;</span><span class="p">]</span>
<span class="w">    </span><span class="p">}]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Valid <code class="docutils literal notranslate"><span class="pre">script_type</span></code> values for the iplib registration:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Script Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sim_probe</span></code></p></td>
<td><p>Standalone SystemC thread script</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">startup_script</span></code></p></td>
<td><p>Simulation Startup Script</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">startup_begin_sim_script</span></code></p></td>
<td><p>Begin-of-simulation callback script</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">startup_end_sim_script</span></code></p></td>
<td><p>End-of-simulation callback script</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">vpx_script</span></code></p></td>
<td><p>VP Explorer script</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">vdkc_script</span></code></p></td>
<td><p>VDK Debug CLI script</p></td>
</tr>
</tbody>
</table>
<p>Scripts in libraries placed inside the VDK project’s <code class="docutils literal notranslate"><span class="pre">script_lib</span></code> directory are automatically added to the Python path.</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="other-simprobe-use-cases">
<h2>4. Other SimProbe Use Cases<a class="headerlink" href="#other-simprobe-use-cases" title="Permalink to this heading"></a></h2>
<p>Beyond backdoor memory loading, SimProbe provides a comprehensive set of capabilities for simulation introspection and control.</p>
<hr class="docutils" />
<section id="signal-probing-and-fault-injection">
<h3>4.1 Signal Probing and Fault Injection<a class="headerlink" href="#signal-probing-and-fault-injection" title="Permalink to this heading"></a></h3>
<p>SimProbe can attach to SystemC signals of various data types and read, write, clamp, or observe their values.</p>
<p><strong>Available probe types:</strong> <code class="docutils literal notranslate"><span class="pre">BoolProbe</span></code>, <code class="docutils literal notranslate"><span class="pre">IntProbe</span></code>, <code class="docutils literal notranslate"><span class="pre">UintProbe</span></code>, <code class="docutils literal notranslate"><span class="pre">Uint64Probe</span></code>, <code class="docutils literal notranslate"><span class="pre">FloatProbe</span></code>, <code class="docutils literal notranslate"><span class="pre">DoubleProbe</span></code>, <code class="docutils literal notranslate"><span class="pre">LogicProbe</span></code>, <code class="docutils literal notranslate"><span class="pre">LV&lt;N&gt;Probe</span></code>, <code class="docutils literal notranslate"><span class="pre">ScInt&lt;N&gt;Probe</span></code>, <code class="docutils literal notranslate"><span class="pre">ScUint&lt;N&gt;Probe</span></code>, <code class="docutils literal notranslate"><span class="pre">ScBigInt&lt;N&gt;Probe</span></code>, <code class="docutils literal notranslate"><span class="pre">ScBigUint&lt;N&gt;Probe</span></code>, <code class="docutils literal notranslate"><span class="pre">CharProbe</span></code>, <code class="docutils literal notranslate"><span class="pre">ShortProbe</span></code>, <code class="docutils literal notranslate"><span class="pre">TimeProbe</span></code>, and more.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="c1"># Read a signal value</span>
<span class="n">sig</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">UintProbe</span><span class="p">(</span><span class="s1">&#39;top.subsystem.my_signal&#39;</span><span class="p">)</span>
<span class="n">current_val</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Signal value: </span><span class="si">{</span><span class="n">current_val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Write a signal value</span>
<span class="n">sig</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Clamp a signal to a fixed value (fault injection)</span>
<span class="n">sig</span><span class="o">.</span><span class="n">set_clamp_value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>            <span class="c1"># Force signal to 0 indefinitely</span>
<span class="n">sig</span><span class="o">.</span><span class="n">set_clamp_value_for</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;us&#39;</span><span class="p">))</span>  <span class="c1"># Clamp to 1 for 10us then release</span>

<span class="c1"># Wait for a signal condition (blocks the SystemC thread)</span>
<span class="n">sig</span><span class="o">.</span><span class="n">wait_for_value</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>             <span class="c1"># Wait until signal equals 1</span>
<span class="n">sig</span><span class="o">.</span><span class="n">wait_for_any_value_change</span><span class="p">()</span>   <span class="c1"># Wait for any change</span>

<span class="c1"># Register a callback on signal change</span>
<span class="k">def</span> <span class="nf">on_signal_change</span><span class="p">(</span><span class="n">probe</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Signal changed to: </span><span class="si">{</span><span class="n">probe</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">probe</span><span class="o">.</span><span class="n">callback_on_any_value_change</span><span class="p">()</span>  <span class="c1"># Re-arm (one-shot)</span>

<span class="n">sig</span><span class="o">.</span><span class="n">set_callback</span><span class="p">(</span><span class="n">on_signal_change</span><span class="p">)</span>
<span class="n">sig</span><span class="o">.</span><span class="n">callback_on_any_value_change</span><span class="p">()</span>

<span class="c1"># Release clamp</span>
<span class="n">sig</span><span class="o">.</span><span class="n">release_clamp</span><span class="p">()</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="clock-manipulation">
<h3>4.2 Clock Manipulation<a class="headerlink" href="#clock-manipulation" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ClockProbe</span></code> allows reading, modifying, and clamping SCML clock properties.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="n">clk</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">ClockProbe</span><span class="p">(</span><span class="s1">&#39;top.clk_gen.main_clock&#39;</span><span class="p">)</span>

<span class="c1"># Read clock properties</span>
<span class="n">period</span> <span class="o">=</span> <span class="n">clk</span><span class="o">.</span><span class="n">get_period</span><span class="p">()</span>          <span class="c1"># Returns (amount, unit) tuple</span>
<span class="n">enabled</span> <span class="o">=</span> <span class="n">clk</span><span class="o">.</span><span class="n">get_enabled</span><span class="p">()</span>
<span class="n">running</span> <span class="o">=</span> <span class="n">clk</span><span class="o">.</span><span class="n">get_running</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Clock period: </span><span class="si">{</span><span class="n">period</span><span class="si">}</span><span class="s2">, enabled: </span><span class="si">{</span><span class="n">enabled</span><span class="si">}</span><span class="s2">, running: </span><span class="si">{</span><span class="n">running</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Modify clock period</span>
<span class="n">clk</span><span class="o">.</span><span class="n">set_period</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;ns&#39;</span><span class="p">))</span>         <span class="c1"># Set to 10ns period (100MHz)</span>

<span class="c1"># Disable/enable clock</span>
<span class="n">clk</span><span class="o">.</span><span class="n">set_enabled</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>             <span class="c1"># Gate the clock</span>
<span class="n">clk</span><span class="o">.</span><span class="n">set_enabled</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>              <span class="c1"># Ungate</span>

<span class="c1"># Clamp clock period (prevent SW from changing it)</span>
<span class="n">clk</span><span class="o">.</span><span class="n">set_clamp_period</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="s1">&#39;ns&#39;</span><span class="p">))</span>   <span class="c1"># Force 50MHz</span>
<span class="n">clk</span><span class="o">.</span><span class="n">set_clamp_enabled</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>        <span class="c1"># Force clock enabled</span>

<span class="c1"># Timed clamp -- clamp for a duration, then release</span>
<span class="n">clk</span><span class="o">.</span><span class="n">set_clamp_period_for</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;ns&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;us&#39;</span><span class="p">))</span>  <span class="c1"># 200MHz for 100us</span>

<span class="c1"># Wait for clock property changes</span>
<span class="n">clk</span><span class="o">.</span><span class="n">wait_for_period_change</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;ns&#39;</span><span class="p">))</span>

<span class="c1"># Release all clamps</span>
<span class="n">clk</span><span class="o">.</span><span class="n">release_clamp</span><span class="p">()</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="processor-core-introspection">
<h3>4.3 Processor Core Introspection<a class="headerlink" href="#processor-core-introspection" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">CoreProbe</span></code> provides deep introspection into processor cores:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">)</span>

<span class="c1"># -- Core Properties --</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Architecture: </span><span class="si">{</span><span class="n">core</span><span class="o">.</span><span class="n">architecture_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Architecture Family: </span><span class="si">{</span><span class="n">core</span><span class="o">.</span><span class="n">architecture_family_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Instance: </span><span class="si">{</span><span class="n">core</span><span class="o">.</span><span class="n">instance_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Instructions executed: </span><span class="si">{</span><span class="n">core</span><span class="o">.</span><span class="n">number_of_executed_instructions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cycles executed: </span><span class="si">{</span><span class="n">core</span><span class="o">.</span><span class="n">number_of_executed_cycles</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current context: </span><span class="si">{</span><span class="n">core</span><span class="o">.</span><span class="n">current_context</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># -- Register Access --</span>
<span class="n">regs</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">core_registers</span>  <span class="c1"># List all register names</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Available registers: </span><span class="si">{</span><span class="n">regs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">pc_val</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_core_register_value</span><span class="p">(</span><span class="s1">&#39;PC&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Program Counter: 0x</span><span class="si">{</span><span class="n">pc_val</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">core</span><span class="o">.</span><span class="n">set_core_register_value</span><span class="p">(</span><span class="s1">&#39;R0&#39;</span><span class="p">,</span> <span class="mh">0x12345678</span><span class="p">)</span>  <span class="c1"># Set register value</span>

<span class="c1"># -- Symbol Lookup --</span>
<span class="n">sym</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">find_symbol_by_name</span><span class="p">(</span><span class="s1">&#39;main&#39;</span><span class="p">,</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;main() at address: 0x</span><span class="si">{</span><span class="n">sym</span><span class="o">.</span><span class="n">address</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">, size: </span><span class="si">{</span><span class="n">sym</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># -- Disassembly --</span>
<span class="n">mnemonic</span><span class="p">,</span> <span class="n">opcode</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_disassembly_info</span><span class="p">(</span><span class="mh">0x20000000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Instruction at 0x20000000: </span><span class="si">{</span><span class="n">mnemonic</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">opcode</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

<span class="c1"># -- Debug Info (DWARF) --</span>
<span class="n">dbg</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_debug_info</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>  <span class="c1"># Empty string = no OS context</span>
<span class="n">var_info</span> <span class="o">=</span> <span class="n">dbg</span><span class="o">.</span><span class="n">find_variable</span><span class="p">(</span><span class="s1">&#39;global_counter&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">var_info</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; type: </span><span class="si">{</span><span class="n">var_info</span><span class="o">.</span><span class="n">type_info</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">var_info</span><span class="o">.</span><span class="n">get_typed_value</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Value: </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="tlm2-transaction-observation-and-manipulation">
<h3>4.4 TLM2 Transaction Observation and Manipulation<a class="headerlink" href="#tlm2-transaction-observation-and-manipulation" title="Permalink to this heading"></a></h3>
<section id="observing-transactions-targetsocketprobe-sockettraceprobe">
<h4>4.4.1 Observing Transactions (TargetSocketProbe / SocketTraceProbe)<a class="headerlink" href="#observing-transactions-targetsocketprobe-sockettraceprobe" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="c1"># Observe all transactions on a TLM2 socket</span>
<span class="n">trace</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">SocketTraceProbe</span><span class="p">(</span><span class="s1">&#39;top.bus.target_socket&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">on_begin</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Transaction BEGIN: type=</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">, time=</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">on_end</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Transaction END: type=</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">observer</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">create_observer</span><span class="p">(</span>
    <span class="n">begin_cb</span><span class="o">=</span><span class="n">on_begin</span><span class="p">,</span>
    <span class="n">end_cb</span><span class="o">=</span><span class="n">on_end</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="transaction-manipulation-targetsocketprobe">
<h4>4.4.2 Transaction Manipulation (TargetSocketProbe)<a class="headerlink" href="#transaction-manipulation-targetsocketprobe" title="Permalink to this heading"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">TargetSocketProbe</span></code> allows not just observing but also modifying transaction arguments (address, data, response status) in-flight.</p>
</section>
</section>
<hr class="docutils" />
<section id="memory-content-observation">
<h3>4.5 Memory Content Observation<a class="headerlink" href="#memory-content-observation" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">MemoryContentObserver</span></code> triggers callbacks on memory accesses to specific address ranges:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="k">def</span> <span class="nf">on_memory_access</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">get_before_access_value</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Memory </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">access_kind</span><span class="si">}</span><span class="s2"> at index </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">: &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;0x</span><span class="si">{</span><span class="n">prev</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2"> -&gt; 0x</span><span class="si">{</span><span class="n">val</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Observe writes to indices 0-255 of an SCML2 memory</span>
<span class="n">obs</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">MemoryContentObserver</span><span class="p">(</span>
    <span class="s1">&#39;top.sram.memory&#39;</span><span class="p">,</span>     <span class="c1"># Memory object name</span>
    <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>                <span class="c1"># Start index</span>
    <span class="n">end</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span>                <span class="c1"># End index</span>
    <span class="n">cb</span><span class="o">=</span><span class="n">on_memory_access</span><span class="p">,</span>
    <span class="n">access_kind</span><span class="o">=</span><span class="s1">&#39;write&#39;</span>     <span class="c1"># &#39;read&#39;, &#39;write&#39;, or &#39;any&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="software-function-tracing">
<h3>4.6 Software Function Tracing<a class="headerlink" href="#software-function-tracing" title="Permalink to this heading"></a></h3>
<section id="function-entry-exit-observer">
<h4>4.6.1 Function Entry/Exit Observer<a class="headerlink" href="#function-entry-exit-observer" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">on_function</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="n">change</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">functionChange</span>  <span class="c1"># &#39;Call&#39; or &#39;Return&#39;</span>
    <span class="n">func_name</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">name</span>
    <span class="n">context</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">context</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">sim</span><span class="o">.</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">change</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2"> (context: </span><span class="si">{</span><span class="n">context</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

<span class="n">func_obs</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">create_enter_function_observer</span><span class="p">(</span><span class="n">on_function</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="instruction-execution-observer">
<h4>4.6.2 Instruction Execution Observer<a class="headerlink" href="#instruction-execution-observer" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">on_instruction</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Executing instruction at 0x</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">address</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Trigger callback when PC enters the address range [0x2000_0000, 0x2000_0100]</span>
<span class="n">instr_obs</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">create_about_to_execute_instruction_observer</span><span class="p">(</span>
    <span class="n">cb</span><span class="o">=</span><span class="n">on_instruction</span><span class="p">,</span>
    <span class="n">first</span><span class="o">=</span><span class="mh">0x20000000</span><span class="p">,</span>
    <span class="n">last</span><span class="o">=</span><span class="mh">0x20000100</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="register-access-observer">
<h4>4.6.3 Register Access Observer<a class="headerlink" href="#register-access-observer" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">on_reg_access</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Register </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">access_kind</span><span class="si">}</span><span class="s2">: &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;0x</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">prev_value</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2"> -&gt; 0x</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">value</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2"> &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;(PC=0x</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">hit_pc</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

<span class="n">reg_obs</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">create_core_register_observer</span><span class="p">(</span>
    <span class="n">cb</span><span class="o">=</span><span class="n">on_reg_access</span><span class="p">,</span>
    <span class="n">registers</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;R0&#39;</span><span class="p">,</span> <span class="s1">&#39;R1&#39;</span><span class="p">,</span> <span class="s1">&#39;SP&#39;</span><span class="p">,</span> <span class="s1">&#39;LR&#39;</span><span class="p">],</span>
    <span class="n">access_kind</span><span class="o">=</span><span class="s1">&#39;write&#39;</span>        <span class="c1"># &#39;read&#39;, &#39;write&#39;, or &#39;any&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="software-memory-access-observer">
<h4>4.6.4 Software Memory Access Observer<a class="headerlink" href="#software-memory-access-observer" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">on_sw_mem_access</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SW memory </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">access_kind</span><span class="si">}</span><span class="s2"> at sw_addr=0x</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">software_address</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">, &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;port=</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">port</span><span class="si">}</span><span class="s2">, data=</span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">mem_obs</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">create_end_sw_memory_access_observer</span><span class="p">(</span>
    <span class="n">cb</span><span class="o">=</span><span class="n">on_sw_mem_access</span><span class="p">,</span>
    <span class="n">address</span><span class="o">=</span><span class="mh">0x40000000</span><span class="p">,</span>        <span class="c1"># Start address to watch</span>
    <span class="n">access_kind</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span>
    <span class="n">region_size</span><span class="o">=</span><span class="mh">0x1000</span>         <span class="c1"># Watch a 4KB region</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="register-probing">
<h3>4.7 Register Probing<a class="headerlink" href="#register-probing" title="Permalink to this heading"></a></h3>
<p>The utility classes <code class="docutils literal notranslate"><span class="pre">RegisterFieldProbe</span></code> and <code class="docutils literal notranslate"><span class="pre">RegisterSetProbe</span></code> provide high-level access to SCML2 register fields:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sim_utils</span> <span class="kn">import</span> <span class="n">RegisterFieldProbe</span><span class="p">,</span> <span class="n">RegisterSetProbe</span>

<span class="c1"># Probe an entire register set</span>
<span class="n">reg_set</span> <span class="o">=</span> <span class="n">RegisterSetProbe</span><span class="p">(</span><span class="s1">&#39;top.peripheral.reg_set&#39;</span><span class="p">)</span>

<span class="c1"># Probe a specific register field</span>
<span class="n">field</span> <span class="o">=</span> <span class="n">RegisterFieldProbe</span><span class="p">(</span><span class="s1">&#39;top.peripheral.reg_set.CTRL.ENABLE&#39;</span><span class="p">)</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
<span class="n">field</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="gda-trace-creation-data-analysis">
<h3>4.8 GDA Trace Creation (Data Analysis)<a class="headerlink" href="#gda-trace-creation-data-analysis" title="Permalink to this heading"></a></h3>
<p>SimProbe can create custom GDA (Generic Data Analysis) traces for visualization in Synopsys analysis tools:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="c1"># Create an integer trace</span>
<span class="n">trace</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">IntegerTrace</span><span class="p">(</span>
    <span class="n">owner</span><span class="o">=</span><span class="s1">&#39;top.my_module&#39;</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;custom_counter&#39;</span><span class="p">,</span>
    <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Tracks a custom counter value&#39;</span>
<span class="p">)</span>
<span class="n">el_id</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">add_element</span><span class="p">(</span><span class="s1">&#39;counter&#39;</span><span class="p">)</span>

<span class="c1"># Update trace values during simulation</span>
<span class="n">trace</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">element_id</span><span class="o">=</span><span class="n">el_id</span><span class="p">)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">wait_for</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;us&#39;</span><span class="p">))</span>
<span class="n">trace</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">element_id</span><span class="o">=</span><span class="n">el_id</span><span class="p">)</span>

<span class="c1"># Enum traces for state machines</span>
<span class="n">state_trace</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">EnumTrace</span><span class="p">(</span><span class="s1">&#39;top.fsm&#39;</span><span class="p">,</span> <span class="s1">&#39;state&#39;</span><span class="p">,</span> <span class="s1">&#39;FSM State&#39;</span><span class="p">)</span>
<span class="n">state_trace</span><span class="o">.</span><span class="n">register_value</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;IDLE&#39;</span><span class="p">)</span>
<span class="n">state_trace</span><span class="o">.</span><span class="n">register_value</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;ACTIVE&#39;</span><span class="p">)</span>
<span class="n">state_trace</span><span class="o">.</span><span class="n">register_value</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;ERROR&#39;</span><span class="p">)</span>
<span class="n">state_trace</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Set initial state to IDLE</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="profiling">
<h3>4.9 Profiling<a class="headerlink" href="#profiling" title="Permalink to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="n">profiler</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">Profiler</span><span class="p">()</span>

<span class="c1"># Start Top-Down Profiler collection</span>
<span class="n">profiler</span><span class="o">.</span><span class="n">start_top_down_profile</span><span class="p">({</span>
    <span class="s1">&#39;output_file&#39;</span><span class="p">:</span> <span class="s1">&#39;profile_results.db&#39;</span>
<span class="p">})</span>

<span class="c1"># Add segment annotations</span>
<span class="n">seg_id</span> <span class="o">=</span> <span class="n">profiler</span><span class="o">.</span><span class="n">begin_segment_annotation</span><span class="p">(</span><span class="s1">&#39;boot_phase&#39;</span><span class="p">)</span>
<span class="c1"># ... simulation runs ...</span>
<span class="n">profiler</span><span class="o">.</span><span class="n">end_segment_annotation</span><span class="p">(</span><span class="n">seg_id</span><span class="p">)</span>

<span class="c1"># Stop profiling</span>
<span class="n">profiler</span><span class="o">.</span><span class="n">stop_top_down_profile</span><span class="p">()</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="simulation-control">
<h3>4.10 Simulation Control<a class="headerlink" href="#simulation-control" title="Permalink to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sim</span>

<span class="c1"># Time management</span>
<span class="n">current_time</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_time</span><span class="p">()</span>           <span class="c1"># Formatted string</span>
<span class="n">time_ps</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_time_in_ps</span><span class="p">()</span>          <span class="c1"># Picoseconds as float</span>
<span class="n">time_us</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_time_in_unit</span><span class="p">(</span><span class="s1">&#39;us&#39;</span><span class="p">)</span>    <span class="c1"># In microseconds</span>

<span class="c1"># Wait for simulation time</span>
<span class="n">sim</span><span class="o">.</span><span class="n">wait_for</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;us&#39;</span><span class="p">))</span>                <span class="c1"># Wait for 10 microseconds</span>
<span class="n">sim</span><span class="o">.</span><span class="n">wait_until</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;ms&#39;</span><span class="p">))</span>              <span class="c1"># Wait until simulation reaches 1ms</span>

<span class="c1"># Suspend/stop simulation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">suspend_simulation</span><span class="p">()</span>                <span class="c1"># Pause (resume from outside)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">stop_simulation</span><span class="p">()</span>                   <span class="c1"># End simulation</span>

<span class="c1"># Event-based synchronization</span>
<span class="n">evt</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">EventProbe</span><span class="p">(</span><span class="s1">&#39;top.my_event&#39;</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">evt</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>                            <span class="c1"># Notify event</span>
<span class="n">evt</span><span class="o">.</span><span class="n">notify</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;ns&#39;</span><span class="p">))</span>                   <span class="c1"># Timed notification</span>
<span class="n">evt</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>                              <span class="c1"># Wait for notification (blocking)</span>

<span class="c1"># Inter-thread communication</span>
<span class="n">sim</span><span class="o">.</span><span class="n">post_message</span><span class="p">(</span><span class="s2">&quot;Hello from SimProbe&quot;</span><span class="p">)</span>  <span class="c1"># Send to VDK Debug console</span>
<span class="n">sim</span><span class="o">.</span><span class="n">print_message</span><span class="p">(</span><span class="s2">&quot;Thread-safe output&quot;</span><span class="p">)</span>  <span class="c1"># Thread-safe print</span>

<span class="c1"># Query simulation objects</span>
<span class="n">top</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_top_instance_name</span><span class="p">()</span>
<span class="n">cores</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_cores</span><span class="p">()</span>
<span class="n">connected</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">are_connected</span><span class="p">(</span><span class="s1">&#39;top.a.socket&#39;</span><span class="p">,</span> <span class="s1">&#39;top.b.socket&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="complete-backdoor-memory-loading-examples">
<h2>5. Complete Backdoor Memory Loading Examples<a class="headerlink" href="#complete-backdoor-memory-loading-examples" title="Permalink to this heading"></a></h2>
<section id="example-1-full-firmware-load-at-simulation-start">
<h3>Example 1: Full Firmware Load at Simulation Start<a class="headerlink" href="#example-1-full-firmware-load-at-simulation-start" title="Permalink to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">SimProbe script: Load firmware into core memory at simulation begin.</span>
<span class="sd">Run via: sim_setup.create_standalone_sc_thread(&#39;load_firmware.py&#39;)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sim</span>
<span class="kn">from</span> <span class="nn">sim_utils</span> <span class="kn">import</span> <span class="n">INFO_MSG</span><span class="p">,</span> <span class="n">FATAL_MSG</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">core_name</span> <span class="o">=</span> <span class="s1">&#39;top.cpu0&#39;</span>
    <span class="n">firmware_path</span> <span class="o">=</span> <span class="s1">&#39;firmware/app.elf&#39;</span>

    <span class="n">INFO_MSG</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading firmware from </span><span class="si">{</span><span class="n">firmware_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="n">core_name</span><span class="p">)</span>

        <span class="c1"># Method 1: Load ELF image (includes symbols)</span>
        <span class="n">success</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">load_image</span><span class="p">(</span><span class="n">firmware_path</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">debug_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
            <span class="n">INFO_MSG</span><span class="p">(</span><span class="s2">&quot;Firmware loaded successfully via load_image()&quot;</span><span class="p">)</span>

            <span class="c1"># Verify: read the reset vector</span>
            <span class="n">reset_vec</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_memory_value</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">INFO_MSG</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reset vector: </span><span class="si">{</span><span class="n">reset_vec</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">FATAL_MSG</span><span class="p">(</span><span class="s2">&quot;Failed to load firmware&quot;</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">FATAL_MSG</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading firmware: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="example-2-load-raw-binary-data-via-backdoor">
<h3>Example 2: Load Raw Binary Data via Backdoor<a class="headerlink" href="#example-2-load-raw-binary-data-via-backdoor" title="Permalink to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">SimProbe script: Load raw binary data into memory via CoreProbe backdoor.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sim</span>
<span class="kn">from</span> <span class="nn">sim_utils</span> <span class="kn">import</span> <span class="n">INFO_MSG</span>

<span class="k">def</span> <span class="nf">load_binary</span><span class="p">(</span><span class="n">core_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">base_addr</span><span class="p">):</span>
    <span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="n">core_name</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

    <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">chunk_sz</span> <span class="o">=</span> <span class="mi">1024</span>
    <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">off</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">chunk_sz</span><span class="p">):</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">off</span><span class="p">:</span><span class="n">off</span> <span class="o">+</span> <span class="n">chunk_sz</span><span class="p">]</span>
        <span class="n">core</span><span class="o">.</span><span class="n">set_memory_value</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">))</span>
        <span class="n">written</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>

    <span class="n">INFO_MSG</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded </span><span class="si">{</span><span class="n">written</span><span class="si">}</span><span class="s2"> bytes to 0x</span><span class="si">{</span><span class="n">base_addr</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Verify first 16 bytes</span>
    <span class="n">verify</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_memory_value</span><span class="p">(</span><span class="n">base_addr</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">INFO_MSG</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Verify [0x</span><span class="si">{</span><span class="n">base_addr</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">]: </span><span class="si">{</span><span class="n">verify</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">written</span>

<span class="c1"># Load test data</span>
<span class="n">load_binary</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">,</span> <span class="s1">&#39;test_vectors.bin&#39;</span><span class="p">,</span> <span class="mh">0x20000000</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="example-3-load-data-via-bus-debug-transactions">
<h3>Example 3: Load Data via Bus Debug Transactions<a class="headerlink" href="#example-3-load-data-via-bus-debug-transactions" title="Permalink to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">SimProbe script: Load data into peripheral memory via bus debug transactions.</span>
<span class="sd">Useful when memory is behind an address decoder/interconnect.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sim</span>
<span class="kn">from</span> <span class="nn">sim_utils</span> <span class="kn">import</span> <span class="n">BasicInitiatorSocketProbe</span><span class="p">,</span> <span class="n">INFO_MSG</span>

<span class="k">def</span> <span class="nf">load_via_bus</span><span class="p">(</span><span class="n">socket_name</span><span class="p">,</span> <span class="n">base_addr</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a dictionary of {offset: value} pairs via debug writes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">probe</span> <span class="o">=</span> <span class="n">BasicInitiatorSocketProbe</span><span class="p">(</span><span class="n">socket_name</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="n">base_addr</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="n">probe</span><span class="o">.</span><span class="n">debug_write4</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># Verify</span>
        <span class="n">readback</span> <span class="o">=</span> <span class="n">probe</span><span class="o">.</span><span class="n">debug_read4</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">readback</span> <span class="o">==</span> <span class="n">value</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Mismatch at 0x</span><span class="si">{</span><span class="n">addr</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">: wrote 0x</span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">, read 0x</span><span class="si">{</span><span class="n">readback</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">INFO_MSG</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> words via </span><span class="si">{</span><span class="n">socket_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Example: Initialize PCIe configuration space registers</span>
<span class="n">pcie_config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mh">0x00</span><span class="p">:</span> <span class="mh">0x16C311AB</span><span class="p">,</span>  <span class="c1"># Vendor/Device ID</span>
    <span class="mh">0x04</span><span class="p">:</span> <span class="mh">0x00100006</span><span class="p">,</span>  <span class="c1"># Command/Status</span>
    <span class="mh">0x08</span><span class="p">:</span> <span class="mh">0x02800001</span><span class="p">,</span>  <span class="c1"># Class Code / Revision</span>
    <span class="mh">0x0C</span><span class="p">:</span> <span class="mh">0x00000010</span><span class="p">,</span>  <span class="c1"># Header Type</span>
    <span class="mh">0x10</span><span class="p">:</span> <span class="mh">0xF0000000</span><span class="p">,</span>  <span class="c1"># BAR0</span>
    <span class="mh">0x14</span><span class="p">:</span> <span class="mh">0x00000000</span><span class="p">,</span>  <span class="c1"># BAR1</span>
<span class="p">}</span>

<span class="n">load_via_bus</span><span class="p">(</span><span class="s1">&#39;top.bus.init_socket&#39;</span><span class="p">,</span> <span class="mh">0xFE000000</span><span class="p">,</span> <span class="n">pcie_config</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="example-4-memory-initialization-with-observation">
<h3>Example 4: Memory Initialization with Observation<a class="headerlink" href="#example-4-memory-initialization-with-observation" title="Permalink to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">SimProbe script: Initialize memory and set up observers to watch for accesses.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sim</span>
<span class="kn">from</span> <span class="nn">sim_utils</span> <span class="kn">import</span> <span class="n">INFO_MSG</span>

<span class="c1"># Step 1: Initialize memory region via backdoor</span>
<span class="n">core</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">CoreProbe</span><span class="p">(</span><span class="s1">&#39;top.cpu0&#39;</span><span class="p">)</span>

<span class="c1"># Write test pattern</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">([(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">])</span>
    <span class="n">core</span><span class="o">.</span><span class="n">set_memory_value</span><span class="p">(</span><span class="mh">0x20000000</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="n">INFO_MSG</span><span class="p">(</span><span class="s2">&quot;Memory initialized with test pattern&quot;</span><span class="p">)</span>

<span class="c1"># Step 2: Set up memory content observer to watch for accesses</span>
<span class="k">def</span> <span class="nf">on_access</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
    <span class="n">INFO_MSG</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Memory </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">access_kind</span><span class="si">}</span><span class="s2"> at index </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">: 0x</span><span class="si">{</span><span class="n">val</span><span class="si">:</span><span class="s2">08X</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">obs</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">MemoryContentObserver</span><span class="p">(</span>
    <span class="s1">&#39;top.sram.memory&#39;</span><span class="p">,</span>
    <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span>
    <span class="n">cb</span><span class="o">=</span><span class="n">on_access</span><span class="p">,</span>
    <span class="n">access_kind</span><span class="o">=</span><span class="s1">&#39;any&#39;</span>
<span class="p">)</span>

<span class="n">INFO_MSG</span><span class="p">(</span><span class="s2">&quot;Memory observer armed -- waiting for accesses&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="summary-of-key-apis-for-backdoor-access">
<h2>6. Summary of Key APIs for Backdoor Access<a class="headerlink" href="#summary-of-key-apis-for-backdoor-access" title="Permalink to this heading"></a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>API Class / Method</p></th>
<th class="head"><p>Access Type</p></th>
<th class="head"><p>Use Case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong><code class="docutils literal notranslate"><span class="pre">CoreProbe.load_image()</span></code></strong></p></td>
<td><p>Backdoor</p></td>
<td><p>Load complete ELF/HEX/SREC images with symbols</p></td>
</tr>
<tr class="row-odd"><td><p><strong><code class="docutils literal notranslate"><span class="pre">CoreProbe.set_memory_value()</span></code></strong></p></td>
<td><p>Backdoor</p></td>
<td><p>Write raw data to core memory (debug write)</p></td>
</tr>
<tr class="row-even"><td><p><strong><code class="docutils literal notranslate"><span class="pre">CoreProbe.get_memory_value()</span></code></strong></p></td>
<td><p>Backdoor</p></td>
<td><p>Read raw data from core memory (debug read)</p></td>
</tr>
<tr class="row-odd"><td><p><strong><code class="docutils literal notranslate"><span class="pre">CoreProbe.set_software_data_view_memory_value()</span></code></strong></p></td>
<td><p>Backdoor</p></td>
<td><p>Write via virtual address (MMU-aware)</p></td>
</tr>
<tr class="row-even"><td><p><strong><code class="docutils literal notranslate"><span class="pre">CoreProbe.get_software_data_view_memory_value()</span></code></strong></p></td>
<td><p>Backdoor</p></td>
<td><p>Read via virtual address (MMU-aware)</p></td>
</tr>
<tr class="row-odd"><td><p><strong><code class="docutils literal notranslate"><span class="pre">MemoryProbe.set_value()</span></code></strong></p></td>
<td><p>Backdoor</p></td>
<td><p>Write to SCML2 memory by SystemC name (debug write)</p></td>
</tr>
<tr class="row-even"><td><p><strong><code class="docutils literal notranslate"><span class="pre">MemoryProbe.get_value()</span></code></strong></p></td>
<td><p>Backdoor</p></td>
<td><p>Read from SCML2 memory by SystemC name (debug read)</p></td>
</tr>
<tr class="row-odd"><td><p><strong><code class="docutils literal notranslate"><span class="pre">MemoryProbe.set_clamp_with_value()</span></code></strong></p></td>
<td><p>Backdoor + Clamp</p></td>
<td><p>Force memory to return a specific value</p></td>
</tr>
<tr class="row-even"><td><p><strong><code class="docutils literal notranslate"><span class="pre">InitiatorSocketProbe.debug_write()</span></code></strong></p></td>
<td><p>Backdoor via Bus</p></td>
<td><p>Debug write transaction through TLM2 socket</p></td>
</tr>
<tr class="row-odd"><td><p><strong><code class="docutils literal notranslate"><span class="pre">InitiatorSocketProbe.debug_read()</span></code></strong></p></td>
<td><p>Backdoor via Bus</p></td>
<td><p>Debug read transaction through TLM2 socket</p></td>
</tr>
<tr class="row-even"><td><p><strong><code class="docutils literal notranslate"><span class="pre">BasicInitiatorSocketProbe.debug_write4()</span></code></strong></p></td>
<td><p>Backdoor via Bus</p></td>
<td><p>Convenience 4-byte debug write</p></td>
</tr>
<tr class="row-odd"><td><p><strong><code class="docutils literal notranslate"><span class="pre">BasicInitiatorSocketProbe.mem_fill()</span></code></strong></p></td>
<td><p>Backdoor via Bus</p></td>
<td><p>Fill memory region with pattern</p></td>
</tr>
<tr class="row-even"><td><p><strong><code class="docutils literal notranslate"><span class="pre">BasicInitiatorSocketProbe.mem_copy()</span></code></strong></p></td>
<td><p>Backdoor via Bus</p></td>
<td><p>Copy between memory regions</p></td>
</tr>
</tbody>
</table>
<section id="key-distinctions">
<h3>Key Distinctions<a class="headerlink" href="#key-distinctions" title="Permalink to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Approach</p></th>
<th class="head"><p>When to Use</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>CoreProbe</strong></p></td>
<td><p>When loading firmware/data into a processor core’s memory space. Supports ELF loading with symbols.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>MemoryProbe</strong></p></td>
<td><p>When accessing a specific SCML2 memory object by its SystemC hierarchical name. Supports clamping.</p></td>
</tr>
<tr class="row-even"><td><p><strong>InitiatorSocketProbe</strong></p></td>
<td><p>When accessing memory through the bus interconnect (address-decoded). Useful for peripherals.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="backdoor-vs-normal-access">
<h3>Backdoor vs. Normal Access<a class="headerlink" href="#backdoor-vs-normal-access" title="Permalink to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Backdoor (Debug)</p></th>
<th class="head"><p>Normal (Timed)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Simulation time</p></td>
<td><p>Zero-delay</p></td>
<td><p>Consumes time</p></td>
</tr>
<tr class="row-odd"><td><p>Bus arbitration</p></td>
<td><p>Bypassed</p></td>
<td><p>Normal arbitration</p></td>
</tr>
<tr class="row-even"><td><p>Side effects</p></td>
<td><p>None</p></td>
<td><p>Triggers callbacks, interrupts</p></td>
</tr>
<tr class="row-odd"><td><p>Cache coherency</p></td>
<td><p>Not affected</p></td>
<td><p>Normal behavior</p></td>
</tr>
<tr class="row-even"><td><p>Use case</p></td>
<td><p>Initialization, inspection</p></td>
<td><p>Functional testing</p></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p><em>Document generated from: VP Simulation Probes Python Interface Reference Manual, V-2024.03, April 2024, Synopsys, Inc.</em></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, SystemC Modeling Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>