<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Keraunos PCIE Tile SystemC/TLM2.0 Testplan &mdash; Keraunos PCIe Tile 2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="https://unpkg.com/mermaid@10.6.1/dist/mermaid.min.js"></script>
        <script>
mermaid.initialize({
    startOnLoad: true,
    theme: 'default',
    themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#000',
        primaryBorderColor: '#1976d2',
        lineColor: '#1976d2',
        secondaryColor: '#fff4e1',
        tertiaryColor: '#e8f5e9'
    },
    flowchart: {
        useMaxWidth: true,
        htmlLabels: true,
        curve: 'basis',
        padding: 15
    },
    sequence: {
        useMaxWidth: true,
        diagramMarginX: 50,
        diagramMarginY: 10,
        actorMargin: 50,
        boxMargin: 10,
        boxTextMargin: 5,
        noteMargin: 10,
        messageMargin: 35
    },
    gantt: {
        useMaxWidth: true,
        barHeight: 20,
        barGap: 4,
        topPadding: 50,
        leftPadding: 75,
        gridLineStartPadding: 35
    },
    class: {
        useMaxWidth: true
    },
    state: {
        useMaxWidth: true
    }
});
</script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Enable Gating Feature - Design Documentation" href="ENABLE_GATING_DESIGN.html" />
    <link rel="prev" title="Keraunos PCIE Tile SystemC/TLM2.0 Design Document" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Keraunos PCIe Tile
          </a>
              <div class="version">
                2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Keraunos_System_Architecture.html">Keraunos System Architecture</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#pcie-tile-integration-in-keraunos-e100-chiplet-ecosystem">PCIe Tile Integration in Keraunos-E100 Chiplet Ecosystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#executive-summary">Executive Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#table-of-contents">Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#system-overview">1. System Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#grendel-chiplet-ecosystem">1.1 Grendel Chiplet Ecosystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#keraunos-e100-role">1.2 Keraunos-E100 Role</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#keraunos-e100-chiplet-architecture">2. Keraunos-E100 Chiplet Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#high-level-block-diagram">2.1 High-Level Block Diagram</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#key-subsystems">2.2 Key Subsystems</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_System_Architecture.html#chiplet-harness">2.2.1 Chiplet Harness</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_System_Architecture.html#pcie-subsystem">2.2.2 PCIe Subsystem</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_System_Architecture.html#hsio-high-speed-i-o-tiles">2.2.3 HSIO (High-Speed I/O) Tiles</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_System_Architecture.html#noc-infrastructure">2.2.4 NOC Infrastructure</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#pcie-tile-position-in-the-system">3. PCIe Tile Position in the System</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#pcie-tile-overview">3.1 PCIe Tile Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#architectural-position">3.2 Architectural Position</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#key-interfaces">3.3 Key Interfaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#connectivity-architecture">4. Connectivity Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#inbound-data-path-host-chip">4.1 Inbound Data Path (Host → Chip)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#outbound-data-path-chip-host">4.2 Outbound Data Path (Chip → Host)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#configuration-path-smn-pcie-tile-registers">4.3 Configuration Path (SMN → PCIe Tile Registers)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#msi-interrupt-path-chip-host">4.4 MSI Interrupt Path (Chip → Host)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#data-flow-paths">5. Data Flow Paths</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#end-to-end-data-flow-example-host-dma-to-quasar">5.1 End-to-End Data Flow Example: Host DMA to Quasar</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#multi-hop-data-flow-quasar-pcie-host-pcie-quasar">5.2 Multi-Hop Data Flow: Quasar → PCIe → Host → PCIe → Quasar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#address-space-integration">6. Address Space Integration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#system-address-map">6.1 System Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#pcie-bar-base-address-register-mapping">6.2 PCIe BAR (Base Address Register) Mapping</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#address-translation-stages">6.3 Address Translation Stages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#system-use-cases">7. System Use Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#use-case-1-model-initialization">7.1 Use Case 1: Model Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#use-case-2-inference-execution">7.2 Use Case 2: Inference Execution</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#use-case-3-package-to-package-communication">7.3 Use Case 3: Package-to-Package Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#use-case-4-system-management">7.4 Use Case 4: System Management</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_System_Architecture.html#appendices">8. Appendices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#acronyms-and-abbreviations">8.1 Acronyms and Abbreviations</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#reference-documents">8.2 Reference Documents</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_System_Architecture.html#revision-history">8.3 Revision History</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html">Keraunos PCIe Tile - High-Level Design Document</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#table-of-contents">Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#introduction">1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#purpose">1.1 Purpose</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#scope">1.2 Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#definitions-and-acronyms">1.3 Definitions and Acronyms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#architecture-overview">2. Architecture Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#top-level-architecture">2.1 Top-Level Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#design-principles">2.2 Design Principles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#block-diagram">3. Block Diagram</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#tile-level-block-diagram">3.1 Tile-Level Block Diagram</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#data-flow-paths">3.2 Data Flow Paths</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#module-descriptions">4. Module Descriptions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#noc-pcie-switch">4.1 NOC-PCIE Switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#noc-io-switch">4.2 NOC-IO Switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#smn-io-switch">4.3 SMN-IO Switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#translation-lookaside-buffers-tlbs">4.4 Translation Lookaside Buffers (TLBs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#msi-relay-unit">4.5 MSI Relay Unit</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#system-information-interface-sii-block">4.6 System Information Interface (SII) Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#configuration-register-block">4.7 Configuration Register Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#clock-and-reset-control">4.8 Clock and Reset Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#pcie-phy-model">4.9 PCIe PHY Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#pll-cgm-clock-generation-module">4.10 PLL/CGM (Clock Generation Module)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#interface-specifications">5. Interface Specifications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#external-tlm-sockets">5.1 External TLM Sockets</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#control-input-signals">5.2 Control Input Signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#output-signals">5.3 Output Signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#internal-signals">5.4 Internal Signals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#address-map">6. Address Map</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#inbound-address-map-pcie-noc-smn">6.1 Inbound Address Map (PCIe → NOC/SMN)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#configuration-address-map-smn">6.2 Configuration Address Map (SMN)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#msi-relay-address-map-0x18800000">6.3 MSI Relay Address Map (0x18800000)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#data-flow">7. Data Flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#inbound-data-flow-pcie-noc">7.1 Inbound Data Flow (PCIe → NOC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#outbound-data-flow-noc-pcie">7.2 Outbound Data Flow (NOC → PCIe)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#configuration-access-flow-smn-config-registers">7.3 Configuration Access Flow (SMN → Config Registers)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#msi-generation-flow-noc-pcie-via-msi-relay">7.4 MSI Generation Flow (NOC → PCIe via MSI Relay)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#cii-interrupt-flow-pcie-config-write-config-update">7.5 CII Interrupt Flow (PCIe Config Write → config_update)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#clock-and-reset-strategy">8. Clock and Reset Strategy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#clock-domains">8.1 Clock Domains</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#reset-strategy">8.2 Reset Strategy</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#power-on-initialization">8.3 Power-On Initialization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#configuration-and-control">9. Configuration and Control</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#tile-initialization-sequence">9.1 Tile Initialization Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#runtime-control">9.2 Runtime Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#status-monitoring">9.3 Status Monitoring</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#references">10. References</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#related-documents">10.1 Related Documents</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#source-code-organization">10.2 Source Code Organization</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#key-design-decisions">10.3 Key Design Decisions</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#known-limitations-and-findings">10.4 Known Limitations and Findings</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#appendix-a-signal-timing-diagrams">Appendix A: Signal Timing Diagrams</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#a-1-cii-interrupt-timing">A.1 CII Interrupt Timing</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#a-2-isolation-sequence">A.2 Isolation Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#a-3-cold-reset-cycle">A.3 Cold Reset Cycle</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#appendix-b-address-decode-examples">Appendix B: Address Decode Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#b-1-inbound-tlb-translation-tlb-sys-in0">B.1 Inbound TLB Translation (TLB Sys In0)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#b-2-status-register-access">B.2 Status Register Access</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#b-3-smn-config-write-address-passthrough-issue">B.3 SMN Config Write (Address Passthrough Issue)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#appendix-c-test-coverage-summary">Appendix C: Test Coverage Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html">Keraunos PCIE Tile SystemC/TLM2.0 Design Document</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#sphinx-setup-instructions">Sphinx Setup Instructions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#install-required-extensions">1. Install Required Extensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configure-conf-py">2. Configure <code class="docutils literal notranslate"><span class="pre">conf.py</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#build-html-documentation">3. Build HTML Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#alternative-use-make">4. Alternative: Use make</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#key-implementation-features">⭐ Key Implementation Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#table-of-contents">Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#introduction">1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#purpose">1.1 Purpose</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scope">1.2 Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#references">1.3 References</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#implementation-version">1.4 Implementation Version</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#refactored-architecture-overview-new">1.5 Refactored Architecture Overview ⭐ NEW</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#why-refactoring-was-necessary">1.5.1 Why Refactoring Was Necessary</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#refactored-architecture-pattern">1.5.2 Refactored Architecture Pattern</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#original-design-socket-based">Original Design (Socket-Based):</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#refactored-design-function-based">Refactored Design (Function-Based):</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#function-callback-communication-pattern">1.5.3 Function Callback Communication Pattern</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#callback-type-definition">Callback Type Definition:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#setting-up-callbacks-wire-components">Setting Up Callbacks (Wire Components):</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#benefits-of-function-callbacks">Benefits of Function Callbacks:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#smart-pointer-memory-management">1.5.4 Smart Pointer Memory Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scml2-memory-integration">1.5.5 SCML2 Memory Integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#temporal-decoupling-support">1.5.6 Temporal Decoupling Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#modern-c-best-practices-applied">1.5.7 Modern C++ Best Practices Applied</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#file-organization">1.5.8 File Organization</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#component-communication-pattern">1.5.9 Component Communication Pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#null-safety-pattern">1.5.10 Null Safety Pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#performance-characteristics">1.5.11 Performance Characteristics</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#code-example-complete-transaction-path">1.5.12 Code Example - Complete Transaction Path</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#system-overview">2. System Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#keraunos-pcie-tile-context">2.1 Keraunos PCIE Tile Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#modeled-components">2.2 Modeled Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#design-objectives">2.3 Design Objectives</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#architecture">3. Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#overall-structure">3.1 Overall Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#component-hierarchy">3.2 Component Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#data-flow">3.3 Data Flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-traffic-flow">Inbound Traffic Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#outbound-traffic-flow">Outbound Traffic Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-flow">MSI Flow</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#component-design">4. Component Design</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlb-common-structures">4.1 TLB Common Structures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbentry-structure">4.1.1 TlbEntry Structure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-tlb-design">4.2 Inbound TLB Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#overview-and-use-cases">4.2.1 Overview and Use Cases</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbsysin0-system-management-inbound-tlb">4.2.2 TLBSysIn0 - System Management Inbound TLB</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbappin0-application-inbound-tlb-bar0-1">4.2.3 TLBAppIn0 - Application Inbound TLB (BAR0/1)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbappin1-application-inbound-tlb-bar4-5">4.2.4 TLBAppIn1 - Application Inbound TLB (BAR4/5)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-tlb-translation-flow">4.2.5 Inbound TLB Translation Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#address-translation-examples">4.2.6 Address Translation Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#axuser-field-format">4.2.7 AxUSER Field Format</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-and-initialization">4.2.8 Configuration and Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#error-handling">4.2.9 Error Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#integration-with-system">4.2.10 Integration with System</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#outbound-tlb-design">4.3 Outbound TLB Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id1">4.3.1 Overview and Use Cases</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbsysout0-system-management-outbound-tlb">4.3.2 TLBSysOut0 - System Management Outbound TLB</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbappout0-application-outbound-tlb-high-address">4.3.3 TLBAppOut0 - Application Outbound TLB (High Address)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbappout1-application-outbound-tlb-dbi-access">4.3.4 TLBAppOut1 - Application Outbound TLB (DBI Access)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#outbound-tlb-translation-flow">4.3.5 Outbound TLB Translation Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id2">4.3.6 Address Translation Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id3">4.3.7 Configuration and Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id4">4.3.8 Error Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id5">4.3.9 Integration with System</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-relay-unit-design">4.4 MSI Relay Unit Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#overview">4.4.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id6">4.4.2 Architecture</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-x-table-entry">4.4.3 MSI-X Table Entry</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pending-bit-array-pba">4.4.4 Pending Bit Array (PBA)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-thrower-logic">4.4.5 MSI Thrower Logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#register-map">4.4.6 Register Map</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#intra-tile-fabric-switch-design">4.5 Intra-Tile Fabric Switch Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#noc-pcie-switch">4.5.1 NOC-PCIE Switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#noc-io-switch">4.5.2 NOC-IO Switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#smn-io-switch">4.5.3 SMN-IO Switch</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#system-information-interface-sii-block">4.6 System Information Interface (SII) Block</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id7">4.6.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#architecture-and-operation">4.6.2 Architecture and Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#cii-tracking-implementation">4.6.3 CII Tracking Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id8">4.6.4 Register Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#clock-domain-crossing">4.6.5 Clock Domain Crossing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#interrupt-generation-and-routing">4.6.6 Interrupt Generation and Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#interface-specification">4.6.7 Interface Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#implementation-details">4.6.8 Implementation Details</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-register-block">4.7 Configuration Register Block</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id9">4.7.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#status-registers">4.7.2 Status Registers</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#isolation-behavior">4.7.3 Isolation Behavior</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#clock-reset-control-module">4.8 Clock &amp; Reset Control Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id10">4.8.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#clock-domains">4.8.2 Clock Domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#reset-sequence">4.8.3 Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#interface">4.8.4 Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pll-cgm-clock-generation-module">4.9 PLL/CGM (Clock Generation Module)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id11">4.9.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pll-lock">4.9.2 PLL Lock</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id12">4.9.3 Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pcie-phy-model">4.10 PCIE PHY Model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id13">4.10.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#features">4.10.2 Features</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id14">4.10.3 Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#external-interface-modules">4.11 External Interface Modules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#noc-n-interface">4.11.1 NOC-N Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#smn-n-interface">4.11.2 SMN-N Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#top-level-keraunos-pcie-tile-module">4.12 Top-Level Keraunos PCIE Tile Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id15">4.12.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#external-interfaces">4.12.2 External Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#internal-connections">4.12.3 Internal Connections</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#interface-specifications">5. Interface Specifications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlm2-0-interfaces">5.1 TLM2.0 Interfaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#axi4-target-socket-inbound-tlbs">5.1.1 AXI4 Target Socket (Inbound TLBs)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#axi4-initiator-socket-all-tlbs">5.1.2 AXI4 Initiator Socket (All TLBs)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#apb-target-socket-configuration">5.1.3 APB Target Socket (Configuration)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#axi4-lite-initiator-socket-msi-relay">5.1.4 AXI4-Lite Initiator Socket (MSI Relay)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#systemc-signals">5.2 SystemC Signals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#control-signals">5.2.1 Control Signals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#address-translation-interfaces">5.3 Address Translation Interfaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlb-lookup-methods">5.3.1 TLB Lookup Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-methods">5.3.2 Configuration Methods</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id16">6. Implementation Details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#address-translation-algorithms">6.1 Address Translation Algorithms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-translation-tlbsysin0">6.1.1 Inbound Translation (TLBSysIn0)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#outbound-translation-tlbappout0">6.1.2 Outbound Translation (TLBAppOut0)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id17">6.2 Error Handling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#invalid-tlb-entry">6.2.1 Invalid TLB Entry</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#out-of-range-index">6.2.2 Out-of-Range Index</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-relay-unit-state-machine">6.3 MSI Relay Unit State Machine</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#threading-model">6.4 Threading Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#memory-modeling">6.5 Memory Modeling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#modeling-approach">7. Modeling Approach</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#abstraction-level">7.1 Abstraction Level</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scml2-usage">7.2 SCML2 Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#socket-type-selection-rationale">7.2.1 Socket Type Selection Rationale</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlm2-0-compliance">7.3 TLM2.0 Compliance</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#design-patterns">7.4 Design Patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#performance-considerations">8. Performance Considerations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#simulation-performance">8.1 Simulation Performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#optimization-opportunities">8.2 Optimization Opportunities</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scalability">8.3 Scalability</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#dependencies-and-requirements">9. Dependencies and Requirements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#software-dependencies">9.1 Software Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#hardware-dependencies">9.2 Hardware Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#integration-requirements">9.3 Integration Requirements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#detailed-implementation-architecture">9. Detailed Implementation Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#class-hierarchy-and-relationships">9.1 Class Hierarchy and Relationships</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#top-level-module-only-sc-module">Top-Level Module (Only sc_module):</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#internal-component-pattern">Internal Component Pattern:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#communication-architecture">9.2 Communication Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#transaction-flow-pattern">Transaction Flow Pattern:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#memory-management-architecture">9.3 Memory Management Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#smart-pointer-ownership-tree">Smart Pointer Ownership Tree:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#callback-wiring-implementation">9.4 Callback Wiring Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#complete-wiring-example">Complete Wiring Example:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scml2-memory-usage-pattern">9.5 SCML2 Memory Usage Pattern</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-storage-implementation">Configuration Storage Implementation:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#component-lifecycle">9.6 Component Lifecycle</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#initialization-sequence">Initialization Sequence:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#transaction-processing-flow">9.7 Transaction Processing Flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-pcie-transaction-example">Inbound PCIe Transaction Example:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#routing-decision-implementation">9.8 Routing Decision Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#noc-pcie-switch-routing-logic">NOC-PCIE Switch Routing Logic:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlb-translation-implementation">9.9 TLB Translation Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#translation-algorithm">Translation Algorithm:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#error-handling-strategy">9.10 Error Handling Strategy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#layered-error-response">Layered Error Response:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-register-implementation">9.11 Configuration Register Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#register-access-pattern">Register Access Pattern:</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#implementation-guide">10. Implementation Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#building-the-design">10.1 Building the Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#prerequisites">Prerequisites:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#build-commands">Build Commands:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#build-output">Build Output:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#running-tests">10.2 Running Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#unit-tests-auto-generated">Unit Tests (Auto-Generated):</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-coverage">Test Coverage:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#adding-new-components">10.3 Adding New Components</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pattern-for-c-class-components">Pattern for C++ Class Components:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#debugging-and-troubleshooting">10.4 Debugging and Troubleshooting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#common-issues-and-solutions">Common Issues and Solutions:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#debug-tools">Debug Tools:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#performance-tuning">10.5 Performance Tuning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#temporal-decoupling-configuration">Temporal Decoupling Configuration:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#adding-timing-annotations">Adding Timing Annotations:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-development-guide">10.6 Test Development Guide</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#adding-new-test-cases">Adding New Test Cases:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-management">10.7 Configuration Management</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlb-configuration-example">TLB Configuration Example:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#integration-with-vdk-platform">10.8 Integration with VDK Platform</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#module-instantiation-in-platform">Module Instantiation in Platform:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#memory-management-best-practices">10.9 Memory Management Best Practices</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#raii-pattern-already-applied">RAII Pattern (Already Applied):</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#coding-standards-applied">10.10 Coding Standards Applied</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#modern-c-17-features-used">Modern C++17 Features Used:</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-infrastructure">11. Test Infrastructure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-framework-overview">11.1 Test Framework Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-categories-33-tests">11.2 Test Categories (33 Tests)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-execution-results">11.3 Test Execution Results</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-api-examples">11.4 Test API Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#coverage-goals">11.5 Coverage Goals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#migration-from-original-design">12. Migration from Original Design</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#for-developers-familiar-with-original">12.1 For Developers Familiar with Original</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#api-migration-guide">12.2 API Migration Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#backward-compatibility-notes">12.3 Backward Compatibility Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#known-limitations-and-future-work">13. Known Limitations and Future Work</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#current-limitations">13.1 Current Limitations</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#future-enhancements">13.2 Future Enhancements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#lessons-learned-and-best-practices">14. Lessons Learned and Best Practices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#architecture-decisions">14.1 Architecture Decisions</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#design-patterns-applied">14.2 Design Patterns Applied</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#recommendations-for-similar-projects">14.3 Recommendations for Similar Projects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#appendix-a-implemented-components-summary">Appendix A: Implemented Components Summary</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#a-1-complete-component-list">A.1 Complete Component List</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#a-2-component-statistics">A.2 Component Statistics</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#a-3-scml-compliance">A.3 SCML Compliance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#appendix-b-address-map-summary">Appendix B: Address Map Summary</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-1-tlb-configuration-space">B.1 TLB Configuration Space</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-2-msi-relay-unit-address-map">B.2 MSI Relay Unit Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-3-sii-block-address-map">B.3 SII Block Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-4-config-register-block-address-map">B.4 Config Register Block Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-5-smn-io-switch-address-map">B.5 SMN-IO Switch Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-6-noc-io-switch-address-map">B.6 NOC-IO Switch Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-7-noc-pcie-switch-routing-map">B.7 NOC-PCIE Switch Routing Map</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#appendix-c-acronyms-and-abbreviations">Appendix C: Acronyms and Abbreviations</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Keraunos PCIE Tile SystemC/TLM2.0 Testplan</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#table-of-contents">Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="#introduction">1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#purpose">1.1 Purpose</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scope">1.2 Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test-objectives">1.3 Test Objectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#references">1.4 References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#test-traceability-matrix">1.5 Test Traceability Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="#test-environment">2. Test Environment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#testbench-structure">2.1 Testbench Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test-components">2.2 Test Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test-tools">2.3 Test Tools</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#test-strategy">3. Test Strategy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#test-levels">3.1 Test Levels</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test-methodology">3.2 Test Methodology</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test-phases">3.3 Test Phases</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#inbound-tlb-test-cases">4. Inbound TLB Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tlbsysin0-test-cases">4.1 TLBSysIn0 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-inbound-sys-001-basic-address-translation">TC_INBOUND_SYS_001: Basic Address Translation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-inbound-sys-002-invalid-entry-detection">TC_INBOUND_SYS_002: Invalid Entry Detection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-inbound-sys-003-index-calculation">TC_INBOUND_SYS_003: Index Calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-inbound-sys-004-page-boundary-crossing">TC_INBOUND_SYS_004: Page Boundary Crossing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-inbound-sys-005-axuser-field-mapping">TC_INBOUND_SYS_005: AxUSER Field Mapping</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-inbound-sys-006-system-ready-bypass">TC_INBOUND_SYS_006: System Ready Bypass</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tlbappin0-test-cases">4.2 TLBAppIn0 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-inbound-app0-001-bar0-1-translation">TC_INBOUND_APP0_001: BAR0/1 Translation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-inbound-app0-002-multiple-instance-support">TC_INBOUND_APP0_002: Multiple Instance Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-inbound-app0-003-16mb-page-size">TC_INBOUND_APP0_003: 16MB Page Size</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-inbound-app0-004-non-cacheable-and-qosid">TC_INBOUND_APP0_004: Non-Cacheable and QoSID</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tlbappin1-test-cases">4.3 TLBAppIn1 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-inbound-app1-001-bar4-5-translation">TC_INBOUND_APP1_001: BAR4/5 Translation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-inbound-app1-002-8gb-page-size">TC_INBOUND_APP1_002: 8GB Page Size</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-inbound-app1-003-dram-mapping">TC_INBOUND_APP1_003: DRAM Mapping</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#outbound-tlb-test-cases">5. Outbound TLB Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tlbsysout0-test-cases">5.1 TLBSysOut0 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-outbound-sys-001-dbi-access-translation">TC_OUTBOUND_SYS_001: DBI Access Translation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-outbound-sys-002-64kb-page-size">TC_OUTBOUND_SYS_002: 64KB Page Size</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-outbound-sys-003-all-16-entries">TC_OUTBOUND_SYS_003: All 16 Entries</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tlbappout0-test-cases">5.2 TLBAppOut0 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-outbound-app0-001-high-address-translation-256tb">TC_OUTBOUND_APP0_001: High Address Translation (&gt;=256TB)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-outbound-app0-002-address-range-check">TC_OUTBOUND_APP0_002: Address Range Check</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-outbound-app0-003-16tb-page-size">TC_OUTBOUND_APP0_003: 16TB Page Size</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tlbappout1-test-cases">5.3 TLBAppOut1 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-outbound-app1-001-low-address-translation-256tb">TC_OUTBOUND_APP1_001: Low Address Translation (&lt;256TB)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-outbound-app1-002-dbi-access-from-application">TC_OUTBOUND_APP1_002: DBI Access from Application</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#msi-relay-unit-test-cases">6. MSI Relay Unit Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#register-access-tests">6.1 Register Access Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-msi-relay-001-msi-receiver-write">TC_MSI_RELAY_001: MSI Receiver Write</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-msi-relay-002-msi-x-table-configuration">TC_MSI_RELAY_002: MSI-X Table Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-msi-relay-003-outstanding-count">TC_MSI_RELAY_003: Outstanding Count</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#msi-generation-tests">6.2 MSI Generation Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-msi-relay-004-basic-msi-generation">TC_MSI_RELAY_004: Basic MSI Generation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-msi-relay-005-msi-x-enable-control">TC_MSI_RELAY_005: MSI-X Enable Control</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-msi-relay-006-global-mask-control">TC_MSI_RELAY_006: Global Mask Control</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-msi-relay-007-vector-mask-control">TC_MSI_RELAY_007: Vector Mask Control</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-msi-relay-008-invalid-entry-handling">TC_MSI_RELAY_008: Invalid Entry Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-msi-relay-009-multiple-pending-interrupts">TC_MSI_RELAY_009: Multiple Pending Interrupts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-msi-relay-010-setip-signal">TC_MSI_RELAY_010: SetIP Signal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-msi-relay-011-all-16-vectors">TC_MSI_RELAY_011: All 16 Vectors</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#integration-test-cases">7. Integration Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tlb-msi-relay-integration">7.1 TLB + MSI Relay Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-integration-001-msi-x-table-access-via-tlb">TC_INTEGRATION_001: MSI-X Table Access via TLB</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-integration-002-msi-generation-through-fabric">TC_INTEGRATION_002: MSI Generation Through Fabric</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-tlb-integration">7.2 Multiple TLB Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-integration-003-concurrent-tlb-operations">TC_INTEGRATION_003: Concurrent TLB Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-integration-004-outbound-inbound-round-trip">TC_INTEGRATION_004: Outbound + Inbound Round Trip</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#switch-test-cases">8. Switch Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#noc-pcie-switch-test-cases">8.1 NOC-PCIE Switch Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-switch-noc-pcie-001-address-routing-based-on-axaddr-63-60">TC_SWITCH_NOC_PCIE_001: Address Routing Based on AxADDR[63:60]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-switch-noc-pcie-002-status-register-special-routing">TC_SWITCH_NOC_PCIE_002: Status Register Special Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-switch-noc-pcie-003-isolation-support">TC_SWITCH_NOC_PCIE_003: Isolation Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-switch-noc-pcie-004-inbound-enable-control">TC_SWITCH_NOC_PCIE_004: Inbound Enable Control</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#enable-gating-test-cases-new-feb-2026">8.4 Enable Gating Test Cases (NEW - Feb 2026)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-negative-enable-001-inbound-enable-blocks-pcienoc-traffic">TC_NEGATIVE_ENABLE_001: Inbound Enable Blocks PCIe→NOC Traffic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-negative-enable-002-outbound-enable-blocks-nocpcie-traffic">TC_NEGATIVE_ENABLE_002: Outbound Enable Blocks NOC→PCIe Traffic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-negative-enable-003-both-enables-disabled-complete-isolation">TC_NEGATIVE_ENABLE_003: Both Enables Disabled - Complete Isolation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-negative-enable-004-both-enables-active-positive-control">TC_NEGATIVE_ENABLE_004: Both Enables Active - Positive Control</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#enable-gating-implementation-architecture">8.5 Enable Gating Implementation Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-switch-noc-pcie-005-bypass-path-routing">TC_SWITCH_NOC_PCIE_005: Bypass Path Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-switch-noc-pcie-006-address-conversion-64-bit-to-52-bit">TC_SWITCH_NOC_PCIE_006: Address Conversion (64-bit to 52-bit)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#noc-io-switch-test-cases">8.2 NOC-IO Switch Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-switch-noc-io-001-local-resource-routing">TC_SWITCH_NOC_IO_001: Local Resource Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-switch-noc-io-002-external-noc-routing">TC_SWITCH_NOC_IO_002: External NOC Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-switch-noc-io-003-high-address-routing-axaddr-51-48">TC_SWITCH_NOC_IO_003: High Address Routing (AxADDR[51:48])</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-switch-noc-io-004-timeout-detection">TC_SWITCH_NOC_IO_004: Timeout Detection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#smn-io-switch-test-cases">8.3 SMN-IO Switch Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-switch-smn-io-001-address-based-routing">TC_SWITCH_SMN_IO_001: Address-Based Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-switch-smn-io-002-serdes-routing">TC_SWITCH_SMN_IO_002: SerDes Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-switch-smn-io-003-external-smn-routing">TC_SWITCH_SMN_IO_003: External SMN Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-switch-smn-io-004-timeout-detection">TC_SWITCH_SMN_IO_004: Timeout Detection</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sii-block-test-cases">9. SII Block Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">9.1 Register Access Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-sii-001-configuration-register-access">TC_SII_001: Configuration Register Access</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-sii-002-cii-tracking">TC_SII_002: CII Tracking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-sii-003-bus-device-number-assignment">TC_SII_003: Bus/Device Number Assignment</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#config-register-block-test-cases">10. Config Register Block Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">10.1 Register Access Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-config-reg-001-tlb-configuration-space-access">TC_CONFIG_REG_001: TLB Configuration Space Access</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-config-reg-002-system-ready-register">TC_CONFIG_REG_002: System Ready Register</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-config-reg-003-pcie-enable-registers">TC_CONFIG_REG_003: PCIE Enable Registers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-config-reg-004-isolation-behavior">TC_CONFIG_REG_004: Isolation Behavior</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#clock-reset-test-cases">11. Clock &amp; Reset Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#clock-generation-tests">11.1 Clock Generation Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-clock-reset-001-reference-clock-generation">TC_CLOCK_RESET_001: Reference Clock Generation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-clock-reset-002-pcie-clock-generation">TC_CLOCK_RESET_002: PCIE Clock Generation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reset-sequence-tests">11.2 Reset Sequence Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-clock-reset-003-cold-reset-sequence">TC_CLOCK_RESET_003: Cold Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-clock-reset-004-warm-reset-sequence">TC_CLOCK_RESET_004: Warm Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-clock-reset-005-isolation-behavior">TC_CLOCK_RESET_005: Isolation Behavior</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pll-cgm-test-cases">12. PLL/CGM Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pll-lock-tests">12.1 PLL Lock Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-pll-cgm-001-pll-lock-sequence">TC_PLL_CGM_001: PLL Lock Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-pll-cgm-002-pll-configuration">TC_PLL_CGM_002: PLL Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pcie-phy-test-cases">13. PCIE PHY Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#phy-configuration-tests">13.1 PHY Configuration Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-phy-001-apb-configuration-access">TC_PHY_001: APB Configuration Access</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-phy-002-ahb-firmware-download">TC_PHY_002: AHB Firmware Download</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-phy-003-lane-reversal-support">TC_PHY_003: Lane Reversal Support</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#external-interface-test-cases">14. External Interface Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#noc-n-interface-tests">14.1 NOC-N Interface Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-external-noc-001-transaction-forwarding">TC_EXTERNAL_NOC_001: Transaction Forwarding</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#smn-n-interface-tests">14.2 SMN-N Interface Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-external-smn-001-transaction-forwarding">TC_EXTERNAL_SMN_001: Transaction Forwarding</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#top-level-integration-test-cases">15. Top-Level Integration Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#full-tile-integration">15.1 Full Tile Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-top-level-001-complete-reset-sequence">TC_TOP_LEVEL_001: Complete Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-top-level-002-end-to-end-transaction-flow">TC_TOP_LEVEL_002: End-to-End Transaction Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-top-level-003-msi-end-to-end-flow">TC_TOP_LEVEL_003: MSI End-to-End Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-top-level-004-isolation-sequence">TC_TOP_LEVEL_004: Isolation Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-top-level-005-multiple-clock-domain-operation">TC_TOP_LEVEL_005: Multiple Clock Domain Operation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#end-to-end-test-cases">16. End-to-End Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#inbound-data-paths-pcie-noc-smn">16.1 Inbound Data Paths (PCIe → NOC/SMN)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-inbound-001-pcie-read-tlb-app0-noc-n">TC_E2E_INBOUND_001: PCIe Read → TLB App0 → NOC-N</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-inbound-002-pcie-write-tlb-app1-noc-n">TC_E2E_INBOUND_002: PCIe Write → TLB App1 → NOC-N</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-inbound-003-pcie-tlb-sys-smn-n">TC_E2E_INBOUND_003: PCIe → TLB Sys → SMN-N</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-inbound-004-pcie-bypass-app-path">TC_E2E_INBOUND_004: PCIe Bypass App Path</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-inbound-005-pcie-bypass-sys-path">TC_E2E_INBOUND_005: PCIe Bypass Sys Path</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#outbound-data-paths-noc-smn-pcie">16.2 Outbound Data Paths (NOC/SMN → PCIe)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-outbound-001-noc-n-tlb-app-out0-pcie">TC_E2E_OUTBOUND_001: NOC-N → TLB App Out0 → PCIe</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-outbound-002-smn-n-tlb-sys-out0-pcie">TC_E2E_OUTBOUND_002: SMN-N → TLB Sys Out0 → PCIe</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-outbound-003-noc-n-tlb-app-out1-pcie-dbi">TC_E2E_OUTBOUND_003: NOC-N → TLB App Out1 → PCIe DBI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#configuration-paths-smn-tlb-sii-msi-config">16.3 Configuration Paths (SMN → TLB/SII/MSI Config)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-config-001-smn-n-tlb-config">TC_E2E_CONFIG_001: SMN-N → TLB Config</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-config-002-smn-n-sii-config">TC_E2E_CONFIG_002: SMN-N → SII Config</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-config-003-smn-n-msi-relay-config">TC_E2E_CONFIG_003: SMN-N → MSI Relay Config</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#msi-interrupt-flows">16.4 MSI Interrupt Flows</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-msi-001-msi-generation-noc-n">TC_E2E_MSI_001: MSI Generation → NOC-N</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-msi-002-downstream-msi-input-processing">TC_E2E_MSI_002: Downstream MSI Input → Processing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#status-register-access">16.5 Status Register Access</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-status-001-status-register-read-route-0xe">TC_E2E_STATUS_001: Status Register Read (Route 0xE)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-status-002-status-register-disabled-access">TC_E2E_STATUS_002: Status Register Disabled Access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#isolation-and-error-handling">16.6 Isolation and Error Handling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-isolation-001-global-isolation">TC_E2E_ISOLATION_001: Global Isolation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-isolation-002-config-access-during-isolation">TC_E2E_ISOLATION_002: Config Access During Isolation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#multi-path-concurrent-traffic">16.7 Multi-Path Concurrent Traffic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-concurrent-001-simultaneous-inbound-outbound">TC_E2E_CONCURRENT_001: Simultaneous Inbound + Outbound</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-concurrent-002-multiple-tlb-simultaneous-access">TC_E2E_CONCURRENT_002: Multiple TLB Simultaneous Access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reset-and-initialization-sequences">16.8 Reset and Initialization Sequences</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-reset-001-cold-reset-sequence">TC_E2E_RESET_001: Cold Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-reset-002-warm-reset-sequence">TC_E2E_RESET_002: Warm Reset Sequence</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#complete-transaction-flows">16.9 Complete Transaction Flows</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-flow-001-pcie-memory-read-noc-memory-response">TC_E2E_FLOW_001: PCIe Memory Read → NOC → Memory → Response</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-flow-002-pcie-memory-write-noc-memory-completion">TC_E2E_FLOW_002: PCIe Memory Write → NOC → Memory → Completion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-flow-003-noc-memory-read-pcie-controller">TC_E2E_FLOW_003: NOC Memory Read → PCIe Controller</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-flow-004-smn-config-write-pcie-dbi">TC_E2E_FLOW_004: SMN Config Write → PCIe DBI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#error-injection-and-recovery">16.10 Error Injection and Recovery</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-error-001-invalid-tlb-entry">TC_E2E_ERROR_001: Invalid TLB Entry</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-error-002-timeout-handling">TC_E2E_ERROR_002: Timeout Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-error-003-address-decode-error">TC_E2E_ERROR_003: Address Decode Error</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#msi-x-end-to-end-flow">16.11 MSI-X End-to-End Flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-msix-001-complete-msi-x-interrupt-flow">TC_E2E_MSIX_001: Complete MSI-X Interrupt Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-msix-002-multiple-vector-interrupts">TC_E2E_MSIX_002: Multiple Vector Interrupts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#clock-domain-crossing">16.12 Clock Domain Crossing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-cdc-001-axi-clock-pcie-clock">TC_E2E_CDC_001: AXI Clock → PCIe Clock</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#performance-and-stress-tests">16.13 Performance and Stress Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-perf-001-maximum-throughput-test">TC_E2E_PERF_001: Maximum Throughput Test</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-stress-001-address-space-sweep">TC_E2E_STRESS_001: Address Space Sweep</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-stress-002-tlb-entry-exhaustion">TC_E2E_STRESS_002: TLB Entry Exhaustion</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#power-management">16.14 Power Management</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-power-001-isolation-mode-entry-exit">TC_E2E_POWER_001: Isolation Mode Entry/Exit</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#system-integration-scenarios">16.15 System Integration Scenarios</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-system-001-boot-sequence">TC_E2E_SYSTEM_001: Boot Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-system-002-shutdown-sequence">TC_E2E_SYSTEM_002: Shutdown Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-system-003-error-recovery-scenario">TC_E2E_SYSTEM_003: Error Recovery Scenario</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#refactored-architecture-validation">16.16 Refactored Architecture Validation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-refactor-001-function-callback-chain">TC_E2E_REFACTOR_001: Function Callback Chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tc-e2e-refactor-002-no-internal-sockets-remain">TC_E2E_REFACTOR_002: No Internal Sockets Remain</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#coverage-goals">17. Coverage Goals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">16. Coverage Goals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#functional-coverage">16.1 Functional Coverage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tlb-coverage">TLB Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#msi-relay-coverage">MSI Relay Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#switch-coverage">Switch Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sii-coverage">SII Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#config-register-coverage">Config Register Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#clock-reset-coverage">Clock/Reset Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#phy-coverage">PHY Coverage</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#code-coverage">16.2 Code Coverage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#specification-coverage">16.3 Specification Coverage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#test-infrastructure">17. Test Infrastructure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#testbench-components">9.1 Testbench Components</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#stimulus-generator">Stimulus Generator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#monitor">Monitor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reference-model">Reference Model</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#test-utilities">9.2 Test Utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test-configuration">9.3 Test Configuration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#regression-testing">18. Regression Testing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#regression-suite">10.1 Regression Suite</a></li>
<li class="toctree-l3"><a class="reference internal" href="#regression-criteria">10.2 Regression Criteria</a></li>
<li class="toctree-l3"><a class="reference internal" href="#continuous-integration">10.3 Continuous Integration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#appendix-a-unit-integration-test-case-summary-sections-4-15">Appendix A: Unit/Integration Test Case Summary (Sections 4-15)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#appendix-a-2-end-to-end-test-case-summary-section-16-implemented-in-keranous-pcie-tiletest-cc">Appendix A.2: End-to-End Test Case Summary (Section 16) — Implemented in <code class="docutils literal notranslate"><span class="pre">Keranous_pcie_tileTest.cc</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#appendix-b-test-execution-plan">Appendix B: Test Execution Plan</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#phase-1-unit-tests-weeks-1-3">Phase 1: Unit Tests (Weeks 1-3)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#phase-2-functional-tests-weeks-4-5">Phase 2: Functional Tests (Weeks 4-5)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#phase-3-integration-tests-weeks-6-7">Phase 3: Integration Tests (Weeks 6-7)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#phase-4-system-tests-week-8">Phase 4: System Tests (Week 8)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#phase-5-regression-week-9">Phase 5: Regression (Week 9)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ENABLE_GATING_DESIGN.html">Enable Gating Feature - Design Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#register-interface">Register Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#implementation">Implementation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#signal-propagation">Signal Propagation</a></li>
<li class="toctree-l3"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#key-features">Key Features</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#test-coverage">Test Coverage</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Keraunos PCIe Tile</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Keraunos PCIE Tile SystemC/TLM2.0 Testplan</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Keraunos_PCIE_Tile_Testplan.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="keraunos-pcie-tile-systemc-tlm2-0-testplan">
<h1>Keraunos PCIE Tile SystemC/TLM2.0 Testplan<a class="headerlink" href="#keraunos-pcie-tile-systemc-tlm2-0-testplan" title="Permalink to this heading"></a></h1>
<p><strong>Version:</strong> 2.1<br />
<strong>Date:</strong> February 10, 2026<br />
<strong>Author:</strong> Verification Team<br />
<strong>Based on:</strong> Keraunos PCIE Tile Specification v0.7.023<br />
<strong>Updated:</strong> 81 tests passing, cross-socket data verification via sparse_backing_memory, DUT initiator socket architecture</p>
<hr class="docutils" />
<section id="table-of-contents">
<h2>Table of Contents<a class="headerlink" href="#table-of-contents" title="Permalink to this heading"></a></h2>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#introduction"><span class="std std-doc">Introduction</span></a></p></li>
<li><p><a class="reference internal" href="#test-environment"><span class="std std-doc">Test Environment</span></a></p></li>
<li><p><a class="reference internal" href="#test-strategy"><span class="std std-doc">Test Strategy</span></a></p></li>
<li><p><a class="reference internal" href="#inbound-tlb-test-cases"><span class="std std-doc">Inbound TLB Test Cases</span></a></p></li>
<li><p><a class="reference internal" href="#outbound-tlb-test-cases"><span class="std std-doc">Outbound TLB Test Cases</span></a></p></li>
<li><p><a class="reference internal" href="#msi-relay-unit-test-cases"><span class="std std-doc">MSI Relay Unit Test Cases</span></a></p></li>
<li><p><a class="reference internal" href="#integration-test-cases"><span class="std std-doc">Integration Test Cases</span></a></p></li>
<li><p><a class="reference internal" href="#switch-test-cases"><span class="std std-doc">Switch Test Cases</span></a></p></li>
<li><p><a class="reference internal" href="#sii-block-test-cases"><span class="std std-doc">SII Block Test Cases</span></a></p></li>
<li><p><a class="reference internal" href="#config-register-block-test-cases"><span class="std std-doc">Config Register Block Test Cases</span></a></p></li>
<li><p><a class="reference internal" href="#clock-reset-test-cases"><span class="std std-doc">Clock &amp; Reset Test Cases</span></a></p></li>
<li><p><a class="reference internal" href="#pll-cgm-test-cases"><span class="std std-doc">PLL/CGM Test Cases</span></a></p></li>
<li><p><a class="reference internal" href="#pcie-phy-test-cases"><span class="std std-doc">PCIE PHY Test Cases</span></a></p></li>
<li><p><a class="reference internal" href="#external-interface-test-cases"><span class="std std-doc">External Interface Test Cases</span></a></p></li>
<li><p><a class="reference internal" href="#top-level-integration-test-cases"><span class="std std-doc">Top-Level Integration Test Cases</span></a></p></li>
<li><p><a class="reference internal" href="#end-to-end-test-cases"><span class="std std-doc">End-to-End Test Cases</span></a></p></li>
<li><p><a class="reference internal" href="#coverage-goals"><span class="std std-doc">Coverage Goals</span></a></p></li>
<li><p><span class="xref myst">Test Infrastructure</span></p></li>
<li><p><span class="xref myst">Regression Testing</span></p></li>
</ol>
</section>
<hr class="docutils" />
<section id="introduction">
<h2>1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<section id="purpose">
<h3>1.1 Purpose<a class="headerlink" href="#purpose" title="Permalink to this heading"></a></h3>
<p>This testplan defines comprehensive test cases for verifying the SystemC/TLM2.0 implementation of:</p>
<ul class="simple">
<li><p><strong>Inbound TLBs</strong> (TLBSysIn0, TLBAppIn0, TLBAppIn1)</p></li>
<li><p><strong>Outbound TLBs</strong> (TLBSysOut0, TLBAppOut0, TLBAppOut1)</p></li>
<li><p><strong>MSI Relay Unit</strong></p></li>
<li><p><strong>Intra-Tile Fabric Switches</strong> (NOC-PCIE, NOC-IO, SMN-IO)</p></li>
<li><p><strong>System Information Interface (SII) Block</strong></p></li>
<li><p><strong>Configuration Register Block</strong></p></li>
<li><p><strong>Clock &amp; Reset Control Module</strong></p></li>
<li><p><strong>PLL/CGM (Clock Generation Module)</strong></p></li>
<li><p><strong>PCIE PHY Model</strong></p></li>
<li><p><strong>External Interface Modules</strong> (NOC-N, SMN-N)</p></li>
<li><p><strong>Top-Level Keraunos PCIE Tile Integration</strong></p></li>
</ul>
</section>
<section id="scope">
<h3>1.2 Scope<a class="headerlink" href="#scope" title="Permalink to this heading"></a></h3>
<p>This testplan covers:</p>
<ul class="simple">
<li><p>Functional correctness of address translation</p></li>
<li><p>Register access and configuration</p></li>
<li><p>Error handling and edge cases</p></li>
<li><p>MSI interrupt delivery</p></li>
<li><p>Switch routing and address decoding</p></li>
<li><p>Clock and reset sequences</p></li>
<li><p>Isolation and timeout handling</p></li>
<li><p>Integration scenarios</p></li>
<li><p>Performance and stress testing</p></li>
</ul>
</section>
<section id="test-objectives">
<h3>1.3 Test Objectives<a class="headerlink" href="#test-objectives" title="Permalink to this heading"></a></h3>
<ol class="arabic simple">
<li><p>Verify address translation algorithms match specification</p></li>
<li><p>Validate error handling for invalid TLB entries</p></li>
<li><p>Confirm MSI Relay Unit interrupt delivery mechanism</p></li>
<li><p>Ensure proper AxUSER field mapping</p></li>
<li><p>Validate register access and configuration interfaces</p></li>
<li><p>Test integration with intra-tile fabric</p></li>
</ol>
</section>
<section id="references">
<h3>1.4 References<a class="headerlink" href="#references" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Keraunos PCIE Tile Specification v0.7.023</p></li>
<li><p>SystemC/TLM2.0 Design Document</p></li>
<li><p>PCI Express Base Specification 6.0</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="test-traceability-matrix">
<h2>1.5 Test Traceability Matrix<a class="headerlink" href="#test-traceability-matrix" title="Permalink to this heading"></a></h2>
<p>The following table maps test plan IDs to their implementing test functions in <code class="docutils literal notranslate"><span class="pre">Keranous_pcie_tileTest.cc</span></code>. <strong>81 tests total: 81 passing, 0 failing. Cross-socket data verification enabled via sparse_backing_memory.</strong> The 4 new negative enable tests verify independent control of inbound/outbound traffic gating.</p>
<p><strong>E2E Tests (41 tests):</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#</p></th>
<th class="head"><p>Test Plan ID</p></th>
<th class="head"><p>Test Function (<code class="docutils literal notranslate"><span class="pre">Keranous_pcie_tileTest.cc</span></code>)</p></th>
<th class="head"><p>Feature Under Test</p></th>
<th class="head"><p>Status</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p><em>(sanity)</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testAlwaysSucceeds()</span></code></p></td>
<td><p>Framework sanity check</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>TC_E2E_INBOUND_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieRead_TlbApp0_NocN()</span></code></p></td>
<td><p>Inbound Read: PCIe → TLB App In0 → NOC-N</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>TC_E2E_INBOUND_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN()</span></code></p></td>
<td><p>Inbound Write: PCIe → TLB App In1 → NOC-N</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>TC_E2E_INBOUND_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_Pcie_TlbSys_SmnN()</span></code></p></td>
<td><p>System Mgmt Path: PCIe → TLB Sys In0 → SMN-N</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>TC_E2E_INBOUND_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassApp()</span></code></p></td>
<td><p>Bypass App Path (route=0x8, no TLB)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>TC_E2E_INBOUND_005</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassSys()</span></code></p></td>
<td><p>Bypass Sys Path (route=0x9, no TLB)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>TC_E2E_OUTBOUND_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut0_Pcie()</span></code></p></td>
<td><p>Outbound Read: NOC-N → TLB App Out0 → PCIe</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>TC_E2E_OUTBOUND_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_SmnN_TlbSysOut0_Pcie()</span></code></p></td>
<td><p>DBI Write: SMN-N → TLB Sys Out0 → PCIe</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>TC_E2E_OUTBOUND_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut1_PcieDBI()</span></code></p></td>
<td><p>DBI Read: NOC-N → TLB App Out1 → PCIe DBI</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>10</p></td>
<td><p>TC_E2E_CONFIG_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToTlb()</span></code></p></td>
<td><p>TLB Configuration via SMN</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>11</p></td>
<td><p>TC_E2E_CONFIG_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToSII()</span></code></p></td>
<td><p>SII Configuration via SMN</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>12</p></td>
<td><p>TC_E2E_CONFIG_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToMsiRelay()</span></code></p></td>
<td><p>MSI Relay Configuration via SMN</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>13</p></td>
<td><p>TC_E2E_MSI_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN()</span></code></p></td>
<td><p>MSI Generation and Routing to NOC-N</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>14</p></td>
<td><p>TC_E2E_MSI_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_DownstreamInput_Processing()</span></code></p></td>
<td><p>Downstream MSI Input Processing</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>15</p></td>
<td><p>TC_E2E_MSIX_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_MultipleVectors()</span></code></p></td>
<td><p>Multiple MSI-X Vector Configuration</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>TC_E2E_STATUS_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_Read_Route0xE()</span></code></p></td>
<td><p>Status Register Special Routing (route=0xE)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>17</p></td>
<td><p>TC_E2E_STATUS_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_DisabledAccess()</span></code></p></td>
<td><p>Status Register Access Control (system not ready)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>18</p></td>
<td><p>TC_E2E_ISOLATION_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_GlobalBlock()</span></code></p></td>
<td><p>Global Isolation: Block All Data Traffic</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>19</p></td>
<td><p>TC_E2E_ISOLATION_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_ConfigAccessAllowed()</span></code></p></td>
<td><p>Config Access Allowed During Isolation</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>20</p></td>
<td><p>TC_E2E_ERROR_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_InvalidTlbEntry()</span></code></p></td>
<td><p>TLB Error Handling and Recovery</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>21</p></td>
<td><p>TC_E2E_ERROR_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_AddressDecodeError()</span></code></p></td>
<td><p>Address Decode Error (DECERR) Handling</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>22</p></td>
<td><p>TC_E2E_CONCURRENT_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_InboundOutbound()</span></code></p></td>
<td><p>Concurrent Bidirectional Traffic</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>23</p></td>
<td><p>TC_E2E_CONCURRENT_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_MultipleTlbs()</span></code></p></td>
<td><p>Multiple TLB Array Concurrent Access</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>24</p></td>
<td><p>TC_E2E_RESET_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_ColdResetSequence()</span></code></p></td>
<td><p>Cold Reset Sequence and Recovery</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>25</p></td>
<td><p>TC_E2E_RESET_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_WarmResetSequence()</span></code></p></td>
<td><p>Warm Reset (Config Preserved)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>26</p></td>
<td><p>TC_E2E_FLOW_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryRead_Complete()</span></code></p></td>
<td><p>Complete PCIe Memory Read Flow</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>27</p></td>
<td><p>TC_E2E_FLOW_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryWrite_Complete()</span></code></p></td>
<td><p>Complete PCIe Memory Write Flow</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>28</p></td>
<td><p>TC_E2E_FLOW_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_NocMemoryRead_ToPcie()</span></code></p></td>
<td><p>Outbound Read: NOC → PCIe Memory Read</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>29</p></td>
<td><p>TC_E2E_FLOW_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_SmnConfigWrite_PcieDBI()</span></code></p></td>
<td><p>SMN Config Write to PCIe DBI</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>30</p></td>
<td><p>TC_E2E_REFACTOR_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Refactor_FunctionCallbackChain()</span></code></p></td>
<td><p>Function Callback Chain Validation</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>31</p></td>
<td><p>TC_E2E_REFACTOR_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Refactor_NoInternalSockets_E126Check()</span></code></p></td>
<td><p>E126 Error Elimination Validation</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>32</p></td>
<td><p>TC_E2E_SYSTEM_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_BootSequence()</span></code></p></td>
<td><p>Complete Boot/Initialization Sequence</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>33</p></td>
<td><p>TC_E2E_SYSTEM_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_ErrorRecovery()</span></code></p></td>
<td><p>Error Injection and Recovery</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>34</p></td>
<td><p>TC_E2E_MSIX_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_CompleteMsixInterruptFlow()</span></code></p></td>
<td><p>Complete MSI-X Interrupt Config, Generation, Delivery</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>35</p></td>
<td><p>TC_E2E_ERROR_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_TimeoutHandling()</span></code></p></td>
<td><p>Timeout Detection and Recovery</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>36</p></td>
<td><p>TC_E2E_CDC_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_CDC_AxiToPcieClock()</span></code></p></td>
<td><p>Clock Domain Crossing (AXI ↔ PCIe Core)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>37</p></td>
<td><p>TC_E2E_PERF_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Perf_MaximumThroughput()</span></code></p></td>
<td><p>Maximum Transaction Rate (Back-to-Back Burst)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>38</p></td>
<td><p>TC_E2E_STRESS_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Stress_AddressSpaceSweep()</span></code></p></td>
<td><p>Complete Address Space Routing Sweep</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>39</p></td>
<td><p>TC_E2E_STRESS_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Stress_TlbEntryExhaustion()</span></code></p></td>
<td><p>Full TLB Capacity (64 Entries) + Dynamic Reconfig</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>40</p></td>
<td><p>TC_E2E_POWER_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Power_IsolationModeEntryExit()</span></code></p></td>
<td><p>Power Management Isolation Entry/Exit</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>41</p></td>
<td><p>TC_E2E_SYSTEM_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_ShutdownSequence()</span></code></p></td>
<td><p>Graceful Shutdown Sequence</p></td>
<td><p>✅ PASS</p></td>
</tr>
</tbody>
</table>
<p><strong>Directed Tests (28 tests):</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#</p></th>
<th class="head"><p>Test Plan ID(s)</p></th>
<th class="head"><p>Test Function (<code class="docutils literal notranslate"><span class="pre">Keranous_pcie_tileTest.cc</span></code>)</p></th>
<th class="head"><p>Feature Under Test</p></th>
<th class="head"><p>Status</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>42</p></td>
<td><p>TC_SWITCH_NOC_PCIE_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_RouteDecodeErrors()</span></code></p></td>
<td><p>NOC-PCIE switch: 9 unmapped route values → DECERR</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>43</p></td>
<td><p>TC_SWITCH_NOC_PCIE_003/004 + TC_CONFIG_REG_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_InboundEnableGating()</span></code></p></td>
<td><p>Comprehensive isolation test with <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code>: verifies inbound/bypass/status blocked during isolation, enables permanently cleared after deassert (runs last)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>44</p></td>
<td><p>TC_NEGATIVE_ENABLE_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testNegative_InboundDisabled_BlocksPcieToNoc()</span></code></p></td>
<td><p>Inbound enable gating: pcie_inbound_app_enable=0 blocks PCIe→NOC traffic, outbound still flows</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>45</p></td>
<td><p>TC_NEGATIVE_ENABLE_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testNegative_OutboundDisabled_BlocksNocToPcie()</span></code></p></td>
<td><p>Outbound enable gating: pcie_outbound_app_enable=0 blocks NOC→PCIe traffic, inbound still flows</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>46</p></td>
<td><p>TC_NEGATIVE_ENABLE_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testNegative_BothDisabled_BlocksBidirectional()</span></code></p></td>
<td><p>Both enables=0: complete traffic isolation while system_ready=1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>47</p></td>
<td><p>TC_NEGATIVE_ENABLE_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testNegative_BothEnabled_AllowsBidirectional()</span></code></p></td>
<td><p>Positive control: both enables=1 allows full bidirectional traffic with stress test</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>48</p></td>
<td><p>TC_SWITCH_NOC_IO_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_NocIoDecErrRegions()</span></code></p></td>
<td><p>NOC-IO switch: 3 DECERR regions verified</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>49</p></td>
<td><p>TC_SWITCH_NOC_PCIE_005</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_BypassPathRouting()</span></code></p></td>
<td><p>Bypass paths (route=0x8/0x9) with <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code>: cold reset cycling harmless</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>50</p></td>
<td><p>TC_SWITCH_SMN_IO_001/002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_SmnIoAllTargets()</span></code></p></td>
<td><p>SMN-IO switch: all 15 routing targets exercised</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>51</p></td>
<td><p>TC_CONFIG_REG_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_ConfigReg_StatusReadback()</span></code></p></td>
<td><p>Status register readback via PCIe route 0xE</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>52</p></td>
<td><p>TC_CONFIG_REG_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_ConfigReg_IsolationClearsAll()</span></code></p></td>
<td><p>Config reg defaults + cold reset with <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code>: status/data preserved across reset</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>53</p></td>
<td><p>TC_INBOUND_SYS_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_InboundTlb_InvalidEntry()</span></code></p></td>
<td><p>Invalid TLB entries (1,2,63) → DECERR verified</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>54</p></td>
<td><p>TC_INBOUND_APP1_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_InboundTlb_ValidEntryVerify()</span></code></p></td>
<td><p>Valid entry 0 succeeds, invalid entry 1 DECERR</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>55</p></td>
<td><p>TC_INBOUND_SYS_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_InboundTlb_MultipleEntryIndex()</span></code></p></td>
<td><p>Entry index calculation: entry 0 vs 5,10,31,63</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>56</p></td>
<td><p>TC_INBOUND_SYS/APP0/APP1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_InboundTlb_AllThreeTypes()</span></code></p></td>
<td><p>All 3 inbound TLB types: SysIn0, AppIn0, AppIn1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>57</p></td>
<td><p>TC_INBOUND_APP0_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_InboundTlb_App0_AllInstances()</span></code></p></td>
<td><p>All 4 TLB App In0 instances [0]-[3] config routing</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>58</p></td>
<td><p>TC_OUTBOUND_SYS_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_OutboundTlb_SysOut0_All16Entries()</span></code></p></td>
<td><p>TLB Sys Out0: entry 0 valid, entries 1-15 DECERR</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>59</p></td>
<td><p>TC_OUTBOUND_APP0_001/002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_OutboundTlb_HighAddressRouting()</span></code></p></td>
<td><p>NOC-IO high address routing (bits[51:48]) to TLB Out</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>60</p></td>
<td><p>TC_OUTBOUND_APP1_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_OutboundTlb_AppOut1_Routing()</span></code></p></td>
<td><p>TLB App Out1 via NOC-IO data path</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>61</p></td>
<td><p>TC_MSI_RELAY_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_MsiRelay_ReceiverInput()</span></code></p></td>
<td><p>MSI relay input/CSR routing paths exercised</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>62</p></td>
<td><p>TC_MSI_RELAY_011</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_MsiRelay_MultiVectorConfig()</span></code></p></td>
<td><p>All 16 MSI-X vector config + trigger</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>63</p></td>
<td><p>TC_SII_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_SII_BusDevNumberOutput()</span></code></p></td>
<td><p>SII bus/dev number config path + output signals</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>64</p></td>
<td><p>TC_SII_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_SII_CiiConfigUpdate()</span></code></p></td>
<td><p>CII tracking + interrupt: asserts CII config write (type=0x04, addr in first 128B), verifies config_update=true, confirms cfg_modified sticky bits across multiple CII events</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>65</p></td>
<td><p>TC_EXTERNAL_NOC/SMN</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Signal_InterruptForwarding()</span></code></p></td>
<td><p>5 interrupt signal paths verified with <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code>: FLR assert/deassert, hot reset, RAS error, DMA completion, misc interrupt</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>66</p></td>
<td><p>TC_CLOCK_RESET_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Reset_ColdRestoresDefaults()</span></code></p></td>
<td><p>Cold reset with <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code>: signal cycling, state preserved (enables/TLBs unaffected)</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>67</p></td>
<td><p>TC_CLOCK_RESET_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Reset_WarmPreservesConfig()</span></code></p></td>
<td><p>Warm reset with <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code>: TLB state, status, bypass paths preserved</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>68</p></td>
<td><p>TC_CONFIG_REG_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_TlbConfig_AllBanksAccessible()</span></code></p></td>
<td><p>All 9 TLB config banks + data path verification</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>69</p></td>
<td><p>TC_INTEGRATION_003/004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Integration_BidirectionalVerified()</span></code></p></td>
<td><p>Verified bidirectional: 20 rapid alternating txns</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>70</p></td>
<td><p>TC_MSI_RELAY_012</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_MsiRelay_InterruptOutput()</span></code></p></td>
<td><p>MSI output verification: NOC-IO and PCIe inbound MSI trigger paths exercised, address passthrough prevents PBA set (offset=0x18800000≠0), no spurious MSI output</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>71</p></td>
<td><p>TC_MSI_RELAY_013</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_MsiRelay_PendingBitArray()</span></code></p></td>
<td><p>PBA mechanism: PBA register read attempted via SMN (passthrough documented), MSI accumulation for vectors 0-3 attempted, outstanding counter read attempted</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>72</p></td>
<td><p>TC_MSI_RELAY_014</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_MsiRelay_GlobalMaskControl()</span></code></p></td>
<td><p>Global mask: MSI-X table configuration (addr, data, mask) attempted for entries 0-3 via SMN, MSI trigger after config attempted, address passthrough blocks all CSR writes</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>73</p></td>
<td><p>TC_SII_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_SII_CiiInterruptClear()</span></code></p></td>
<td><p>CII interrupt clear: CII asserts config_update, RW1C via SMN blocked by passthrough, controller reset clears cfg_modified and deasserts config_update</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>74</p></td>
<td><p>TC_SII_005</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_SII_CiiEdgeCases()</span></code></p></td>
<td><p>CII edge cases: type=0x00 (no trigger), type=0x05 (no trigger), addr=0x080 second 128B (no trigger), addr=0x400 high config (no trigger), hv=false (no trigger), positive control confirms valid CII triggers</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>75</p></td>
<td><p>TC_SII_006</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_SII_ResetClearsConfigUpdate()</span></code></p></td>
<td><p>Reset lifecycle: clean→CII→interrupt→more CII→accumulated→reset→cleared→new CII→re-asserted→final reset→cleared</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>76</p></td>
<td><p>TC_SII_007</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_SII_DeviceTypeAndSysInt()</span></code></p></td>
<td><p>SII output signals: verifies <code class="docutils literal notranslate"><span class="pre">pcie_device_type</span></code> (EP mode default=false) and <code class="docutils literal notranslate"><span class="pre">pcie_sys_int</span></code> (no legacy interrupt default=false), attempts CORE_CONTROL write via SMN (blocked by passthrough), confirms outputs unchanged</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>77</p></td>
<td><p>TC_SWITCH_NOC_PCIE_005</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_StatusRegRoute0xF()</span></code></p></td>
<td><p>Status register via route 0xF: reads status via both route 0xE and 0xF, verifies <code class="docutils literal notranslate"><span class="pre">system_ready=1</span></code>, confirms both routes return identical value</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>78</p></td>
<td><p>TC_SWITCH_NOC_PCIE_006</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_StatusRegWriteRejection()</span></code></p></td>
<td><p>Write rejection on status routes: writes to route 0xE and 0xF return DECERR (not treated as status access), read still works after rejection</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>79</p></td>
<td><p>TC_SWITCH_NOC_PCIE_007</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_Switch_BadCommandResponse()</span></code></p></td>
<td><p>DECERR route coverage: exercises 5 unmapped route bits (0x2, 0x3, 0x5, 0xA, 0xD), verifies all return DECERR, confirms system stability after multiple error responses</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>80</p></td>
<td><p>TC_INBOUND_TLB_006</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testDirected_InboundTlb_PageBoundary()</span></code></p></td>
<td><p>TLB page boundary: addr 0x3FFC → entry 0 (valid, success), addr 0x4000 → entry 1 (invalid, DECERR), addr 0x7FFC → entry 1 (DECERR), entry 63 max index (DECERR), regression check entry 0</p></td>
<td><p>✅ PASS</p></td>
</tr>
</tbody>
</table>
<p><strong>Known Findings Documented in Directed Tests:</strong></p>
<ol class="arabic simple">
<li><p><strong>Address Passthrough (TLB Config):</strong> TLB <code class="docutils literal notranslate"><span class="pre">process_config_access()</span></code> uses the full SMN address as an offset into a 4KB SCML2 memory. Only entry 0 at the base of each 64KB config range fits; entries 1+ exceed memory bounds. Fix: strip base address before memory access.</p></li>
<li><p><strong>Address Passthrough (MSI Relay):</strong> MSI relay <code class="docutils literal notranslate"><span class="pre">process_msi_input()</span></code> and <code class="docutils literal notranslate"><span class="pre">process_csr_access()</span></code> receive full addresses from switches, preventing register matching. Fix: strip base address.</p></li>
<li><p><strong>Address Passthrough (SII):</strong> Same issue as MSI relay for SII config register access.</p></li>
<li><p><strong>Signal Propagation (RESOLVED):</strong> sc_signal writes require delta cycles to propagate in SystemC. This is now handled by calling <code class="docutils literal notranslate"><span class="pre">sc_core::wait(sc_core::SC_ZERO_TIME)</span></code> after signal writes to advance delta cycles. Tests that use this technique directly verify isolation blocking, interrupt signal forwarding (FLR, hot reset, RAS, DMA, misc), cold/warm reset signal cycling, and CII input propagation.</p></li>
<li><p><strong>Config Register Block (RESOLVED):</strong> SMN-IO switch now correctly routes config writes within 0x18040000-0x1804FFFF to the ConfigRegBlock callback. System ready (offset 0xFFFC) and enable registers (offset 0xFFF8) are functional via SMN writes.</p></li>
<li><p><strong>Isolation Enable Recovery:</strong> <code class="docutils literal notranslate"><span class="pre">ConfigRegBlock::set_isolate_req(true)</span></code> clears <code class="docutils literal notranslate"><span class="pre">system_ready</span></code>, <code class="docutils literal notranslate"><span class="pre">pcie_inbound_app_enable</span></code>, and <code class="docutils literal notranslate"><span class="pre">pcie_outbound_app_enable</span></code>. <code class="docutils literal notranslate"><span class="pre">set_isolate_req(false)</span></code> only clears the <code class="docutils literal notranslate"><span class="pre">isolate_req_</span></code> flag but does NOT restore the enables. However, tests can recover by writing to enable registers via SMN (0x18040000+0xFFF8 and 0x18040000+0xFFFC) after cold reset, since the config register callback is now functional.</p></li>
<li><p><strong>CII Processing (RESOLVED):</strong> The SII block’s CII tracking, CDC synchronization, and interrupt generation logic has been restored via the <code class="docutils literal notranslate"><span class="pre">SiiBlock::update()</span></code> method. This single method replaces the three SC_METHODs from the backup_original (<code class="docutils literal notranslate"><span class="pre">cii_tracking_process</span></code>, <code class="docutils literal notranslate"><span class="pre">cfg_modified_update_process</span></code>, <code class="docutils literal notranslate"><span class="pre">cdc_pcie_to_apb</span></code>). CII config-space write detection (type 0x04, first 128B), cfg_modified bitmask accumulation with RW1C clear support, and <code class="docutils literal notranslate"><span class="pre">config_update</span></code> interrupt assertion are all functional. The tile’s <code class="docutils literal notranslate"><span class="pre">signal_update_process</span></code> calls <code class="docutils literal notranslate"><span class="pre">sii_block_-&gt;update()</span></code> between setters and getters to process CII inputs each delta cycle.</p></li>
<li><p><strong>MSI Relay Interrupt Output Not Verifiable:</strong> The MSI relay’s interrupt output path cannot be fully exercised because: (a) <code class="docutils literal notranslate"><span class="pre">process_msi_input</span></code> requires <code class="docutils literal notranslate"><span class="pre">offset==0</span></code> but receives the full NOC-IO address <code class="docutils literal notranslate"><span class="pre">0x18800000</span></code> (address passthrough), so PBA bits are never set; (b) <code class="docutils literal notranslate"><span class="pre">msix_enable_</span></code> is an internal <code class="docutils literal notranslate"><span class="pre">sc_signal</span></code> (not exposed as a tile port), defaulting to <code class="docutils literal notranslate"><span class="pre">false</span></code>; © per-vector masks default to <code class="docutils literal notranslate"><span class="pre">true</span></code> (masked) and cannot be cleared via SMN CSR writes (address passthrough). The MSI routing paths, PBA read, and global mask configuration paths are exercised in tests TC_MSI_RELAY_012/013/014, which document the specific address passthrough offsets and verify system stability.</p></li>
<li><p><strong>DUT Initiator Socket Architecture (NEW):</strong> The three output ports (<code class="docutils literal notranslate"><span class="pre">noc_n_initiator</span></code>, <code class="docutils literal notranslate"><span class="pre">smn_n_initiator</span></code>, <code class="docutils literal notranslate"><span class="pre">pcie_controller_initiator</span></code>) have been changed from <code class="docutils literal notranslate"><span class="pre">tlm_utils::simple_target_socket</span></code> (stubs) to <code class="docutils literal notranslate"><span class="pre">tlm_utils::simple_initiator_socket</span></code>. Outbound traffic now flows through these sockets to the testbench’s <code class="docutils literal notranslate"><span class="pre">sparse_backing_memory</span></code> instances, enabling full cross-socket data verification. Data written via one input port (e.g., PCIe) can be verified at the output port’s backing memory (e.g., NOC), confirming end-to-end data integrity through the DUT.</p></li>
<li><p><strong>Sparse Backing Memory (NEW):</strong> The testbench uses a custom <code class="docutils literal notranslate"><span class="pre">sparse_backing_memory</span></code> class instead of <code class="docutils literal notranslate"><span class="pre">scml2::testing::test_memory</span></code> (which had an internal bug with name derivation). The custom class uses <code class="docutils literal notranslate"><span class="pre">std::map&lt;uint64_t,</span> <span class="pre">uint8_t&gt;</span></code> for truly sparse storage covering a 256TB address range with zero allocation overhead, eliminating the previous 1GB memory size constraint.</p></li>
</ol>
</section>
<hr class="docutils" />
<section id="test-environment">
<h2>2. Test Environment<a class="headerlink" href="#test-environment" title="Permalink to this heading"></a></h2>
<section id="testbench-structure">
<h3>2.1 Testbench Structure<a class="headerlink" href="#testbench-structure" title="Permalink to this heading"></a></h3>
<p>The testbench uses the Synopsys SCML2 test framework with <code class="docutils literal notranslate"><span class="pre">scml2::testing::initiator_socket_proxy</span></code> for DUT output ports. A custom <code class="docutils literal notranslate"><span class="pre">sparse_backing_memory</span></code> class provides truly sparse memory backing using <code class="docutils literal notranslate"><span class="pre">std::map&lt;uint64_t,</span> <span class="pre">uint8_t&gt;</span></code>, enabling cross-socket data verification without allocation overhead.</p>
<p><strong>Architecture:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>┌─────────────────────────────────────────────────────────────────┐
│                     SCML2 Test Harness                           │
│                                                                  │
│  target_socket_proxy ──► DUT Input Ports                         │
│   (noc_n_target)          (noc_n_target)                         │
│   (smn_n_target)          (smn_n_target)                         │
│   (pcie_controller_target)(pcie_controller_target)               │
│                                                                  │
│  initiator_socket_proxy ◄── DUT Output Ports (Initiator Sockets) │
│   (noc_n_initiator)        (noc_n_initiator)                     │
│   (smn_n_initiator)        (smn_n_initiator)                     │
│   (pcie_controller_init.)  (pcie_controller_initiator)           │
│        │                                                         │
│        ▼                                                         │
│  sparse_backing_memory (std::map&lt;uint64_t, uint8_t&gt;)             │
│   - noc_output_mem_    (256TB range, zero overhead)              │
│   - smn_output_mem_    (256TB range, zero overhead)              │
│   - pcie_output_mem_   (256TB range, zero overhead)              │
│                                                                  │
│  Cross-Socket Verification:                                      │
│   1. Write via input port (e.g., pcie_controller_target)         │
│   2. DUT routes through TLB, forwards via initiator socket       │
│   3. sparse_backing_memory captures data                         │
│   4. Test reads backing memory to verify data integrity          │
└─────────────────────────────────────────────────────────────────┘
</pre></div>
</div>
</section>
<section id="test-components">
<h3>2.2 Test Components<a class="headerlink" href="#test-components" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><strong>SCML2 Target Socket Proxy:</strong> Sends transactions to DUT input ports</p></li>
<li><p><strong>SCML2 Initiator Socket Proxy:</strong> Receives transactions from DUT output ports (initiator sockets)</p></li>
<li><p><strong>sparse_backing_memory:</strong> Custom class implementing <code class="docutils literal notranslate"><span class="pre">scml2::mappable_if</span></code> and <code class="docutils literal notranslate"><span class="pre">scml2::testing::memory_if</span></code>, using <code class="docutils literal notranslate"><span class="pre">std::map&lt;uint64_t,</span> <span class="pre">uint8_t&gt;</span></code> for fully sparse storage with 256TB address range</p></li>
<li><p><strong>Cross-Socket Data Verification:</strong> Helper methods <code class="docutils literal notranslate"><span class="pre">verify_output_u32()</span></code>, <code class="docutils literal notranslate"><span class="pre">read_output_u32()</span></code>, <code class="docutils literal notranslate"><span class="pre">write_output_u32()</span></code> for verifying data written on one DUT port appears correctly at another port’s backing memory</p></li>
<li><p><strong>SCML2_ASSERT_THAT:</strong> Assertion macro for test pass/fail reporting</p></li>
</ul>
</section>
<section id="test-tools">
<h3>2.3 Test Tools<a class="headerlink" href="#test-tools" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><strong>SystemC Simulator:</strong> SystemC kernel for simulation</p></li>
<li><p><strong>TLM2.0 Library:</strong> Transaction Level Modeling library</p></li>
<li><p><strong>SCML2:</strong> Synopsys Component Modeling Library</p></li>
<li><p><strong>Test Framework:</strong> Custom C++ test framework or UVM-SystemC</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="test-strategy">
<h2>3. Test Strategy<a class="headerlink" href="#test-strategy" title="Permalink to this heading"></a></h2>
<section id="test-levels">
<h3>3.1 Test Levels<a class="headerlink" href="#test-levels" title="Permalink to this heading"></a></h3>
<ol class="arabic simple">
<li><p><strong>Unit Tests:</strong> Individual TLB and MSI Relay Unit testing</p></li>
<li><p><strong>Integration Tests:</strong> TLB + MSI Relay Unit interaction</p></li>
<li><p><strong>System Tests:</strong> Full tile integration scenarios</p></li>
</ol>
</section>
<section id="test-methodology">
<h3>3.2 Test Methodology<a class="headerlink" href="#test-methodology" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Directed Tests:</strong> Specific scenarios from specification</p></li>
<li><p><strong>Random Tests:</strong> Constrained random stimulus generation</p></li>
<li><p><strong>Coverage-Driven Tests:</strong> Tests targeting coverage holes</p></li>
<li><p><strong>Stress Tests:</strong> High transaction rates and edge cases</p></li>
</ul>
</section>
<section id="test-phases">
<h3>3.3 Test Phases<a class="headerlink" href="#test-phases" title="Permalink to this heading"></a></h3>
<ol class="arabic simple">
<li><p><strong>Phase 1:</strong> Basic functionality (address translation, register access)</p></li>
<li><p><strong>Phase 2:</strong> Error handling and edge cases</p></li>
<li><p><strong>Phase 3:</strong> MSI interrupt delivery</p></li>
<li><p><strong>Phase 4:</strong> Integration and system scenarios</p></li>
<li><p><strong>Phase 5:</strong> Performance and stress testing</p></li>
</ol>
</section>
</section>
<hr class="docutils" />
<section id="inbound-tlb-test-cases">
<h2>4. Inbound TLB Test Cases<a class="headerlink" href="#inbound-tlb-test-cases" title="Permalink to this heading"></a></h2>
<section id="tlbsysin0-test-cases">
<h3>4.1 TLBSysIn0 Test Cases<a class="headerlink" href="#tlbsysin0-test-cases" title="Permalink to this heading"></a></h3>
<section id="tc-inbound-sys-001-basic-address-translation">
<h4>TC_INBOUND_SYS_001: Basic Address Translation<a class="headerlink" href="#tc-inbound-sys-001-basic-address-translation" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify correct address translation for valid TLB entry</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB entry 0: valid=1, addr=0x18000000, attr=0x123</p></li>
<li><p>Send AXI read transaction with address 0xE0000000 (iATU output)</p></li>
<li><p>Verify translated address = 0x18000000</p></li>
<li><p>Verify AxUSER = expected value based on attr[11:4] and attr[1:0]</p></li>
</ol>
<p><strong>Expected Result:</strong> Translation successful, correct address and AxUSER</p>
<p><strong>Coverage:</strong> Basic translation path, AxUSER mapping</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-sys-002-invalid-entry-detection">
<h4>TC_INBOUND_SYS_002: Invalid Entry Detection<a class="headerlink" href="#tc-inbound-sys-002-invalid-entry-detection" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify DECERR response for invalid TLB entry</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB entry 5: valid=0</p></li>
<li><p>Send AXI read transaction with address that maps to entry 5</p></li>
<li><p>Verify response status = TLM_DECERR_RESPONSE</p></li>
<li><p>Verify transaction does not propagate downstream</p></li>
</ol>
<p><strong>Expected Result:</strong> DECERR returned immediately</p>
<p><strong>Coverage:</strong> Invalid entry handling</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-sys-003-index-calculation">
<h4>TC_INBOUND_SYS_003: Index Calculation<a class="headerlink" href="#tc-inbound-sys-003-index-calculation" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify correct index calculation for all entries</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure all 64 entries with unique addresses</p></li>
<li><p>Send transactions covering all index ranges</p></li>
<li><p>Verify each transaction uses correct TLB entry</p></li>
</ol>
<p><strong>Expected Result:</strong> All entries accessed correctly</p>
<p><strong>Coverage:</strong> Index calculation, all entries</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-sys-004-page-boundary-crossing">
<h4>TC_INBOUND_SYS_004: Page Boundary Crossing<a class="headerlink" href="#tc-inbound-sys-004-page-boundary-crossing" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify address translation preserves page offset</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB entry 10: addr=0x10000000</p></li>
<li><p>Send transaction with address 0xE0001234 (offset=0x1234)</p></li>
<li><p>Verify translated address = 0x10001234</p></li>
</ol>
<p><strong>Expected Result:</strong> Page offset preserved correctly</p>
<p><strong>Coverage:</strong> Address masking, page boundaries</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-sys-005-axuser-field-mapping">
<h4>TC_INBOUND_SYS_005: AxUSER Field Mapping<a class="headerlink" href="#tc-inbound-sys-005-axuser-field-mapping" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify AxUSER field format: {ATTR[11:4], 2’b0, ATTR[1:0]}</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB entry with attr = 0xABC</p></li>
<li><p>Send transaction and capture AxUSER</p></li>
<li><p>Verify AxUSER[11:4] = attr[11:4] = 0xAB</p></li>
<li><p>Verify AxUSER[3:2] = 0b00</p></li>
<li><p>Verify AxUSER[1:0] = attr[1:0] = 0x3</p></li>
</ol>
<p><strong>Expected Result:</strong> AxUSER matches specification format</p>
<p><strong>Coverage:</strong> AxUSER encoding</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-sys-006-system-ready-bypass">
<h4>TC_INBOUND_SYS_006: System Ready Bypass<a class="headerlink" href="#tc-inbound-sys-006-system-ready-bypass" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify bypass path when system_ready=1 and addr[63:60]=8 or 9</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Set system_ready = 1</p></li>
<li><p>Send transaction with address[63:60] = 8</p></li>
<li><p>Verify transaction bypasses TLB translation</p></li>
<li><p>Verify transaction forwarded directly to SMN-IO</p></li>
</ol>
<p><strong>Expected Result:</strong> Bypass path functional</p>
<p><strong>Coverage:</strong> Bypass logic</p>
</section>
</section>
<hr class="docutils" />
<section id="tlbappin0-test-cases">
<h3>4.2 TLBAppIn0 Test Cases<a class="headerlink" href="#tlbappin0-test-cases" title="Permalink to this heading"></a></h3>
<section id="tc-inbound-app0-001-bar0-1-translation">
<h4>TC_INBOUND_APP0_001: BAR0/1 Translation<a class="headerlink" href="#tc-inbound-app0-001-bar0-1-translation" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify translation for BAR0/1 traffic (port=0)</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB entry 20: valid=1, addr=0x20000000</p></li>
<li><p>Send transaction with iATU address[63:60] = 0 (BAR0/1)</p></li>
<li><p>Verify translated address uses entry 20</p></li>
<li><p>Verify AxUSER format: {3’b0, ATTR[4:0], 4’b0}</p></li>
</ol>
<p><strong>Expected Result:</strong> Correct translation for BAR0/1</p>
<p><strong>Coverage:</strong> Port selection, BAR0/1 path</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-app0-002-multiple-instance-support">
<h4>TC_INBOUND_APP0_002: Multiple Instance Support<a class="headerlink" href="#tc-inbound-app0-002-multiple-instance-support" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify multiple TLBAppIn0 instances work independently</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Instantiate TLBAppIn0-0, TLBAppIn0-1, TLBAppIn0-2, TLBAppIn0-3</p></li>
<li><p>Configure each with different entries</p></li>
<li><p>Send transactions to each instance</p></li>
<li><p>Verify each instance translates independently</p></li>
</ol>
<p><strong>Expected Result:</strong> All instances function correctly</p>
<p><strong>Coverage:</strong> Multiple instances</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-app0-003-16mb-page-size">
<h4>TC_INBOUND_APP0_003: 16MB Page Size<a class="headerlink" href="#tc-inbound-app0-003-16mb-page-size" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify 16MB page size translation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 5: addr=0x30000000</p></li>
<li><p>Send transaction with address offset 0x123456</p></li>
<li><p>Verify translated address = 0x30123456</p></li>
</ol>
<p><strong>Expected Result:</strong> 16MB page size handled correctly</p>
<p><strong>Coverage:</strong> Page size, address masking</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-app0-004-non-cacheable-and-qosid">
<h4>TC_INBOUND_APP0_004: Non-Cacheable and QoSID<a class="headerlink" href="#tc-inbound-app0-004-non-cacheable-and-qosid" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify ATTR[4:0] mapping to AxUSER</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry with attr[4] = 1 (non-cacheable), attr[3:0] = 0xA (QoSID)</p></li>
<li><p>Send transaction and verify AxUSER[8] = 1, AxUSER[7:4] = 0xA</p></li>
</ol>
<p><strong>Expected Result:</strong> Non-cacheable and QoSID correctly encoded</p>
<p><strong>Coverage:</strong> Attribute encoding</p>
</section>
</section>
<hr class="docutils" />
<section id="tlbappin1-test-cases">
<h3>4.3 TLBAppIn1 Test Cases<a class="headerlink" href="#tlbappin1-test-cases" title="Permalink to this heading"></a></h3>
<section id="tc-inbound-app1-001-bar4-5-translation">
<h4>TC_INBOUND_APP1_001: BAR4/5 Translation<a class="headerlink" href="#tc-inbound-app1-001-bar4-5-translation" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify translation for BAR4/5 traffic (port=1)</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB entry 30: valid=1, addr=0x4000000000</p></li>
<li><p>Send transaction with iATU address[63:60] = 1 (BAR4/5)</p></li>
<li><p>Verify translated address uses entry 30</p></li>
<li><p>Verify correct 8GB page size handling</p></li>
</ol>
<p><strong>Expected Result:</strong> Correct translation for BAR4/5</p>
<p><strong>Coverage:</strong> Port selection, BAR4/5 path</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-app1-002-8gb-page-size">
<h4>TC_INBOUND_APP1_002: 8GB Page Size<a class="headerlink" href="#tc-inbound-app1-002-8gb-page-size" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify 8GB page size translation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 10: addr=0x5000000000</p></li>
<li><p>Send transaction with address offset 0x123456789</p></li>
<li><p>Verify translated address = 0x5123456789</p></li>
</ol>
<p><strong>Expected Result:</strong> 8GB page size handled correctly</p>
<p><strong>Coverage:</strong> Large page size, address masking</p>
</section>
<hr class="docutils" />
<section id="tc-inbound-app1-003-dram-mapping">
<h4>TC_INBOUND_APP1_003: DRAM Mapping<a class="headerlink" href="#tc-inbound-app1-003-dram-mapping" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify typical DRAM mapping scenario</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entries 0-3 for Mimir 0 (4 entries × 8GB = 32GB)</p></li>
<li><p>Send transactions covering all 4 entries</p></li>
<li><p>Verify correct translation to DRAM addresses</p></li>
</ol>
<p><strong>Expected Result:</strong> DRAM mapping functional</p>
<p><strong>Coverage:</strong> Real-world usage scenario</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="outbound-tlb-test-cases">
<h2>5. Outbound TLB Test Cases<a class="headerlink" href="#outbound-tlb-test-cases" title="Permalink to this heading"></a></h2>
<section id="tlbsysout0-test-cases">
<h3>5.1 TLBSysOut0 Test Cases<a class="headerlink" href="#tlbsysout0-test-cases" title="Permalink to this heading"></a></h3>
<section id="tc-outbound-sys-001-dbi-access-translation">
<h4>TC_OUTBOUND_SYS_001: DBI Access Translation<a class="headerlink" href="#tc-outbound-sys-001-dbi-access-translation" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify DBI access translation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 0: valid=1, addr=0x00000000, attr=DBI_ATTR</p></li>
<li><p>Send AXI write transaction with address 0x00001234</p></li>
<li><p>Verify translated address = 0x00001234</p></li>
<li><p>Verify attributes passed through</p></li>
</ol>
<p><strong>Expected Result:</strong> DBI access translated correctly</p>
<p><strong>Coverage:</strong> DBI path, attribute passthrough</p>
</section>
<hr class="docutils" />
<section id="tc-outbound-sys-002-64kb-page-size">
<h4>TC_OUTBOUND_SYS_002: 64KB Page Size<a class="headerlink" href="#tc-outbound-sys-002-64kb-page-size" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify 64KB page size</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 5: addr=0x00380000</p></li>
<li><p>Send transaction with address 0x00381234</p></li>
<li><p>Verify translated address = 0x00381234</p></li>
</ol>
<p><strong>Expected Result:</strong> 64KB page size handled correctly</p>
<p><strong>Coverage:</strong> Page size, address masking</p>
</section>
<hr class="docutils" />
<section id="tc-outbound-sys-003-all-16-entries">
<h4>TC_OUTBOUND_SYS_003: All 16 Entries<a class="headerlink" href="#tc-outbound-sys-003-all-16-entries" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify all 16 entries accessible</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure all 16 entries with unique addresses</p></li>
<li><p>Send transactions covering all entries</p></li>
<li><p>Verify each entry translates correctly</p></li>
</ol>
<p><strong>Expected Result:</strong> All entries functional</p>
<p><strong>Coverage:</strong> Full entry coverage</p>
</section>
</section>
<hr class="docutils" />
<section id="tlbappout0-test-cases">
<h3>5.2 TLBAppOut0 Test Cases<a class="headerlink" href="#tlbappout0-test-cases" title="Permalink to this heading"></a></h3>
<section id="tc-outbound-app0-001-high-address-translation-256tb">
<h4>TC_OUTBOUND_APP0_001: High Address Translation (&gt;=256TB)<a class="headerlink" href="#tc-outbound-app0-001-high-address-translation-256tb" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify translation for addresses &gt;= 256TB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 5: valid=1, addr=0x100000000000</p></li>
<li><p>Send transaction with address 0x100000001234</p></li>
<li><p>Verify translated address uses entry 5</p></li>
<li><p>Verify 16TB page size handling</p></li>
</ol>
<p><strong>Expected Result:</strong> High address translation correct</p>
<p><strong>Coverage:</strong> High address path, 16TB pages</p>
</section>
<hr class="docutils" />
<section id="tc-outbound-app0-002-address-range-check">
<h4>TC_OUTBOUND_APP0_002: Address Range Check<a class="headerlink" href="#tc-outbound-app0-002-address-range-check" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify only addresses &gt;= 256TB are processed</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with address &lt; 256TB (e.g., 0x000000001234)</p></li>
<li><p>Verify TLBAppOut0 does not process (should use TLBAppOut1)</p></li>
<li><p>Send transaction with address &gt;= 256TB</p></li>
<li><p>Verify TLBAppOut0 processes correctly</p></li>
</ol>
<p><strong>Expected Result:</strong> Address range filtering correct</p>
<p><strong>Coverage:</strong> Address range logic</p>
</section>
<hr class="docutils" />
<section id="tc-outbound-app0-003-16tb-page-size">
<h4>TC_OUTBOUND_APP0_003: 16TB Page Size<a class="headerlink" href="#tc-outbound-app0-003-16tb-page-size" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify 16TB page size translation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 10: addr=0x200000000000</p></li>
<li><p>Send transaction with address offset 0x123456789ABC</p></li>
<li><p>Verify translated address = 0x2123456789ABC</p></li>
</ol>
<p><strong>Expected Result:</strong> 16TB page size handled correctly</p>
<p><strong>Coverage:</strong> Large page size</p>
</section>
</section>
<hr class="docutils" />
<section id="tlbappout1-test-cases">
<h3>5.3 TLBAppOut1 Test Cases<a class="headerlink" href="#tlbappout1-test-cases" title="Permalink to this heading"></a></h3>
<section id="tc-outbound-app1-001-low-address-translation-256tb">
<h4>TC_OUTBOUND_APP1_001: Low Address Translation (&lt;256TB)<a class="headerlink" href="#tc-outbound-app1-001-low-address-translation-256tb" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify translation for addresses &lt; 256TB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 3: valid=1, addr=0x00003800</p></li>
<li><p>Send transaction with address 0x00001234</p></li>
<li><p>Verify translated address uses entry 3</p></li>
</ol>
<p><strong>Expected Result:</strong> Low address translation correct</p>
<p><strong>Coverage:</strong> Low address path</p>
</section>
<hr class="docutils" />
<section id="tc-outbound-app1-002-dbi-access-from-application">
<h4>TC_OUTBOUND_APP1_002: DBI Access from Application<a class="headerlink" href="#tc-outbound-app1-002-dbi-access-from-application" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify DBI access from application processors</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure entry 1: addr=0x00380000 (DBI DMA)</p></li>
<li><p>Send transaction with address 0x00381234</p></li>
<li><p>Verify translated address = 0x00381234</p></li>
<li><p>Verify DBI attributes set</p></li>
</ol>
<p><strong>Expected Result:</strong> DBI access functional</p>
<p><strong>Coverage:</strong> DBI path from application</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="msi-relay-unit-test-cases">
<h2>6. MSI Relay Unit Test Cases<a class="headerlink" href="#msi-relay-unit-test-cases" title="Permalink to this heading"></a></h2>
<section id="register-access-tests">
<h3>6.1 Register Access Tests<a class="headerlink" href="#register-access-tests" title="Permalink to this heading"></a></h3>
<section id="tc-msi-relay-001-msi-receiver-write">
<h4>TC_MSI_RELAY_001: MSI Receiver Write<a class="headerlink" href="#tc-msi-relay-001-msi-receiver-write" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify writing to msi_receiver sets PBA bit</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Write 0x0005 to msi_receiver (vector 5)</p></li>
<li><p>Read msix_pba register</p></li>
<li><p>Verify bit 5 is set</p></li>
<li><p>Verify other bits unchanged</p></li>
</ol>
<p><strong>Expected Result:</strong> PBA bit 5 set correctly</p>
<p><strong>Coverage:</strong> MSI receiver, PBA update</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-002-msi-x-table-configuration">
<h4>TC_MSI_RELAY_002: MSI-X Table Configuration<a class="headerlink" href="#tc-msi-relay-002-msi-x-table-configuration" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify MSI-X table read/write</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Write MSI-X table entry 3:</p>
<ul class="simple">
<li><p>Address = 0xFEE00000</p></li>
<li><p>Data = 0x1234</p></li>
<li><p>Mask = 0</p></li>
</ul>
</li>
<li><p>Read back entry 3</p></li>
<li><p>Verify all fields match</p></li>
</ol>
<p><strong>Expected Result:</strong> MSI-X table accessible</p>
<p><strong>Coverage:</strong> MSI-X table access</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-003-outstanding-count">
<h4>TC_MSI_RELAY_003: Outstanding Count<a class="headerlink" href="#tc-msi-relay-003-outstanding-count" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify msi_outstanding counter</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 0</p></li>
<li><p>Trigger MSI (should increment counter)</p></li>
<li><p>Read msi_outstanding</p></li>
<li><p>Verify counter &gt; 0</p></li>
<li><p>Wait for completion</p></li>
<li><p>Verify counter returns to 0</p></li>
</ol>
<p><strong>Expected Result:</strong> Outstanding counter accurate</p>
<p><strong>Coverage:</strong> Outstanding tracking</p>
</section>
</section>
<hr class="docutils" />
<section id="msi-generation-tests">
<h3>6.2 MSI Generation Tests<a class="headerlink" href="#msi-generation-tests" title="Permalink to this heading"></a></h3>
<section id="tc-msi-relay-004-basic-msi-generation">
<h4>TC_MSI_RELAY_004: Basic MSI Generation<a class="headerlink" href="#tc-msi-relay-004-basic-msi-generation" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify MSI message generation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 0:</p>
<ul class="simple">
<li><p>Address = 0xFEE00000</p></li>
<li><p>Data = 0x1234</p></li>
<li><p>Mask = 0</p></li>
</ul>
</li>
<li><p>Set msix_enable = 1, msix_mask = 0</p></li>
<li><p>Write 0x0000 to msi_receiver</p></li>
<li><p>Verify AXI4-Lite write transaction:</p>
<ul class="simple">
<li><p>Address = 0xFEE00000</p></li>
<li><p>Data = 0x1234</p></li>
</ul>
</li>
<li><p>Verify PBA bit 0 cleared after send</p></li>
</ol>
<p><strong>Expected Result:</strong> MSI generated correctly</p>
<p><strong>Coverage:</strong> MSI generation path</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-005-msi-x-enable-control">
<h4>TC_MSI_RELAY_005: MSI-X Enable Control<a class="headerlink" href="#tc-msi-relay-005-msi-x-enable-control" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify MSI-X enable gating</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 0</p></li>
<li><p>Set msix_enable = 0</p></li>
<li><p>Write 0x0000 to msi_receiver</p></li>
<li><p>Verify no MSI generated</p></li>
<li><p>Set msix_enable = 1</p></li>
<li><p>Verify MSI generated</p></li>
</ol>
<p><strong>Expected Result:</strong> Enable control functional</p>
<p><strong>Coverage:</strong> Enable gating</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-006-global-mask-control">
<h4>TC_MSI_RELAY_006: Global Mask Control<a class="headerlink" href="#tc-msi-relay-006-global-mask-control" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify global mask gating</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 0</p></li>
<li><p>Set msix_enable = 1, msix_mask = 1</p></li>
<li><p>Write 0x0000 to msi_receiver</p></li>
<li><p>Verify no MSI generated</p></li>
<li><p>Set msix_mask = 0</p></li>
<li><p>Verify MSI generated</p></li>
</ol>
<p><strong>Expected Result:</strong> Global mask functional</p>
<p><strong>Coverage:</strong> Mask gating</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-007-vector-mask-control">
<h4>TC_MSI_RELAY_007: Vector Mask Control<a class="headerlink" href="#tc-msi-relay-007-vector-mask-control" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify per-vector mask control</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 5 with mask = 1</p></li>
<li><p>Set msix_enable = 1, msix_mask = 0</p></li>
<li><p>Write 0x0005 to msi_receiver</p></li>
<li><p>Verify no MSI generated (vector masked)</p></li>
<li><p>Configure entry 5 with mask = 0</p></li>
<li><p>Verify MSI generated</p></li>
</ol>
<p><strong>Expected Result:</strong> Vector mask functional</p>
<p><strong>Coverage:</strong> Per-vector masking</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-008-invalid-entry-handling">
<h4>TC_MSI_RELAY_008: Invalid Entry Handling<a class="headerlink" href="#tc-msi-relay-008-invalid-entry-handling" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify invalid MSI-X table entry handling</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 10 with address = 0</p></li>
<li><p>Set msix_enable = 1, msix_mask = 0</p></li>
<li><p>Write 0x000A to msi_receiver</p></li>
<li><p>Verify no MSI generated (invalid address)</p></li>
<li><p>Verify PBA bit remains set</p></li>
</ol>
<p><strong>Expected Result:</strong> Invalid entries ignored</p>
<p><strong>Coverage:</strong> Invalid entry handling</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-009-multiple-pending-interrupts">
<h4>TC_MSI_RELAY_009: Multiple Pending Interrupts<a class="headerlink" href="#tc-msi-relay-009-multiple-pending-interrupts" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify handling of multiple pending interrupts</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entries 0, 1, 2</p></li>
<li><p>Set msix_enable = 1, msix_mask = 0</p></li>
<li><p>Write 0x0000, 0x0001, 0x0002 to msi_receiver</p></li>
<li><p>Verify all three PBA bits set</p></li>
<li><p>Verify MSIs generated one at a time</p></li>
<li><p>Verify PBA bits cleared as MSIs sent</p></li>
</ol>
<p><strong>Expected Result:</strong> Multiple interrupts handled correctly</p>
<p><strong>Coverage:</strong> Multiple pending, MSI ordering</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-010-setip-signal">
<h4>TC_MSI_RELAY_010: SetIP Signal<a class="headerlink" href="#tc-msi-relay-010-setip-signal" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify setip signal sets PBA bits</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 7</p></li>
<li><p>Set msix_enable = 1, msix_mask = 0</p></li>
<li><p>Assert setip[7] = 1</p></li>
<li><p>Verify PBA bit 7 set</p></li>
<li><p>Verify MSI generated</p></li>
</ol>
<p><strong>Expected Result:</strong> SetIP signal functional</p>
<p><strong>Coverage:</strong> SetIP input</p>
</section>
<hr class="docutils" />
<section id="tc-msi-relay-011-all-16-vectors">
<h4>TC_MSI_RELAY_011: All 16 Vectors<a class="headerlink" href="#tc-msi-relay-011-all-16-vectors" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify all 16 MSI-X vectors functional</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure all 16 MSI-X table entries</p></li>
<li><p>Trigger interrupts for all vectors</p></li>
<li><p>Verify all MSIs generated</p></li>
<li><p>Verify all PBA bits cleared</p></li>
</ol>
<p><strong>Expected Result:</strong> All vectors functional</p>
<p><strong>Coverage:</strong> Full vector coverage</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="integration-test-cases">
<h2>7. Integration Test Cases<a class="headerlink" href="#integration-test-cases" title="Permalink to this heading"></a></h2>
<section id="tlb-msi-relay-integration">
<h3>7.1 TLB + MSI Relay Integration<a class="headerlink" href="#tlb-msi-relay-integration" title="Permalink to this heading"></a></h3>
<section id="tc-integration-001-msi-x-table-access-via-tlb">
<h4>TC_INTEGRATION_001: MSI-X Table Access via TLB<a class="headerlink" href="#tc-integration-001-msi-x-table-access-via-tlb" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify host can access MSI-X table through TLB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLBSysIn0 entry 0 for MSI Relay (0x18000000)</p></li>
<li><p>Configure iATU to map BAR2/3 to TLBSysIn0</p></li>
<li><p>Host writes to BAR2+0x2000 (MSI-X table)</p></li>
<li><p>Verify write reaches MSI Relay Unit</p></li>
<li><p>Verify MSI-X table updated</p></li>
</ol>
<p><strong>Expected Result:</strong> TLB + MSI Relay integration functional</p>
<p><strong>Coverage:</strong> Integration path</p>
</section>
<hr class="docutils" />
<section id="tc-integration-002-msi-generation-through-fabric">
<h4>TC_INTEGRATION_002: MSI Generation Through Fabric<a class="headerlink" href="#tc-integration-002-msi-generation-through-fabric" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify MSI travels through intra-tile fabric</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table entry 0</p></li>
<li><p>Trigger MSI from MSI Relay Unit</p></li>
<li><p>Verify MSI write transaction on NOC-PCIE</p></li>
<li><p>Verify transaction reaches PCIe Controller</p></li>
<li><p>Verify TLP generated</p></li>
</ol>
<p><strong>Expected Result:</strong> MSI path through fabric functional</p>
<p><strong>Coverage:</strong> Fabric integration</p>
</section>
</section>
<hr class="docutils" />
<section id="multiple-tlb-integration">
<h3>7.2 Multiple TLB Integration<a class="headerlink" href="#multiple-tlb-integration" title="Permalink to this heading"></a></h3>
<section id="tc-integration-003-concurrent-tlb-operations">
<h4>TC_INTEGRATION_003: Concurrent TLB Operations<a class="headerlink" href="#tc-integration-003-concurrent-tlb-operations" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify multiple TLBs operate concurrently</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transactions to TLBSysIn0, TLBAppIn0, TLBAppIn1 simultaneously</p></li>
<li><p>Verify all translations occur correctly</p></li>
<li><p>Verify no interference between TLBs</p></li>
</ol>
<p><strong>Expected Result:</strong> Concurrent operations functional</p>
<p><strong>Coverage:</strong> Concurrency</p>
</section>
<hr class="docutils" />
<section id="tc-integration-004-outbound-inbound-round-trip">
<h4>TC_INTEGRATION_004: Outbound + Inbound Round Trip<a class="headerlink" href="#tc-integration-004-outbound-inbound-round-trip" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify address translation round trip</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure outbound TLB entry</p></li>
<li><p>Send transaction outbound (chiplet -&gt; external)</p></li>
<li><p>External device responds</p></li>
<li><p>Response comes inbound through inbound TLB</p></li>
<li><p>Verify correct translation both directions</p></li>
</ol>
<p><strong>Expected Result:</strong> Round trip translation correct</p>
<p><strong>Coverage:</strong> Bidirectional translation</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="switch-test-cases">
<h2>8. Switch Test Cases<a class="headerlink" href="#switch-test-cases" title="Permalink to this heading"></a></h2>
<section id="noc-pcie-switch-test-cases">
<h3>8.1 NOC-PCIE Switch Test Cases<a class="headerlink" href="#noc-pcie-switch-test-cases" title="Permalink to this heading"></a></h3>
<section id="tc-switch-noc-pcie-001-address-routing-based-on-axaddr-63-60">
<h4>TC_SWITCH_NOC_PCIE_001: Address Routing Based on AxADDR[63:60]<a class="headerlink" href="#tc-switch-noc-pcie-001-address-routing-based-on-axaddr-63-60" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify routing based on top 4 address bits</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with AxADDR[63:60] = 0x0</p></li>
<li><p>Verify transaction routed to TLB App Inbound Port 0</p></li>
<li><p>Send transaction with AxADDR[63:60] = 0x4</p></li>
<li><p>Verify transaction routed to TLB Sys Inbound Port</p></li>
<li><p>Send transaction with AxADDR[63:60] = 0x2</p></li>
<li><p>Verify DECERR response</p></li>
</ol>
<p><strong>Expected Result:</strong> Correct routing based on address bits</p>
<p><strong>Coverage:</strong> Address routing logic</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-pcie-002-status-register-special-routing">
<h4>TC_SWITCH_NOC_PCIE_002: Status Register Special Routing<a class="headerlink" href="#tc-switch-noc-pcie-002-status-register-special-routing" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify Status Register special routing (AxADDR[63:60] = 0xE)</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send read transaction with AxADDR[63:60] = 0xE, AxADDR[59:7] = 0</p></li>
<li><p>Verify transaction routed to Status Register (not TLB Sys)</p></li>
<li><p>Verify System Ready register value returned</p></li>
<li><p>Send write transaction with AxADDR[63:60] = 0xE, AxADDR[59:7] = 0</p></li>
<li><p>Verify Status Register updated</p></li>
<li><p>Send transaction with AxADDR[63:60] = 0xE, AxADDR[59:7] != 0</p></li>
<li><p>Verify transaction routed to TLB Sys (not Status Register)</p></li>
</ol>
<p><strong>Expected Result:</strong> Status Register routing correct</p>
<p><strong>Coverage:</strong> Special routing case</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-pcie-003-isolation-support">
<h4>TC_SWITCH_NOC_PCIE_003: Isolation Support<a class="headerlink" href="#tc-switch-noc-pcie-003-isolation-support" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify isolation behavior</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert <code class="docutils literal notranslate"><span class="pre">isolate_req</span></code> signal</p></li>
<li><p>Send transaction to switch</p></li>
<li><p>Verify DECERR response immediately</p></li>
<li><p>Deassert <code class="docutils literal notranslate"><span class="pre">isolate_req</span></code></p></li>
<li><p>Verify normal routing resumes</p></li>
</ol>
<p><strong>Expected Result:</strong> Isolation functional</p>
<p><strong>Coverage:</strong> Isolation logic</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-pcie-004-inbound-enable-control">
<h4>TC_SWITCH_NOC_PCIE_004: Inbound Enable Control<a class="headerlink" href="#tc-switch-noc-pcie-004-inbound-enable-control" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify inbound enable gating</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Set <code class="docutils literal notranslate"><span class="pre">pcie_inbound_app_enable</span></code> = 0</p></li>
<li><p>Send inbound transaction (not Status Register)</p></li>
<li><p>Verify DECERR response</p></li>
<li><p>Set <code class="docutils literal notranslate"><span class="pre">pcie_inbound_app_enable</span></code> = 1</p></li>
<li><p>Verify normal routing</p></li>
</ol>
<p><strong>Expected Result:</strong> Inbound enable control functional</p>
<p><strong>Coverage:</strong> Enable gating</p>
</section>
</section>
<hr class="docutils" />
<section id="enable-gating-test-cases-new-feb-2026">
<h3>8.4 Enable Gating Test Cases (NEW - Feb 2026)<a class="headerlink" href="#enable-gating-test-cases-new-feb-2026" title="Permalink to this heading"></a></h3>
<section id="tc-negative-enable-001-inbound-enable-blocks-pcienoc-traffic">
<h4>TC_NEGATIVE_ENABLE_001: Inbound Enable Blocks PCIe→NOC Traffic<a class="headerlink" href="#tc-negative-enable-001-inbound-enable-blocks-pcienoc-traffic" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testNegative_InboundDisabled_BlocksPcieToNoc()</span></code> | <strong>Feature:</strong> Inbound Enable Independent Control | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify <code class="docutils literal notranslate"><span class="pre">pcie_inbound_app_enable=0</span></code> blocks PCIe→NOC application traffic while outbound traffic flows normally</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Verify default state: both enables=1, traffic flows bidirectionally</p></li>
<li><p>Configure outbound TLB for NOC→PCIe path</p></li>
<li><p>Write to config register 0x18000000+0x0FFF8 with value 0x1 (outbound=1, inbound=0)</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code> to propagate config change via callback</p></li>
<li><p>Verify inbound traffic (PCIe→NOC) returns DECERR for both read and write</p></li>
<li><p>Verify outbound traffic (NOC→PCIe) still succeeds</p></li>
<li><p>Cold reset and restore both enables</p></li>
<li><p>Verify full recovery</p></li>
</ol>
<p><strong>Expected Result:</strong> Inbound traffic blocked, outbound flows, recovery successful</p>
<p><strong>Coverage:</strong> Inbound enable gate, independent control, status register bypass</p>
<p><strong>Implementation Detail:</strong> ConfigRegBlock callback propagates enable bit changes to NocPcieSwitch</p>
</section>
<hr class="docutils" />
<section id="tc-negative-enable-002-outbound-enable-blocks-nocpcie-traffic">
<h4>TC_NEGATIVE_ENABLE_002: Outbound Enable Blocks NOC→PCIe Traffic<a class="headerlink" href="#tc-negative-enable-002-outbound-enable-blocks-nocpcie-traffic" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testNegative_OutboundDisabled_BlocksNocToPcie()</span></code> | <strong>Feature:</strong> Outbound Enable Independent Control | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify <code class="docutils literal notranslate"><span class="pre">pcie_outbound_app_enable=0</span></code> blocks NOC→PCIe application traffic while inbound traffic flows normally</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure outbound TLB and verify default state works</p></li>
<li><p>Verify inbound traffic succeeds with default enables</p></li>
<li><p>Write to config register 0x18000000+0x0FFF8 with value 0x10000 (outbound=0, inbound=1)</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code> to propagate config change</p></li>
<li><p>Verify outbound traffic (NOC→PCIe) returns DECERR for both read and write</p></li>
<li><p>Verify inbound traffic (PCIe→NOC) still succeeds</p></li>
<li><p>Cold reset and restore both enables</p></li>
<li><p>Verify outbound traffic restored</p></li>
</ol>
<p><strong>Expected Result:</strong> Outbound traffic blocked, inbound flows, recovery successful</p>
<p><strong>Coverage:</strong> Outbound enable gate, independent control, address range 0x18900000</p>
<p><strong>Implementation Detail:</strong> Uses NOC-IO address range (0x18900000) to avoid SCML2 framework high-address interception</p>
</section>
<hr class="docutils" />
<section id="tc-negative-enable-003-both-enables-disabled-complete-isolation">
<h4>TC_NEGATIVE_ENABLE_003: Both Enables Disabled - Complete Isolation<a class="headerlink" href="#tc-negative-enable-003-both-enables-disabled-complete-isolation" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testNegative_BothDisabled_BlocksBidirectional()</span></code> | <strong>Feature:</strong> Dual Enable Complete Traffic Isolation | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify both enables=0 blocks all application traffic while system_ready=1</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Verify default state: traffic flows both directions</p></li>
<li><p>Keep system_ready=1 but disable both enables: write 0x0 to PCIE_ENABLE register</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code> to propagate config change</p></li>
<li><p>Verify inbound traffic (PCIe→NOC) returns DECERR</p></li>
<li><p>Verify outbound traffic (NOC→PCIe) returns DECERR</p></li>
<li><p>Verify status register bypass still works (system_ready=1 allows monitoring)</p></li>
<li><p>Cold reset and restore both enables</p></li>
<li><p>Verify full bidirectional recovery</p></li>
</ol>
<p><strong>Expected Result:</strong> Both directions blocked, status register accessible, recovery successful</p>
<p><strong>Coverage:</strong> Complete isolation mode, status register bypass during traffic block</p>
<p><strong>Key Feature:</strong> Status register (route 0xE) checked BEFORE enable bits, allowing monitoring even when traffic is disabled</p>
</section>
<hr class="docutils" />
<section id="tc-negative-enable-004-both-enables-active-positive-control">
<h4>TC_NEGATIVE_ENABLE_004: Both Enables Active - Positive Control<a class="headerlink" href="#tc-negative-enable-004-both-enables-active-positive-control" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testNegative_BothEnabled_AllowsBidirectional()</span></code> | <strong>Feature:</strong> Enable Gating Positive Control Test | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Positive control test - verify both enables=1 allows full bidirectional traffic</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Explicitly set both enables to 1: write 0x10001 to PCIE_ENABLE register</p></li>
<li><p>Configure TLBs for bidirectional traffic (inbound and outbound)</p></li>
<li><p>Verify inbound path succeeds (write + read)</p></li>
<li><p>Verify outbound path succeeds (write + read)</p></li>
<li><p>Stress test: 10 rapid bidirectional transactions</p></li>
<li><p>Verify all complete successfully</p></li>
<li><p>Verify status register accessible</p></li>
</ol>
<p><strong>Expected Result:</strong> Full bidirectional traffic flows, 24 checks pass</p>
<p><strong>Coverage:</strong> Enable logic doesn’t false-positive block, stress test confirms stability</p>
<p><strong>Implementation:</strong> Uses working address ranges (0x80000000 for inbound, 0x18900000 for outbound) compatible with SCML2 framework</p>
</section>
</section>
<hr class="docutils" />
<section id="enable-gating-implementation-architecture">
<h3>8.5 Enable Gating Implementation Architecture<a class="headerlink" href="#enable-gating-implementation-architecture" title="Permalink to this heading"></a></h3>
<p>The enable gating feature uses a callback-based signal propagation mechanism:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>APB Write to PCIE_ENABLE (0x18000000 + 0x0FFF8)
    ↓
ConfigRegBlock::process_write()
    → Updates pcie_outbound_app_enable_ (bit 0)
    → Updates pcie_inbound_app_enable_ (bit 16)
    → Invokes change_callback_()
    ↓
KeraunosPcieTile::update_config_dependent_modules()
    → Reads enable values from ConfigRegBlock
    → Calls NocPcieSwitch::set_pcie_outbound_app_enable()
    → Calls NocPcieSwitch::set_pcie_inbound_app_enable()
    ↓
NocPcieSwitch::route_from_pcie() / route_to_pcie()
    → Checks enable bits
    → Returns DECERR if disabled
    → Routes normally if enabled
</pre></div>
</div>
<p><strong>Key Design Features:</strong></p>
<ol class="arabic simple">
<li><p><strong>Status Register Bypass:</strong> Status register access (routes 0xE/0xF) checked BEFORE enable bits, allowing system monitoring even when traffic is disabled</p></li>
<li><p><strong>Callback Mechanism:</strong> ConfigRegBlock uses <code class="docutils literal notranslate"><span class="pre">std::function</span></code> callback to notify KeraunosPcieTile of register changes, avoiding complex SystemC signal dependencies</p></li>
<li><p><strong>Independent Control:</strong> Each enable bit controls one direction independently</p></li>
<li><p><strong>Recovery Support:</strong> Cold reset restores default enables, allowing full recovery</p></li>
</ol>
<p><strong>Register Format (0x18000000 + 0x0FFF8):</strong></p>
<ul class="simple">
<li><p>Bit 0: <code class="docutils literal notranslate"><span class="pre">pcie_outbound_app_enable</span></code> (controls NOC→PCIe traffic)</p></li>
<li><p>Bit 16: <code class="docutils literal notranslate"><span class="pre">pcie_inbound_app_enable</span></code> (controls PCIe→NOC traffic)</p></li>
<li><p>Example values:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">0x10001</span></code> = Both enabled (default)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x10000</span></code> = Inbound only</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x00001</span></code> = Outbound only</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x00000</span></code> = Both disabled (isolation mode)</p></li>
</ul>
</li>
</ul>
<hr class="docutils" />
<section id="tc-switch-noc-pcie-005-bypass-path-routing">
<h4>TC_SWITCH_NOC_PCIE_005: Bypass Path Routing<a class="headerlink" href="#tc-switch-noc-pcie-005-bypass-path-routing" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify bypass path (AxADDR[63:60] = 0x8 or 0x9)</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Set <code class="docutils literal notranslate"><span class="pre">system_ready</span></code> = 1</p></li>
<li><p>Send transaction with AxADDR[63:60] = 0x8</p></li>
<li><p>Verify transaction routed to Bypass App Port (NOC-IO)</p></li>
<li><p>Send transaction with AxADDR[63:60] = 0x9</p></li>
<li><p>Verify transaction routed to Bypass Sys Port (SMN-IO)</p></li>
<li><p>Set <code class="docutils literal notranslate"><span class="pre">system_ready</span></code> = 0</p></li>
<li><p>Verify bypass path returns DECERR</p></li>
</ol>
<p><strong>Expected Result:</strong> Bypass path functional</p>
<p><strong>Coverage:</strong> Bypass logic, system ready</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-pcie-006-address-conversion-64-bit-to-52-bit">
<h4>TC_SWITCH_NOC_PCIE_006: Address Conversion (64-bit to 52-bit)<a class="headerlink" href="#tc-switch-noc-pcie-006-address-conversion-64-bit-to-52-bit" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify address conversion for NOC-IO/SMN-IO routing</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with 64-bit address to bypass port</p></li>
<li><p>Verify address converted to 52-bit for NOC-IO/SMN-IO</p></li>
<li><p>Verify top 12 bits stripped correctly</p></li>
<li><p>Verify routing preserved</p></li>
</ol>
<p><strong>Expected Result:</strong> Address conversion correct</p>
<p><strong>Coverage:</strong> Address width conversion</p>
</section>
</section>
<hr class="docutils" />
<section id="noc-io-switch-test-cases">
<h3>8.2 NOC-IO Switch Test Cases<a class="headerlink" href="#noc-io-switch-test-cases" title="Permalink to this heading"></a></h3>
<section id="tc-switch-noc-io-001-local-resource-routing">
<h4>TC_SWITCH_NOC_IO_001: Local Resource Routing<a class="headerlink" href="#tc-switch-noc-io-001-local-resource-routing" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify routing to local resources</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction to 0x18800000 (MSI Relay MSI)</p></li>
<li><p>Verify routed to MSI Relay port</p></li>
<li><p>Send transaction to 0x18900000 (TLB App Outbound)</p></li>
<li><p>Verify routed to TLB App Outbound</p></li>
<li><p>Send transaction to 0x18A00000 (DECERR region)</p></li>
<li><p>Verify DECERR response</p></li>
</ol>
<p><strong>Expected Result:</strong> Local routing correct</p>
<p><strong>Coverage:</strong> Address decoding</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-io-002-external-noc-routing">
<h4>TC_SWITCH_NOC_IO_002: External NOC Routing<a class="headerlink" href="#tc-switch-noc-io-002-external-noc-routing" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify routing to external NOC-N</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with address not matching local resources</p></li>
<li><p>Verify routed to NOC-N interface</p></li>
<li><p>Verify transaction forwarded to external NOC</p></li>
<li><p>Verify response propagated back</p></li>
</ol>
<p><strong>Expected Result:</strong> External routing functional</p>
<p><strong>Coverage:</strong> External interface</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-io-003-high-address-routing-axaddr-51-48">
<h4>TC_SWITCH_NOC_IO_003: High Address Routing (AxADDR[51:48])<a class="headerlink" href="#tc-switch-noc-io-003-high-address-routing-axaddr-51-48" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify routing based on AxADDR[51:48]</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with AxADDR[51:48] != 0</p></li>
<li><p>Verify routed to TLB App Outbound</p></li>
<li><p>Send transaction with AxADDR[51:48] = 0</p></li>
<li><p>Verify routed to NOC-N (if not local resource)</p></li>
</ol>
<p><strong>Expected Result:</strong> High address routing correct</p>
<p><strong>Coverage:</strong> Address bit routing</p>
</section>
<hr class="docutils" />
<section id="tc-switch-noc-io-004-timeout-detection">
<h4>TC_SWITCH_NOC_IO_004: Timeout Detection<a class="headerlink" href="#tc-switch-noc-io-004-timeout-detection" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify timeout detection for hung transactions</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send read transaction to external NOC</p></li>
<li><p>Simulate timeout (no response)</p></li>
<li><p>Verify timeout signal asserted</p></li>
<li><p>Verify SLVERR response returned</p></li>
<li><p>Verify outstanding requests cleared</p></li>
</ol>
<p><strong>Expected Result:</strong> Timeout detection functional</p>
<p><strong>Coverage:</strong> Timeout logic</p>
</section>
</section>
<hr class="docutils" />
<section id="smn-io-switch-test-cases">
<h3>8.3 SMN-IO Switch Test Cases<a class="headerlink" href="#smn-io-switch-test-cases" title="Permalink to this heading"></a></h3>
<section id="tc-switch-smn-io-001-address-based-routing">
<h4>TC_SWITCH_SMN_IO_001: Address-Based Routing<a class="headerlink" href="#tc-switch-smn-io-001-address-based-routing" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify routing based on address map</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction to 0x18000000 (MSI Relay Config)</p></li>
<li><p>Verify routed to MSI Relay Config port</p></li>
<li><p>Send transaction to 0x18040000 (TLB Config)</p></li>
<li><p>Verify routed to TLB Config port</p></li>
<li><p>Send transaction to 0x18100000 (SII Config)</p></li>
<li><p>Verify routed to SII Config port</p></li>
</ol>
<p><strong>Expected Result:</strong> Address routing correct</p>
<p><strong>Coverage:</strong> Address map decoding</p>
</section>
<hr class="docutils" />
<section id="tc-switch-smn-io-002-serdes-routing">
<h4>TC_SWITCH_SMN_IO_002: SerDes Routing<a class="headerlink" href="#tc-switch-smn-io-002-serdes-routing" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify SerDes APB/AHB routing</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction to 0x18080000 (SerDes AHB)</p></li>
<li><p>Verify routed to SerDes AHB port</p></li>
<li><p>Send transaction to 0x180C0000 (SerDes APB)</p></li>
<li><p>Verify routed to SerDes APB port</p></li>
</ol>
<p><strong>Expected Result:</strong> SerDes routing functional</p>
<p><strong>Coverage:</strong> SerDes interface</p>
</section>
<hr class="docutils" />
<section id="tc-switch-smn-io-003-external-smn-routing">
<h4>TC_SWITCH_SMN_IO_003: External SMN Routing<a class="headerlink" href="#tc-switch-smn-io-003-external-smn-routing" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify routing to external SMN-N</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with address not matching local resources</p></li>
<li><p>Verify routed to SMN-N interface</p></li>
<li><p>Verify transaction forwarded to external SMN</p></li>
<li><p>Verify response propagated back</p></li>
</ol>
<p><strong>Expected Result:</strong> External routing functional</p>
<p><strong>Coverage:</strong> External interface</p>
</section>
<hr class="docutils" />
<section id="tc-switch-smn-io-004-timeout-detection">
<h4>TC_SWITCH_SMN_IO_004: Timeout Detection<a class="headerlink" href="#tc-switch-smn-io-004-timeout-detection" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify timeout detection</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction to external SMN</p></li>
<li><p>Simulate timeout</p></li>
<li><p>Verify timeout signal asserted</p></li>
<li><p>Verify SLVERR response</p></li>
</ol>
<p><strong>Expected Result:</strong> Timeout detection functional</p>
<p><strong>Coverage:</strong> Timeout logic</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="sii-block-test-cases">
<h2>9. SII Block Test Cases<a class="headerlink" href="#sii-block-test-cases" title="Permalink to this heading"></a></h2>
<section id="id1">
<h3>9.1 Register Access Tests<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h3>
<section id="tc-sii-001-configuration-register-access">
<h4>TC_SII_001: Configuration Register Access<a class="headerlink" href="#tc-sii-001-configuration-register-access" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify SII register space accessible via APB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Write to SII register space via APB</p></li>
<li><p>Read back register value</p></li>
<li><p>Verify read/write correct</p></li>
</ol>
<p><strong>Expected Result:</strong> Register access functional</p>
<p><strong>Coverage:</strong> APB interface</p>
</section>
<hr class="docutils" />
<section id="tc-sii-002-cii-tracking">
<h4>TC_SII_002: CII Tracking<a class="headerlink" href="#tc-sii-002-cii-tracking" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Implementing Test:</strong> <code class="docutils literal notranslate"><span class="pre">testDirected_SII_CiiConfigUpdate()</span></code> | <strong>Feature:</strong> CII tracking, cfg_modified accumulation, config_update interrupt | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify CII tracks configuration updates and generates config_update interrupt</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Verify config_update initially false (no CII events)</p></li>
<li><p>Assert CII valid with type=0x04 (config write), addr=0x010 (register index 4, first 128B)</p></li>
<li><p>Advance delta cycles with <code class="docutils literal notranslate"><span class="pre">wait(SC_ZERO_TIME)</span></code> for signal propagation</p></li>
<li><p>Verify config_update asserted (cfg_modified bit 4 set)</p></li>
<li><p>Deassert CII header valid</p></li>
<li><p>Verify config_update stays asserted (cfg_modified bits sticky until RW1C clear)</p></li>
<li><p>Assert CII for different register (addr=0x004, register index 1)</p></li>
<li><p>Verify config_update still asserted (bits 1 and 4 now set)</p></li>
</ol>
<p><strong>Expected Result:</strong> CII tracking functional: config writes detected, cfg_modified accumulated, config_update interrupt asserted</p>
<p><strong>Coverage:</strong> CII interface, cfg_modified bitmask, interrupt generation, sticky bit behavior</p>
</section>
<hr class="docutils" />
<section id="tc-sii-003-bus-device-number-assignment">
<h4>TC_SII_003: Bus/Device Number Assignment<a class="headerlink" href="#tc-sii-003-bus-device-number-assignment" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify bus/device number outputs</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Write bus number to SII register</p></li>
<li><p>Verify app_bus_num output updated</p></li>
<li><p>Write device number to SII register</p></li>
<li><p>Verify app_dev_num output updated</p></li>
</ol>
<p><strong>Expected Result:</strong> Bus/device assignment functional</p>
<p><strong>Coverage:</strong> Control outputs</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="config-register-block-test-cases">
<h2>10. Config Register Block Test Cases<a class="headerlink" href="#config-register-block-test-cases" title="Permalink to this heading"></a></h2>
<section id="id2">
<h3>10.1 Register Access Tests<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h3>
<section id="tc-config-reg-001-tlb-configuration-space-access">
<h4>TC_CONFIG_REG_001: TLB Configuration Space Access<a class="headerlink" href="#tc-config-reg-001-tlb-configuration-space-access" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify TLB configuration registers accessible</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Write to TLBSysOut0 configuration space</p></li>
<li><p>Read back TLB entry</p></li>
<li><p>Verify entry configured correctly</p></li>
<li><p>Repeat for all TLB banks</p></li>
</ol>
<p><strong>Expected Result:</strong> TLB config space accessible</p>
<p><strong>Coverage:</strong> TLB configuration</p>
</section>
<hr class="docutils" />
<section id="tc-config-reg-002-system-ready-register">
<h4>TC_CONFIG_REG_002: System Ready Register<a class="headerlink" href="#tc-config-reg-002-system-ready-register" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify System Ready register behavior</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Write 1 to System Ready register (bit[0])</p></li>
<li><p>Verify system_ready output = 1</p></li>
<li><p>Write 0 to System Ready register</p></li>
<li><p>Verify system_ready output = 0</p></li>
<li><p>Verify RW1C behavior (write 1 to clear)</p></li>
</ol>
<p><strong>Expected Result:</strong> System Ready register functional</p>
<p><strong>Coverage:</strong> Status register</p>
</section>
<hr class="docutils" />
<section id="tc-config-reg-003-pcie-enable-registers">
<h4>TC_CONFIG_REG_003: PCIE Enable Registers<a class="headerlink" href="#tc-config-reg-003-pcie-enable-registers" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify PCIE enable register control</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Write 1 to bit[0] (outbound enable)</p></li>
<li><p>Verify pcie_outbound_app_enable = 1</p></li>
<li><p>Write 1 to bit[16] (inbound enable)</p></li>
<li><p>Verify pcie_inbound_app_enable = 1</p></li>
<li><p>Write 0 to both bits</p></li>
<li><p>Verify both enables = 0</p></li>
</ol>
<p><strong>Expected Result:</strong> Enable registers functional</p>
<p><strong>Coverage:</strong> Control registers</p>
</section>
<hr class="docutils" />
<section id="tc-config-reg-004-isolation-behavior">
<h4>TC_CONFIG_REG_004: Isolation Behavior<a class="headerlink" href="#tc-config-reg-004-isolation-behavior" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify isolation clears enable bits</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Set System Ready = 1, Outbound Enable = 1, Inbound Enable = 1</p></li>
<li><p>Assert isolate_req</p></li>
<li><p>Verify System Ready = 0, Outbound Enable = 0, Inbound Enable = 0</p></li>
<li><p>Deassert isolate_req</p></li>
<li><p>Verify registers maintain values (until FW reprogramming)</p></li>
</ol>
<p><strong>Expected Result:</strong> Isolation behavior correct</p>
<p><strong>Coverage:</strong> Isolation logic</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="clock-reset-test-cases">
<h2>11. Clock &amp; Reset Test Cases<a class="headerlink" href="#clock-reset-test-cases" title="Permalink to this heading"></a></h2>
<section id="clock-generation-tests">
<h3>11.1 Clock Generation Tests<a class="headerlink" href="#clock-generation-tests" title="Permalink to this heading"></a></h3>
<section id="tc-clock-reset-001-reference-clock-generation">
<h4>TC_CLOCK_RESET_001: Reference Clock Generation<a class="headerlink" href="#tc-clock-reset-001-reference-clock-generation" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify reference clock generation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Enable reference clock</p></li>
<li><p>Monitor ref_clock output</p></li>
<li><p>Verify frequency = 100 MHz (10ns period)</p></li>
<li><p>Verify clock toggles correctly</p></li>
</ol>
<p><strong>Expected Result:</strong> Reference clock functional</p>
<p><strong>Coverage:</strong> Clock generation</p>
</section>
<hr class="docutils" />
<section id="tc-clock-reset-002-pcie-clock-generation">
<h4>TC_CLOCK_RESET_002: PCIE Clock Generation<a class="headerlink" href="#tc-clock-reset-002-pcie-clock-generation" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify PCIE clock generation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Deassert cold_reset_n and warm_reset_n</p></li>
<li><p>Wait for reset deassertion</p></li>
<li><p>Monitor pcie_clock output</p></li>
<li><p>Verify frequency = 1.0 GHz (1ns period)</p></li>
<li><p>Verify clock enabled after reset</p></li>
</ol>
<p><strong>Expected Result:</strong> PCIE clock functional</p>
<p><strong>Coverage:</strong> Clock generation, reset sequence</p>
</section>
</section>
<hr class="docutils" />
<section id="reset-sequence-tests">
<h3>11.2 Reset Sequence Tests<a class="headerlink" href="#reset-sequence-tests" title="Permalink to this heading"></a></h3>
<section id="tc-clock-reset-003-cold-reset-sequence">
<h4>TC_CLOCK_RESET_003: Cold Reset Sequence<a class="headerlink" href="#tc-clock-reset-003-cold-reset-sequence" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify cold reset sequence</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert cold_reset_n = 0</p></li>
<li><p>Verify pcie_sii_reset_ctrl = 0, pcie_reset_ctrl = 0</p></li>
<li><p>Verify clocks disabled</p></li>
<li><p>Deassert pcie_sii_reset_ctrl (SMC FW)</p></li>
<li><p>Wait for PLL lock</p></li>
<li><p>Deassert pcie_reset_ctrl</p></li>
<li><p>Verify clocks enabled</p></li>
<li><p>Verify force_to_ref_clk_n = 1</p></li>
</ol>
<p><strong>Expected Result:</strong> Cold reset sequence correct</p>
<p><strong>Coverage:</strong> Reset sequence</p>
</section>
<hr class="docutils" />
<section id="tc-clock-reset-004-warm-reset-sequence">
<h4>TC_CLOCK_RESET_004: Warm Reset Sequence<a class="headerlink" href="#tc-clock-reset-004-warm-reset-sequence" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify warm reset sequence</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert warm_reset_n = 0</p></li>
<li><p>Verify pcie_reset_ctrl = 0 (but pcie_sii_reset_ctrl = 1)</p></li>
<li><p>Verify PCIE clock disabled</p></li>
<li><p>Deassert warm_reset_n</p></li>
<li><p>Verify PCIE clock enabled</p></li>
</ol>
<p><strong>Expected Result:</strong> Warm reset sequence correct</p>
<p><strong>Coverage:</strong> Reset sequence</p>
</section>
<hr class="docutils" />
<section id="tc-clock-reset-005-isolation-behavior">
<h4>TC_CLOCK_RESET_005: Isolation Behavior<a class="headerlink" href="#tc-clock-reset-005-isolation-behavior" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify isolation disables clocks</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Enable clocks normally</p></li>
<li><p>Assert isolate_req</p></li>
<li><p>Verify clocks disabled (gated)</p></li>
<li><p>Deassert isolate_req</p></li>
<li><p>Verify clocks re-enabled</p></li>
</ol>
<p><strong>Expected Result:</strong> Isolation clock gating functional</p>
<p><strong>Coverage:</strong> Isolation logic</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="pll-cgm-test-cases">
<h2>12. PLL/CGM Test Cases<a class="headerlink" href="#pll-cgm-test-cases" title="Permalink to this heading"></a></h2>
<section id="pll-lock-tests">
<h3>12.1 PLL Lock Tests<a class="headerlink" href="#pll-lock-tests" title="Permalink to this heading"></a></h3>
<section id="tc-pll-cgm-001-pll-lock-sequence">
<h4>TC_PLL_CGM_001: PLL Lock Sequence<a class="headerlink" href="#tc-pll-cgm-001-pll-lock-sequence" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify PLL lock sequence</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert reset_n = 0</p></li>
<li><p>Provide reference clock</p></li>
<li><p>Deassert reset_n = 1</p></li>
<li><p>Monitor pll_lock output</p></li>
<li><p>Verify lock after ~170 ref clock cycles</p></li>
<li><p>Verify pcie_clock generated after lock</p></li>
</ol>
<p><strong>Expected Result:</strong> PLL lock functional</p>
<p><strong>Coverage:</strong> PLL lock logic</p>
</section>
<hr class="docutils" />
<section id="tc-pll-cgm-002-pll-configuration">
<h4>TC_PLL_CGM_002: PLL Configuration<a class="headerlink" href="#tc-pll-cgm-002-pll-configuration" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify PLL configuration via APB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Access PLL configuration registers via APB</p></li>
<li><p>Configure lock time</p></li>
<li><p>Verify configuration applied</p></li>
<li><p>Verify lock time matches configuration</p></li>
</ol>
<p><strong>Expected Result:</strong> PLL configuration functional</p>
<p><strong>Coverage:</strong> Configuration interface</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="pcie-phy-test-cases">
<h2>13. PCIE PHY Test Cases<a class="headerlink" href="#pcie-phy-test-cases" title="Permalink to this heading"></a></h2>
<section id="phy-configuration-tests">
<h3>13.1 PHY Configuration Tests<a class="headerlink" href="#phy-configuration-tests" title="Permalink to this heading"></a></h3>
<section id="tc-phy-001-apb-configuration-access">
<h4>TC_PHY_001: APB Configuration Access<a class="headerlink" href="#tc-phy-001-apb-configuration-access" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify PHY configuration via APB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Access PHY configuration registers via APB</p></li>
<li><p>Write configuration values</p></li>
<li><p>Read back and verify</p></li>
<li><p>Verify configuration applied</p></li>
</ol>
<p><strong>Expected Result:</strong> APB configuration functional</p>
<p><strong>Coverage:</strong> APB interface</p>
</section>
<hr class="docutils" />
<section id="tc-phy-002-ahb-firmware-download">
<h4>TC_PHY_002: AHB Firmware Download<a class="headerlink" href="#tc-phy-002-ahb-firmware-download" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify firmware download via AHB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Download firmware to PHY via AHB interface</p></li>
<li><p>Verify firmware written correctly</p></li>
<li><p>Trigger PHY initialization</p></li>
<li><p>Verify phy_ready asserted after initialization</p></li>
</ol>
<p><strong>Expected Result:</strong> Firmware download functional</p>
<p><strong>Coverage:</strong> AHB interface, initialization</p>
</section>
<hr class="docutils" />
<section id="tc-phy-003-lane-reversal-support">
<h4>TC_PHY_003: Lane Reversal Support<a class="headerlink" href="#tc-phy-003-lane-reversal-support" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify lane reversal configuration</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure lane reversal via APB</p></li>
<li><p>Verify lane reversal enabled</p></li>
<li><p>Verify lane mapping correct</p></li>
</ol>
<p><strong>Expected Result:</strong> Lane reversal functional</p>
<p><strong>Coverage:</strong> Lane reversal feature</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="external-interface-test-cases">
<h2>14. External Interface Test Cases<a class="headerlink" href="#external-interface-test-cases" title="Permalink to this heading"></a></h2>
<section id="noc-n-interface-tests">
<h3>14.1 NOC-N Interface Tests<a class="headerlink" href="#noc-n-interface-tests" title="Permalink to this heading"></a></h3>
<section id="tc-external-noc-001-transaction-forwarding">
<h4>TC_EXTERNAL_NOC_001: Transaction Forwarding<a class="headerlink" href="#tc-external-noc-001-transaction-forwarding" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify transaction forwarding to external NOC</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction from NOC-IO switch</p></li>
<li><p>Verify transaction forwarded to external NOC</p></li>
<li><p>Simulate response from external NOC</p></li>
<li><p>Verify response propagated back</p></li>
</ol>
<p><strong>Expected Result:</strong> Transaction forwarding functional</p>
<p><strong>Coverage:</strong> External interface</p>
</section>
</section>
<hr class="docutils" />
<section id="smn-n-interface-tests">
<h3>14.2 SMN-N Interface Tests<a class="headerlink" href="#smn-n-interface-tests" title="Permalink to this heading"></a></h3>
<section id="tc-external-smn-001-transaction-forwarding">
<h4>TC_EXTERNAL_SMN_001: Transaction Forwarding<a class="headerlink" href="#tc-external-smn-001-transaction-forwarding" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify transaction forwarding to external SMN</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction from SMN-IO switch</p></li>
<li><p>Verify transaction forwarded to external SMN</p></li>
<li><p>Simulate response from external SMN</p></li>
<li><p>Verify response propagated back</p></li>
</ol>
<p><strong>Expected Result:</strong> Transaction forwarding functional</p>
<p><strong>Coverage:</strong> External interface</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="top-level-integration-test-cases">
<h2>15. Top-Level Integration Test Cases<a class="headerlink" href="#top-level-integration-test-cases" title="Permalink to this heading"></a></h2>
<section id="full-tile-integration">
<h3>15.1 Full Tile Integration<a class="headerlink" href="#full-tile-integration" title="Permalink to this heading"></a></h3>
<section id="tc-top-level-001-complete-reset-sequence">
<h4>TC_TOP_LEVEL_001: Complete Reset Sequence<a class="headerlink" href="#tc-top-level-001-complete-reset-sequence" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify complete reset sequence through top-level module</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert cold_reset_n = 0</p></li>
<li><p>Verify all components reset</p></li>
<li><p>Follow cold reset sequence</p></li>
<li><p>Verify all components initialized</p></li>
<li><p>Verify system ready</p></li>
</ol>
<p><strong>Expected Result:</strong> Reset sequence functional</p>
<p><strong>Coverage:</strong> Top-level reset</p>
</section>
<hr class="docutils" />
<section id="tc-top-level-002-end-to-end-transaction-flow">
<h4>TC_TOP_LEVEL_002: End-to-End Transaction Flow<a class="headerlink" href="#tc-top-level-002-end-to-end-transaction-flow" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify transaction flow through entire tile</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure all TLBs</p></li>
<li><p>Send transaction from PCIe Controller (inbound)</p></li>
<li><p>Verify transaction flows: Controller -&gt; NOC-PCIE -&gt; TLB -&gt; NOC-IO -&gt; External</p></li>
<li><p>Verify response flows back correctly</p></li>
</ol>
<p><strong>Expected Result:</strong> End-to-end flow functional</p>
<p><strong>Coverage:</strong> Full integration</p>
</section>
<hr class="docutils" />
<section id="tc-top-level-003-msi-end-to-end-flow">
<h4>TC_TOP_LEVEL_003: MSI End-to-End Flow<a class="headerlink" href="#tc-top-level-003-msi-end-to-end-flow" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify MSI flow through entire system</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table via TLB</p></li>
<li><p>Trigger MSI from downstream component</p></li>
<li><p>Verify MSI flows: Component -&gt; MSI Relay -&gt; NOC-PCIE -&gt; Controller</p></li>
<li><p>Verify MSI TLP generated</p></li>
</ol>
<p><strong>Expected Result:</strong> MSI flow functional</p>
<p><strong>Coverage:</strong> Interrupt path</p>
</section>
<hr class="docutils" />
<section id="tc-top-level-004-isolation-sequence">
<h4>TC_TOP_LEVEL_004: Isolation Sequence<a class="headerlink" href="#tc-top-level-004-isolation-sequence" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify isolation sequence</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Generate traffic through tile</p></li>
<li><p>Assert isolate_req</p></li>
<li><p>Verify all new transactions return DECERR</p></li>
<li><p>Verify outstanding transactions drain</p></li>
<li><p>Deassert isolate_req</p></li>
<li><p>Verify normal operation resumes</p></li>
</ol>
<p><strong>Expected Result:</strong> Isolation sequence functional</p>
<p><strong>Coverage:</strong> Isolation handling</p>
</section>
<hr class="docutils" />
<section id="tc-top-level-005-multiple-clock-domain-operation">
<h4>TC_TOP_LEVEL_005: Multiple Clock Domain Operation<a class="headerlink" href="#tc-top-level-005-multiple-clock-domain-operation" title="Permalink to this heading"></a></h4>
<p><strong>Objective:</strong> Verify operation with multiple clock domains</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Provide all required clocks (PCIE, NOC, SOC, AHB, Ref)</p></li>
<li><p>Generate transactions on different clock domains</p></li>
<li><p>Verify CDC logic handles crossings correctly</p></li>
<li><p>Verify no data corruption</p></li>
</ol>
<p><strong>Expected Result:</strong> Multi-clock operation functional</p>
<p><strong>Coverage:</strong> Clock domain crossing</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="end-to-end-test-cases">
<h2>16. End-to-End Test Cases<a class="headerlink" href="#end-to-end-test-cases" title="Permalink to this heading"></a></h2>
<p><strong>Note:</strong> After refactoring to eliminate E126 errors, all internal sub-modules are now C++ classes with function-based communication. Only the top-level <code class="docutils literal notranslate"><span class="pre">KeraunosPcieTile</span></code> has TLM sockets. These E2E tests verify complete data paths through the refactored architecture.</p>
<section id="inbound-data-paths-pcie-noc-smn">
<h3>16.1 Inbound Data Paths (PCIe → NOC/SMN)<a class="headerlink" href="#inbound-data-paths-pcie-noc-smn" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-inbound-001-pcie-read-tlb-app0-noc-n">
<h4>TC_E2E_INBOUND_001: PCIe Read → TLB App0 → NOC-N<a class="headerlink" href="#tc-e2e-inbound-001-pcie-read-tlb-app0-noc-n" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieRead_TlbApp0_NocN()</span></code> | <strong>Feature:</strong> Inbound Read Data Path | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify complete inbound read path from PCIe Controller through TLB App0 to NOC-N</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB App In0 entry 0: valid=1, addr=0x80000000</p></li>
<li><p>Send TLM read from <code class="docutils literal notranslate"><span class="pre">pcie_controller_target</span></code> with addr=0x0000000001000000 (route=0)</p></li>
<li><p>NOC-PCIE switch routes to TLB App In0</p></li>
<li><p>TLB translates to 0x80001000000</p></li>
<li><p>NOC-IO switch routes to NOC-N external</p></li>
<li><p>Verify transaction arrives at <code class="docutils literal notranslate"><span class="pre">noc_n_initiator</span></code> with translated address</p></li>
<li><p>Return read data, verify response propagates back</p></li>
</ol>
<p><strong>Expected Result:</strong> Complete E2E read with correct address translation</p>
<p><strong>Coverage:</strong> Inbound read path, TLB App0, switch routing</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-inbound-002-pcie-write-tlb-app1-noc-n">
<h4>TC_E2E_INBOUND_002: PCIe Write → TLB App1 → NOC-N<a class="headerlink" href="#tc-e2e-inbound-002-pcie-write-tlb-app1-noc-n" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN()</span></code> | <strong>Feature:</strong> Inbound Write Data Path (Large Pages) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify inbound write path via TLB App1</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB App In1 entry: valid=1, addr=0x100000000 (large page)</p></li>
<li><p>Send TLM write from <code class="docutils literal notranslate"><span class="pre">pcie_controller_target</span></code> with addr=0x1000000000000000 (route=1)</p></li>
<li><p>Verify routing: PCIe → NOC-PCIE → TLB App In1 → NOC-IO → NOC-N</p></li>
<li><p>Verify write data integrity throughout path</p></li>
<li><p>Verify response propagates back</p></li>
</ol>
<p><strong>Expected Result:</strong> Write completes successfully with translation</p>
<p><strong>Coverage:</strong> Inbound write path, TLB App1, large pages</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-inbound-003-pcie-tlb-sys-smn-n">
<h4>TC_E2E_INBOUND_003: PCIe → TLB Sys → SMN-N<a class="headerlink" href="#tc-e2e-inbound-003-pcie-tlb-sys-smn-n" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_Pcie_TlbSys_SmnN()</span></code> | <strong>Feature:</strong> System Management Inbound Path | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify system management path</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB Sys In0: valid=1, addr=0x18000000</p></li>
<li><p>Send config write from <code class="docutils literal notranslate"><span class="pre">pcie_controller_target</span></code> with addr=0x4000000000000000 (route=4)</p></li>
<li><p>Verify: PCIe → NOC-PCIE → TLB Sys In0 → SMN-IO → SMN-N</p></li>
<li><p>Check system ready flag handling</p></li>
<li><p>Verify transaction reaches <code class="docutils literal notranslate"><span class="pre">smn_n_initiator</span></code></p></li>
</ol>
<p><strong>Expected Result:</strong> Config write completes via SMN path</p>
<p><strong>Coverage:</strong> System management path, TLB Sys, SMN routing</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-inbound-004-pcie-bypass-app-path">
<h4>TC_E2E_INBOUND_004: PCIe Bypass App Path<a class="headerlink" href="#tc-e2e-inbound-004-pcie-bypass-app-path" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassApp()</span></code> | <strong>Feature:</strong> Application Bypass Routing (route=0x8) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify bypass path (no TLB translation)</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction from <code class="docutils literal notranslate"><span class="pre">pcie_controller_target</span></code> with addr=0x8000000000000000 (route=8)</p></li>
<li><p>Verify NOC-PCIE routes directly to NOC-IO (bypass TLB)</p></li>
<li><p>Verify address unchanged (no translation)</p></li>
<li><p>Transaction reaches NOC-N</p></li>
</ol>
<p><strong>Expected Result:</strong> Bypass path works, no TLB used</p>
<p><strong>Coverage:</strong> Bypass routing, address pass-through</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-inbound-005-pcie-bypass-sys-path">
<h4>TC_E2E_INBOUND_005: PCIe Bypass Sys Path<a class="headerlink" href="#tc-e2e-inbound-005-pcie-bypass-sys-path" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassSys()</span></code> | <strong>Feature:</strong> System Bypass Routing (route=0x9) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify system bypass path</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with addr=0x9000000000000000 (route=9)</p></li>
<li><p>Verify routing: PCIe → NOC-PCIE → SMN-IO → SMN-N (no TLB)</p></li>
<li><p>Address unchanged</p></li>
</ol>
<p><strong>Expected Result:</strong> System bypass successful</p>
<p><strong>Coverage:</strong> System bypass routing</p>
</section>
</section>
<hr class="docutils" />
<section id="outbound-data-paths-noc-smn-pcie">
<h3>16.2 Outbound Data Paths (NOC/SMN → PCIe)<a class="headerlink" href="#outbound-data-paths-noc-smn-pcie" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-outbound-001-noc-n-tlb-app-out0-pcie">
<h4>TC_E2E_OUTBOUND_001: NOC-N → TLB App Out0 → PCIe<a class="headerlink" href="#tc-e2e-outbound-001-noc-n-tlb-app-out0-pcie" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut0_Pcie()</span></code> | <strong>Feature:</strong> Outbound Read via Reverse TLB Translation | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify outbound path from NOC to PCIe via TLB App Out0</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB App Out0: valid=1, addr=0xA000000000000 (IATU addr)</p></li>
<li><p>Send read from <code class="docutils literal notranslate"><span class="pre">noc_n_target</span></code> with addr=0x10001000000000 (large addr)</p></li>
<li><p>NOC-IO routes to TLB App Out0</p></li>
<li><p>TLB translates to PCIe IATU address</p></li>
<li><p>NOC-PCIE routes to PCIe Controller</p></li>
<li><p>Verify transaction arrives at <code class="docutils literal notranslate"><span class="pre">pcie_controller_initiator</span></code></p></li>
</ol>
<p><strong>Expected Result:</strong> Outbound read completes with reverse translation</p>
<p><strong>Coverage:</strong> Outbound path, reverse TLB, large address handling</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-outbound-002-smn-n-tlb-sys-out0-pcie">
<h4>TC_E2E_OUTBOUND_002: SMN-N → TLB Sys Out0 → PCIe<a class="headerlink" href="#tc-e2e-outbound-002-smn-n-tlb-sys-out0-pcie" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_SmnN_TlbSysOut0_Pcie()</span></code> | <strong>Feature:</strong> System Outbound DBI Access | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify system outbound path</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB Sys Out0: valid=1, addr=0x4000000000 (DBI)</p></li>
<li><p>Send write from <code class="docutils literal notranslate"><span class="pre">smn_n_target</span></code> with system address</p></li>
<li><p>Verify: SMN-N → SMN-IO → TLB Sys Out0 → NOC-PCIE → PCIe</p></li>
<li><p>Translation converts to PCIe DBI address</p></li>
<li><p>Write completes at PCIe controller</p></li>
</ol>
<p><strong>Expected Result:</strong> DBI write successful</p>
<p><strong>Coverage:</strong> System outbound, DBI access, reverse translation</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-outbound-003-noc-n-tlb-app-out1-pcie-dbi">
<h4>TC_E2E_OUTBOUND_003: NOC-N → TLB App Out1 → PCIe DBI<a class="headerlink" href="#tc-e2e-outbound-003-noc-n-tlb-app-out1-pcie-dbi" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut1_PcieDBI()</span></code> | <strong>Feature:</strong> Application DBI Access (64KB Pages) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify application DBI access path</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB App Out1: valid=1, addr=0x9000000000 (DBI)</p></li>
<li><p>Send config read from <code class="docutils literal notranslate"><span class="pre">noc_n_target</span></code> with small address</p></li>
<li><p>NOC-IO routes to TLB App Out1 (64KB pages)</p></li>
<li><p>Translate to PCIe DBI</p></li>
<li><p>Read config space from PCIe</p></li>
</ol>
<p><strong>Expected Result:</strong> Config space read successful</p>
<p><strong>Coverage:</strong> DBI access, small page TLB</p>
</section>
</section>
<hr class="docutils" />
<section id="configuration-paths-smn-tlb-sii-msi-config">
<h3>16.3 Configuration Paths (SMN → TLB/SII/MSI Config)<a class="headerlink" href="#configuration-paths-smn-tlb-sii-msi-config" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-config-001-smn-n-tlb-config">
<h4>TC_E2E_CONFIG_001: SMN-N → TLB Config<a class="headerlink" href="#tc-e2e-config-001-smn-n-tlb-config" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToTlb()</span></code> | <strong>Feature:</strong> TLB Configuration via SMN Path | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify TLB configuration path</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send APB write to <code class="docutils literal notranslate"><span class="pre">smn_n_target</span></code> with addr=0x18210000 (TLB App In0[0] config)</p></li>
<li><p>SMN-IO routes to TLB App In0[0] config interface</p></li>
<li><p>Write TLB entry: valid=1, addr=0x90000000</p></li>
<li><p>Read back and verify</p></li>
<li><p>Use TLB for translation to confirm config applied</p></li>
</ol>
<p><strong>Expected Result:</strong> TLB configuration successful, translation uses new entry</p>
<p><strong>Coverage:</strong> TLB configuration path, config persistence</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-config-002-smn-n-sii-config">
<h4>TC_E2E_CONFIG_002: SMN-N → SII Config<a class="headerlink" href="#tc-e2e-config-002-smn-n-sii-config" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToSII()</span></code> | <strong>Feature:</strong> SII Bus/Device Number Configuration | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify SII configuration</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send APB write to <code class="docutils literal notranslate"><span class="pre">smn_n_target</span></code> with addr=0x18101000 (SII config)</p></li>
<li><p>Write bus/device numbers</p></li>
<li><p>Verify SII outputs updated: app_bus_num, app_dev_num</p></li>
<li><p>Read back via APB</p></li>
</ol>
<p><strong>Expected Result:</strong> SII config applied, outputs updated</p>
<p><strong>Coverage:</strong> SII configuration, bus/dev assignment</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-config-003-smn-n-msi-relay-config">
<h4>TC_E2E_CONFIG_003: SMN-N → MSI Relay Config<a class="headerlink" href="#tc-e2e-config-003-smn-n-msi-relay-config" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToMsiRelay()</span></code> | <strong>Feature:</strong> MSI-X Table Configuration and Persistence | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify MSI-X table configuration</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send APB write to <code class="docutils literal notranslate"><span class="pre">smn_n_target</span></code> with addr=0x18100000 (MSI config)</p></li>
<li><p>Configure MSI-X table entry 0: addr=0x80001000, data=0x1234</p></li>
<li><p>Set vector unmasked, enable MSI-X</p></li>
<li><p>Trigger interrupt with SETIP</p></li>
<li><p>Verify MSI write appears at NOC-N with correct addr/data</p></li>
</ol>
<p><strong>Expected Result:</strong> MSI-X configuration and generation successful</p>
<p><strong>Coverage:</strong> MSI config path, interrupt flow</p>
</section>
</section>
<hr class="docutils" />
<section id="msi-interrupt-flows">
<h3>16.4 MSI Interrupt Flows<a class="headerlink" href="#msi-interrupt-flows" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-msi-001-msi-generation-noc-n">
<h4>TC_E2E_MSI_001: MSI Generation → NOC-N<a class="headerlink" href="#tc-e2e-msi-001-msi-generation-noc-n" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN()</span></code> | <strong>Feature:</strong> MSI Generation and NOC-N Routing | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify MSI interrupt from relay to NOC</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table via SMN config path</p></li>
<li><p>Set SETIP bit for vector 5</p></li>
<li><p>Enable MSI-X globally</p></li>
<li><p>Process pending MSIs</p></li>
<li><p>Verify MSI write transaction appears at <code class="docutils literal notranslate"><span class="pre">noc_n_initiator</span></code></p></li>
<li><p>Verify PBA bit cleared after successful send</p></li>
</ol>
<p><strong>Expected Result:</strong> MSI generated and sent to NOC</p>
<p><strong>Coverage:</strong> MSI thrower logic, NOC routing</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-msi-002-downstream-msi-input-processing">
<h4>TC_E2E_MSI_002: Downstream MSI Input → Processing<a class="headerlink" href="#tc-e2e-msi-002-downstream-msi-input-processing" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_MSI_DownstreamInput_Processing()</span></code> | <strong>Feature:</strong> Downstream MSI Relay Input Path | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify MSI received from downstream</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send MSI write to <code class="docutils literal notranslate"><span class="pre">noc_n_target</span></code> with addr=0x18800000 (MSI Relay input)</p></li>
<li><p>MSI Relay sets PBA bit</p></li>
<li><p>Enable MSI-X</p></li>
<li><p>MSI Relay generates MSI to NOC-N</p></li>
<li><p>Verify complete flow</p></li>
</ol>
<p><strong>Expected Result:</strong> Downstream MSI processed and forwarded</p>
<p><strong>Coverage:</strong> MSI relay input path, PBA update</p>
</section>
</section>
<hr class="docutils" />
<section id="status-register-access">
<h3>16.5 Status Register Access<a class="headerlink" href="#status-register-access" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-status-001-status-register-read-route-0xe">
<h4>TC_E2E_STATUS_001: Status Register Read (Route 0xE)<a class="headerlink" href="#tc-e2e-status-001-status-register-read-route-0xe" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_Read_Route0xE()</span></code> | <strong>Feature:</strong> NOC-PCIE Switch Status Register Special Routing | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify special status register access</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Set system_ready = true in config registers</p></li>
<li><p>Send read from <code class="docutils literal notranslate"><span class="pre">pcie_controller_target</span></code> with addr=0xE000000000000000 (route=0xE)</p></li>
<li><p>NOC-PCIE switch handles internally (no TLB)</p></li>
<li><p>Returns status register value (system_ready bit)</p></li>
<li><p>No external routing</p></li>
</ol>
<p><strong>Expected Result:</strong> Status returned directly, no NOC access</p>
<p><strong>Coverage:</strong> Status register special routing, system ready</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-status-002-status-register-disabled-access">
<h4>TC_E2E_STATUS_002: Status Register Disabled Access<a class="headerlink" href="#tc-e2e-status-002-status-register-disabled-access" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_DisabledAccess()</span></code> | <strong>Feature:</strong> Status Register Access Control (System Not Ready) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify status register blocked when system not ready</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Set system_ready = false</p></li>
<li><p>Send read with addr=0xE000000000000000</p></li>
<li><p>Verify DECERR or normal routing (not status)</p></li>
</ol>
<p><strong>Expected Result:</strong> Status register not accessible when disabled</p>
<p><strong>Coverage:</strong> Status register access control</p>
</section>
</section>
<hr class="docutils" />
<section id="isolation-and-error-handling">
<h3>16.6 Isolation and Error Handling<a class="headerlink" href="#isolation-and-error-handling" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-isolation-001-global-isolation">
<h4>TC_E2E_ISOLATION_001: Global Isolation<a class="headerlink" href="#tc-e2e-isolation-001-global-isolation" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_GlobalBlock()</span></code> | <strong>Feature:</strong> Global Isolation (Block All Data Traffic) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify isolation blocks all traffic</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert isolate_req signal</p></li>
<li><p>Send transactions to all ports: noc_n, smn_n, pcie_controller</p></li>
<li><p>Verify all return DECERR</p></li>
<li><p>Verify timeout signals asserted</p></li>
<li><p>Deassert isolate_req</p></li>
<li><p>Verify traffic resumes</p></li>
</ol>
<p><strong>Expected Result:</strong> Isolation blocks all data paths, recovery works</p>
<p><strong>Coverage:</strong> Isolation mechanism, all switches, timeout generation</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-isolation-002-config-access-during-isolation">
<h4>TC_E2E_ISOLATION_002: Config Access During Isolation<a class="headerlink" href="#tc-e2e-isolation-002-config-access-during-isolation" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_ConfigAccessAllowed()</span></code> | <strong>Feature:</strong> Selective Isolation (Config Path Exception) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify config access remains available during isolation</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert isolate_req</p></li>
<li><p>Send config writes to SMN-N (SII, MSI config)</p></li>
<li><p>Verify config writes succeed (isolation doesn’t block config)</p></li>
<li><p>Send data transactions (blocked)</p></li>
</ol>
<p><strong>Expected Result:</strong> Config accessible, data blocked</p>
<p><strong>Coverage:</strong> Selective isolation, config path exception</p>
</section>
</section>
<hr class="docutils" />
<section id="multi-path-concurrent-traffic">
<h3>16.7 Multi-Path Concurrent Traffic<a class="headerlink" href="#multi-path-concurrent-traffic" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-concurrent-001-simultaneous-inbound-outbound">
<h4>TC_E2E_CONCURRENT_001: Simultaneous Inbound + Outbound<a class="headerlink" href="#tc-e2e-concurrent-001-simultaneous-inbound-outbound" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_InboundOutbound()</span></code> | <strong>Feature:</strong> Concurrent Bidirectional Traffic (No Interference) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify concurrent bidirectional traffic</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send PCIe read (inbound path) simultaneously with NOC write (outbound path)</p></li>
<li><p>Verify both complete without interference</p></li>
<li><p>Check no transaction corruption</p></li>
<li><p>Verify ordering maintained per path</p></li>
</ol>
<p><strong>Expected Result:</strong> Both paths work concurrently</p>
<p><strong>Coverage:</strong> Concurrent operation, no resource conflicts</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-concurrent-002-multiple-tlb-simultaneous-access">
<h4>TC_E2E_CONCURRENT_002: Multiple TLB Simultaneous Access<a class="headerlink" href="#tc-e2e-concurrent-002-multiple-tlb-simultaneous-access" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_MultipleTlbs()</span></code> | <strong>Feature:</strong> TLB Array Concurrent Access and Config | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify multiple TLBs can be accessed concurrently</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transactions to TLB App In0[0], [1], [2], [3] simultaneously</p></li>
<li><p>Configure different TLBs via SMN concurrently</p></li>
<li><p>Verify no conflicts, all complete</p></li>
</ol>
<p><strong>Expected Result:</strong> TLB array supports concurrent access</p>
<p><strong>Coverage:</strong> TLB array, concurrent config and data</p>
</section>
</section>
<hr class="docutils" />
<section id="reset-and-initialization-sequences">
<h3>16.8 Reset and Initialization Sequences<a class="headerlink" href="#reset-and-initialization-sequences" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-reset-001-cold-reset-sequence">
<h4>TC_E2E_RESET_001: Cold Reset Sequence<a class="headerlink" href="#tc-e2e-reset-001-cold-reset-sequence" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Reset_ColdResetSequence()</span></code> | <strong>Feature:</strong> Cold Reset and Full Reinitialization | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify complete cold reset flow</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Assert cold_reset_n = 0</p></li>
<li><p>Verify all internal states cleared</p></li>
<li><p>Verify all outputs in reset state</p></li>
<li><p>Deassert cold_reset_n = 1</p></li>
<li><p>Configure tile (TLBs, MSI, SII)</p></li>
<li><p>Send test transactions</p></li>
<li><p>Verify normal operation</p></li>
</ol>
<p><strong>Expected Result:</strong> Clean reset and initialization</p>
<p><strong>Coverage:</strong> Cold reset, initialization sequence</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-reset-002-warm-reset-sequence">
<h4>TC_E2E_RESET_002: Warm Reset Sequence<a class="headerlink" href="#tc-e2e-reset-002-warm-reset-sequence" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Reset_WarmResetSequence()</span></code> | <strong>Feature:</strong> Warm Reset (Config Preservation) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify warm reset (preserves config)</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLBs and MSI</p></li>
<li><p>Assert warm_reset_n = 0 (cold_reset_n = 1)</p></li>
<li><p>Verify data path blocked</p></li>
<li><p>Verify config preserved</p></li>
<li><p>Deassert warm_reset_n</p></li>
<li><p>Verify transactions resume without reconfiguration</p></li>
</ol>
<p><strong>Expected Result:</strong> Warm reset blocks data, preserves config</p>
<p><strong>Coverage:</strong> Warm reset, config persistence</p>
</section>
</section>
<hr class="docutils" />
<section id="complete-transaction-flows">
<h3>16.9 Complete Transaction Flows<a class="headerlink" href="#complete-transaction-flows" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-flow-001-pcie-memory-read-noc-memory-response">
<h4>TC_E2E_FLOW_001: PCIe Memory Read → NOC → Memory → Response<a class="headerlink" href="#tc-e2e-flow-001-pcie-memory-read-noc-memory-response" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryRead_Complete()</span></code> | <strong>Feature:</strong> Complete PCIe Memory Read Cycle (End-to-End) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Full memory read flow</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure complete inbound path (TLB, switches, enables)</p></li>
<li><p>PCIe sends memory read to addr=0x0123456789ABC (via TLB App In0)</p></li>
<li><p>Translate to physical addr</p></li>
<li><p>Route via NOC-IO to NOC-N</p></li>
<li><p>External memory responds with data</p></li>
<li><p>Response propagates back: NOC-N → NOC-IO → TLB → NOC-PCIE → PCIe</p></li>
<li><p>Verify data integrity end-to-end</p></li>
<li><p>Verify latency within spec</p></li>
</ol>
<p><strong>Expected Result:</strong> Complete read cycle successful</p>
<p><strong>Coverage:</strong> Full inbound read flow, response path</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-flow-002-pcie-memory-write-noc-memory-completion">
<h4>TC_E2E_FLOW_002: PCIe Memory Write → NOC → Memory → Completion<a class="headerlink" href="#tc-e2e-flow-002-pcie-memory-write-noc-memory-completion" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryWrite_Complete()</span></code> | <strong>Feature:</strong> Complete PCIe Memory Write Cycle (End-to-End) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Full memory write flow</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure outbound enables</p></li>
<li><p>PCIe sends memory write with 256-bit data</p></li>
<li><p>Path: PCIe → NOC-PCIE → TLB App In0 → NOC-IO → NOC-N → Memory</p></li>
<li><p>Verify write data intact</p></li>
<li><p>Response returns</p></li>
<li><p>Verify write completion signaled</p></li>
</ol>
<p><strong>Expected Result:</strong> Write completes successfully</p>
<p><strong>Coverage:</strong> Full inbound write flow, large data</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-flow-003-noc-memory-read-pcie-controller">
<h4>TC_E2E_FLOW_003: NOC Memory Read → PCIe Controller<a class="headerlink" href="#tc-e2e-flow-003-noc-memory-read-pcie-controller" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Flow_NocMemoryRead_ToPcie()</span></code> | <strong>Feature:</strong> Outbound NOC-to-PCIe Memory Read | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Outbound read from NOC to PCIe</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB App Out0 for large address space</p></li>
<li><p>NOC sends read with addr &gt; 256TB</p></li>
<li><p>Path: NOC-N → NOC-IO → TLB App Out0 → NOC-PCIE → PCIe</p></li>
<li><p>PCIe returns data</p></li>
<li><p>Response: PCIe → NOC-PCIE → TLB → NOC-IO → NOC-N</p></li>
</ol>
<p><strong>Expected Result:</strong> Outbound read successful</p>
<p><strong>Coverage:</strong> Outbound read, reverse translation</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-flow-004-smn-config-write-pcie-dbi">
<h4>TC_E2E_FLOW_004: SMN Config Write → PCIe DBI<a class="headerlink" href="#tc-e2e-flow-004-smn-config-write-pcie-dbi" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Flow_SmnConfigWrite_PcieDBI()</span></code> | <strong>Feature:</strong> SMN-to-PCIe DBI Configuration Access | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> DBI access from SMN</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>SMN sends config write to DBI address</p></li>
<li><p>Path: SMN-N → SMN-IO → TLB Sys Out0 → NOC-PCIE → PCIe DBI</p></li>
<li><p>PCIe DBI responds</p></li>
<li><p>Response returns via same path</p></li>
</ol>
<p><strong>Expected Result:</strong> DBI config write successful</p>
<p><strong>Coverage:</strong> DBI path, SMN-to-PCIe routing</p>
</section>
</section>
<hr class="docutils" />
<section id="error-injection-and-recovery">
<h3>16.10 Error Injection and Recovery<a class="headerlink" href="#error-injection-and-recovery" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-error-001-invalid-tlb-entry">
<h4>TC_E2E_ERROR_001: Invalid TLB Entry<a class="headerlink" href="#tc-e2e-error-001-invalid-tlb-entry" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Error_InvalidTlbEntry()</span></code> | <strong>Feature:</strong> TLB Invalid Entry Error Detection and Recovery | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify error handling with invalid TLB</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure TLB entry: valid=0</p></li>
<li><p>Send transaction that maps to invalid entry</p></li>
<li><p>Verify DECERR returned</p></li>
<li><p>Verify no downstream propagation</p></li>
<li><p>Configure entry: valid=1</p></li>
<li><p>Retry transaction</p></li>
<li><p>Verify success</p></li>
</ol>
<p><strong>Expected Result:</strong> Error detected, recovery works</p>
<p><strong>Coverage:</strong> TLB error detection, error propagation</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-error-002-timeout-handling">
<h4>TC_E2E_ERROR_002: Timeout Handling<a class="headerlink" href="#tc-e2e-error-002-timeout-handling" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Error_TimeoutHandling()</span></code> | <strong>Feature:</strong> Timeout Detection and Recovery on Stalled Transactions | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify timeout on stalled transactions</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction to NOC-N</p></li>
<li><p>Don’t respond (simulate stall)</p></li>
<li><p>Wait for timeout period</p></li>
<li><p>Verify timeout signal asserted</p></li>
<li><p>Verify error response returned</p></li>
<li><p>Clear timeout, verify recovery</p></li>
</ol>
<p><strong>Expected Result:</strong> Timeout detected and handled</p>
<p><strong>Coverage:</strong> Timeout mechanism, error recovery</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-error-003-address-decode-error">
<h4>TC_E2E_ERROR_003: Address Decode Error<a class="headerlink" href="#tc-e2e-error-003-address-decode-error" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Error_AddressDecodeError()</span></code> | <strong>Feature:</strong> Address Decode DECERR for Unmapped Regions | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify DECERR for unmapped addresses</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction with route=0xA (DECERR region)</p></li>
<li><p>Verify NOC-PCIE returns DECERR immediately</p></li>
<li><p>No downstream routing</p></li>
<li><p>Send to DECERR region in NOC-IO (0x18A00000)</p></li>
<li><p>Verify DECERR returned</p></li>
</ol>
<p><strong>Expected Result:</strong> DECERR for all unmapped regions</p>
<p><strong>Coverage:</strong> Address decode, DECERR handling</p>
</section>
</section>
<hr class="docutils" />
<section id="msi-x-end-to-end-flow">
<h3>16.11 MSI-X End-to-End Flow<a class="headerlink" href="#msi-x-end-to-end-flow" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-msix-001-complete-msi-x-interrupt-flow">
<h4>TC_E2E_MSIX_001: Complete MSI-X Interrupt Flow<a class="headerlink" href="#tc-e2e-msix-001-complete-msi-x-interrupt-flow" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_CompleteMsixInterruptFlow()</span></code> | <strong>Feature:</strong> Complete MSI-X Interrupt Config, Generation, and Delivery | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify entire MSI-X interrupt generation and delivery</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure MSI-X table via SMN: addr=0x18100000, entry[0]={addr:0x80002000, data:0x5678}</p></li>
<li><p>Downstream device writes to MSI Relay: addr=0x18800000, data=vector_0</p></li>
<li><p>MSI Relay sets PBA[0]</p></li>
<li><p>Enable MSI-X, unmask vector 0</p></li>
<li><p>MSI Relay generates AXI write to addr=0x80002000, data=0x5678</p></li>
<li><p>Route via NOC-IO to NOC-N</p></li>
<li><p>External interrupt controller receives MSI</p></li>
<li><p>PBA[0] cleared</p></li>
<li><p>Read PBA and verify cleared</p></li>
</ol>
<p><strong>Expected Result:</strong> Complete MSI-X flow successful</p>
<p><strong>Coverage:</strong> MSI config, generation, routing, PBA management</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-msix-002-multiple-vector-interrupts">
<h4>TC_E2E_MSIX_002: Multiple Vector Interrupts<a class="headerlink" href="#tc-e2e-msix-002-multiple-vector-interrupts" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_MultipleVectors()</span></code> | <strong>Feature:</strong> Multiple MSI-X Vector Configuration and Handling | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify multiple MSI-X vectors</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure 4 MSI-X vectors with different addresses</p></li>
<li><p>Set PBA bits for vectors 0, 2, 5, 7</p></li>
<li><p>Enable MSI-X</p></li>
<li><p>Verify each MSI generated sequentially</p></li>
<li><p>Verify correct address/data per vector</p></li>
<li><p>Verify PBA bits cleared</p></li>
</ol>
<p><strong>Expected Result:</strong> Multiple MSI-X vectors delivered correctly</p>
<p><strong>Coverage:</strong> Multi-vector MSI, sequential processing</p>
</section>
</section>
<hr class="docutils" />
<section id="clock-domain-crossing">
<h3>16.12 Clock Domain Crossing<a class="headerlink" href="#clock-domain-crossing" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-cdc-001-axi-clock-pcie-clock">
<h4>TC_E2E_CDC_001: AXI Clock → PCIe Clock<a class="headerlink" href="#tc-e2e-cdc-001-axi-clock-pcie-clock" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_CDC_AxiToPcieClock()</span></code> | <strong>Feature:</strong> Clock Domain Crossing (AXI ↔ PCIe Core) in SII | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify clock domain crossing in SII</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send config write on axi_clk domain to SII</p></li>
<li><p>Verify data synchronized to pcie_core_clk domain</p></li>
<li><p>SII outputs update on pcie_core_clk</p></li>
<li><p>Send CII update on pcie_core_clk</p></li>
<li><p>Verify interrupt generated to axi_clk domain</p></li>
</ol>
<p><strong>Expected Result:</strong> CDC works correctly, no metastability</p>
<p><strong>Coverage:</strong> Clock domain crossing, SII CDC logic</p>
</section>
</section>
<hr class="docutils" />
<section id="performance-and-stress-tests">
<h3>16.13 Performance and Stress Tests<a class="headerlink" href="#performance-and-stress-tests" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-perf-001-maximum-throughput-test">
<h4>TC_E2E_PERF_001: Maximum Throughput Test<a class="headerlink" href="#tc-e2e-perf-001-maximum-throughput-test" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Perf_MaximumThroughput()</span></code> | <strong>Feature:</strong> Maximum Transaction Rate (Back-to-Back Burst) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify tile handles maximum transaction rate</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send back-to-back transactions on all ports</p></li>
<li><p>PCIe inbound at max rate</p></li>
<li><p>NOC/SMN outbound at max rate</p></li>
<li><p>MSI interrupts at max rate</p></li>
<li><p>Monitor for buffer overflow, dropped transactions</p></li>
<li><p>Verify all complete successfully</p></li>
</ol>
<p><strong>Expected Result:</strong> No transactions lost, all complete</p>
<p><strong>Coverage:</strong> Performance limits, buffer management</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-stress-001-address-space-sweep">
<h4>TC_E2E_STRESS_001: Address Space Sweep<a class="headerlink" href="#tc-e2e-stress-001-address-space-sweep" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Stress_AddressSpaceSweep()</span></code> | <strong>Feature:</strong> Complete Address Space Routing Sweep (All Routes) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Sweep entire address space</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transactions to all possible route values (0x0-0xF)</p></li>
<li><p>Send to all address ranges (TLB, config, MSI, DECERR)</p></li>
<li><p>Mix reads and writes</p></li>
<li><p>Verify correct routing for each</p></li>
<li><p>Verify no unexpected errors</p></li>
</ol>
<p><strong>Expected Result:</strong> All addresses handled correctly</p>
<p><strong>Coverage:</strong> Complete address space, routing table</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-stress-002-tlb-entry-exhaustion">
<h4>TC_E2E_STRESS_002: TLB Entry Exhaustion<a class="headerlink" href="#tc-e2e-stress-002-tlb-entry-exhaustion" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Stress_TlbEntryExhaustion()</span></code> | <strong>Feature:</strong> Full TLB Capacity (64 Entries) and Dynamic Reconfiguration | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify behavior with all TLB entries used</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Configure all 64 entries in TLB App In0</p></li>
<li><p>Send transactions that map to each entry</p></li>
<li><p>Verify all translations correct</p></li>
<li><p>Reconfigure entries during traffic</p></li>
<li><p>Verify atomic update</p></li>
</ol>
<p><strong>Expected Result:</strong> Full TLB usage works, dynamic reconfiguration</p>
<p><strong>Coverage:</strong> TLB capacity, dynamic config</p>
</section>
</section>
<hr class="docutils" />
<section id="power-management">
<h3>16.14 Power Management<a class="headerlink" href="#power-management" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-power-001-isolation-mode-entry-exit">
<h4>TC_E2E_POWER_001: Isolation Mode Entry/Exit<a class="headerlink" href="#tc-e2e-power-001-isolation-mode-entry-exit" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Power_IsolationModeEntryExit()</span></code> | <strong>Feature:</strong> Power Management Isolation Entry/Exit with Traffic | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify complete isolation sequence</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Normal operation with active traffic</p></li>
<li><p>Assert isolate_req</p></li>
<li><p>Verify in-flight transactions complete</p></li>
<li><p>Verify new transactions blocked</p></li>
<li><p>Verify config access still available</p></li>
<li><p>Deassert isolate_req</p></li>
<li><p>Verify traffic resumes</p></li>
</ol>
<p><strong>Expected Result:</strong> Clean isolation entry/exit</p>
<p><strong>Coverage:</strong> Isolation, power management, recovery</p>
</section>
</section>
<hr class="docutils" />
<section id="system-integration-scenarios">
<h3>16.15 System Integration Scenarios<a class="headerlink" href="#system-integration-scenarios" title="Permalink to this heading"></a></h3>
<section id="tc-e2e-system-001-boot-sequence">
<h4>TC_E2E_SYSTEM_001: Boot Sequence<a class="headerlink" href="#tc-e2e-system-001-boot-sequence" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_System_BootSequence()</span></code> | <strong>Feature:</strong> Complete Tile Boot and Initialization | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify complete tile initialization</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Cold reset asserted</p></li>
<li><p>Release cold reset</p></li>
<li><p>PLL locks</p></li>
<li><p>PHY initializes</p></li>
<li><p>SMC configures all TLBs</p></li>
<li><p>SMC configures MSI-X</p></li>
<li><p>SMC writes system_ready = 1</p></li>
<li><p>PCIe link up</p></li>
<li><p>First transaction from PCIe</p></li>
<li><p>Complete successfully</p></li>
</ol>
<p><strong>Expected Result:</strong> Boot sequence successful, first transaction works</p>
<p><strong>Coverage:</strong> Complete initialization, boot flow</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-system-002-shutdown-sequence">
<h4>TC_E2E_SYSTEM_002: Shutdown Sequence<a class="headerlink" href="#tc-e2e-system-002-shutdown-sequence" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_System_ShutdownSequence()</span></code> | <strong>Feature:</strong> Graceful Shutdown (Drain → Isolate → Reset) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify clean shutdown</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Active traffic on all paths</p></li>
<li><p>SMC writes system_ready = 0</p></li>
<li><p>Drain in-flight transactions</p></li>
<li><p>Assert isolation</p></li>
<li><p>Warm reset</p></li>
<li><p>Cold reset</p></li>
<li><p>Verify clean shutdown, no hangs</p></li>
</ol>
<p><strong>Expected Result:</strong> Graceful shutdown</p>
<p><strong>Coverage:</strong> Shutdown sequence, drain logic</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-system-003-error-recovery-scenario">
<h4>TC_E2E_SYSTEM_003: Error Recovery Scenario<a class="headerlink" href="#tc-e2e-system-003-error-recovery-scenario" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_System_ErrorRecovery()</span></code> | <strong>Feature:</strong> Error Injection and Recovery (Fault Tolerance) | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify recovery from error conditions</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Inject TLB error (invalid entry)</p></li>
<li><p>Transaction fails with DECERR</p></li>
<li><p>Fix TLB configuration</p></li>
<li><p>Retry transaction</p></li>
<li><p>Success</p></li>
<li><p>Inject timeout</p></li>
<li><p>Recover</p></li>
<li><p>Verify normal operation resumes</p></li>
</ol>
<p><strong>Expected Result:</strong> All errors recoverable</p>
<p><strong>Coverage:</strong> Error recovery, fault tolerance</p>
</section>
</section>
<hr class="docutils" />
<section id="refactored-architecture-validation">
<h3>16.16 Refactored Architecture Validation<a class="headerlink" href="#refactored-architecture-validation" title="Permalink to this heading"></a></h3>
<p><strong>Note:</strong> These tests specifically validate the refactored C++ class architecture</p>
<section id="tc-e2e-refactor-001-function-callback-chain">
<h4>TC_E2E_REFACTOR_001: Function Callback Chain<a class="headerlink" href="#tc-e2e-refactor-001-function-callback-chain" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Refactor_FunctionCallbackChain()</span></code> | <strong>Feature:</strong> Refactored C++ Function Callback Architecture | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify function callbacks work correctly</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Send transaction through complete chain: External socket → Switch → TLB → Switch → External socket</p></li>
<li><p>Trace execution through all function callbacks</p></li>
<li><p>Verify no callback dropped</p></li>
<li><p>Verify timing maintained</p></li>
<li><p>Compare with original socket-based behavior</p></li>
</ol>
<p><strong>Expected Result:</strong> Function callbacks equivalent to sockets</p>
<p><strong>Coverage:</strong> Callback mechanism, refactored architecture</p>
</section>
<hr class="docutils" />
<section id="tc-e2e-refactor-002-no-internal-sockets-remain">
<h4>TC_E2E_REFACTOR_002: No Internal Sockets Remain<a class="headerlink" href="#tc-e2e-refactor-002-no-internal-sockets-remain" title="Permalink to this heading"></a></h4>
<blockquote>
<div><p><strong>Test Function:</strong> <code class="docutils literal notranslate"><span class="pre">testE2E_Refactor_NoInternalSockets_E126Check()</span></code> | <strong>Feature:</strong> E126 Error Elimination / FastBuild Compatibility | <strong>Status:</strong> ✅ PASS</p>
</div></blockquote>
<p><strong>Objective:</strong> Verify FastBuild only sees external sockets</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Run with SCML2 FastBuild coverage enabled</p></li>
<li><p>Verify no E126 errors</p></li>
<li><p>Verify coverage only instruments 6 top-level sockets</p></li>
<li><p>Verify internal C++ classes not instrumented</p></li>
<li><p>Collect coverage data</p></li>
</ol>
<p><strong>Expected Result:</strong> ✅ NO E126 ERRORS, coverage works</p>
<p><strong>Coverage:</strong> FastBuild compatibility validation</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="coverage-goals">
<h2>17. Coverage Goals<a class="headerlink" href="#coverage-goals" title="Permalink to this heading"></a></h2>
</section>
<section id="id3">
<h2>16. Coverage Goals<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h2>
<section id="functional-coverage">
<h3>16.1 Functional Coverage<a class="headerlink" href="#functional-coverage" title="Permalink to this heading"></a></h3>
<section id="tlb-coverage">
<h4>TLB Coverage<a class="headerlink" href="#tlb-coverage" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Entry Coverage:</strong> All TLB entries accessed at least once</p></li>
<li><p><strong>Valid/Invalid Coverage:</strong> Both valid and invalid entries tested</p></li>
<li><p><strong>Index Coverage:</strong> All possible index values tested</p></li>
<li><p><strong>Address Range Coverage:</strong> Min, max, and boundary addresses</p></li>
<li><p><strong>Page Boundary Coverage:</strong> Addresses at page boundaries</p></li>
<li><p><strong>Port Coverage:</strong> All port values (0, 1, 4, 8, 9) for inbound TLBs</p></li>
</ul>
</section>
<section id="msi-relay-coverage">
<h4>MSI Relay Coverage<a class="headerlink" href="#msi-relay-coverage" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Vector Coverage:</strong> All 16 vectors tested</p></li>
<li><p><strong>PBA Coverage:</strong> All PBA bit combinations</p></li>
<li><p><strong>Enable/Mask Coverage:</strong> All enable/mask combinations</p></li>
<li><p><strong>Table Entry Coverage:</strong> All MSI-X table entries configured</p></li>
<li><p><strong>Address Coverage:</strong> Various MSI addresses tested</p></li>
</ul>
</section>
<section id="switch-coverage">
<h4>Switch Coverage<a class="headerlink" href="#switch-coverage" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Routing Coverage:</strong> All routing paths tested (NOC-PCIE: 16 routes, NOC-IO: all address ranges, SMN-IO: all address ranges)</p></li>
<li><p><strong>Address Decoding Coverage:</strong> All address bits tested</p></li>
<li><p><strong>Isolation Coverage:</strong> Isolation behavior for all switches</p></li>
<li><p><strong>Timeout Coverage:</strong> Timeout detection for NOC-IO and SMN-IO</p></li>
<li><p><strong>Enable Control Coverage:</strong> All enable combinations tested</p></li>
</ul>
</section>
<section id="sii-coverage">
<h4>SII Coverage<a class="headerlink" href="#sii-coverage" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p><strong>CII Tracking Coverage:</strong> All config register updates tracked</p></li>
<li><p><strong>Register Access Coverage:</strong> All SII registers accessed</p></li>
<li><p><strong>Interrupt Coverage:</strong> Config update interrupt generation</p></li>
</ul>
</section>
<section id="config-register-coverage">
<h4>Config Register Coverage<a class="headerlink" href="#config-register-coverage" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p><strong>TLB Config Coverage:</strong> All TLB configuration spaces accessed</p></li>
<li><p><strong>Status Register Coverage:</strong> System Ready and Enable registers tested</p></li>
<li><p><strong>Isolation Coverage:</strong> Isolation behavior for config registers</p></li>
</ul>
</section>
<section id="clock-reset-coverage">
<h4>Clock/Reset Coverage<a class="headerlink" href="#clock-reset-coverage" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Reset Sequence Coverage:</strong> Cold reset, warm reset, isolation</p></li>
<li><p><strong>Clock Generation Coverage:</strong> All clock outputs verified</p></li>
<li><p><strong>Reset Timing Coverage:</strong> Reset deassertion timing verified</p></li>
</ul>
</section>
<section id="phy-coverage">
<h4>PHY Coverage<a class="headerlink" href="#phy-coverage" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Configuration Coverage:</strong> APB and AHB configuration tested</p></li>
<li><p><strong>Initialization Coverage:</strong> PHY initialization sequence verified</p></li>
<li><p><strong>Lane Reversal Coverage:</strong> Lane reversal configuration tested</p></li>
</ul>
</section>
</section>
<section id="code-coverage">
<h3>16.2 Code Coverage<a class="headerlink" href="#code-coverage" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Statement Coverage:</strong> &gt;95%</p></li>
<li><p><strong>Branch Coverage:</strong> &gt;90%</p></li>
<li><p><strong>Condition Coverage:</strong> &gt;85%</p></li>
<li><p><strong>Path Coverage:</strong> Critical paths 100%</p></li>
</ul>
</section>
<section id="specification-coverage">
<h3>16.3 Specification Coverage<a class="headerlink" href="#specification-coverage" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Address Translation Algorithms:</strong> 100%</p></li>
<li><p><strong>Error Handling:</strong> 100%</p></li>
<li><p><strong>Register Access:</strong> 100%</p></li>
<li><p><strong>MSI Generation:</strong> 100%</p></li>
<li><p><strong>Switch Routing:</strong> 100% of routing table entries</p></li>
<li><p><strong>Reset Sequences:</strong> 100% (Cold, Warm, Isolation)</p></li>
<li><p><strong>Clock Generation:</strong> 100%</p></li>
<li><p><strong>Integration Scenarios:</strong> Key scenarios covered</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="test-infrastructure">
<h2>17. Test Infrastructure<a class="headerlink" href="#test-infrastructure" title="Permalink to this heading"></a></h2>
<section id="testbench-components">
<h3>9.1 Testbench Components<a class="headerlink" href="#testbench-components" title="Permalink to this heading"></a></h3>
<section id="stimulus-generator">
<h4>Stimulus Generator<a class="headerlink" href="#stimulus-generator" title="Permalink to this heading"></a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TlbStimulusGenerator</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">generate_tlb_test</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">tlb_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">entry_index</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">generate_address_range_test</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">generate_error_test</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="monitor">
<h4>Monitor<a class="headerlink" href="#monitor" title="Permalink to this heading"></a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TlbMonitor</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">monitor_transaction</span><span class="p">(</span><span class="n">tlm</span><span class="o">::</span><span class="n">tlm_generic_payload</span><span class="o">&amp;</span><span class="w"> </span><span class="n">trans</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">check_translation</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">output</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">check_axuser</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">axuser</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="reference-model">
<h4>Reference Model<a class="headerlink" href="#reference-model" title="Permalink to this heading"></a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TlbReferenceModel</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">lookup</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">translated</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">axuser</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">configure_entry</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TlbEntry</span><span class="o">&amp;</span><span class="w"> </span><span class="n">entry</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="test-utilities">
<h3>9.2 Test Utilities<a class="headerlink" href="#test-utilities" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><strong>TLB Entry Builder:</strong> Helper to create TLB entries</p></li>
<li><p><strong>Transaction Builder:</strong> Helper to create TLM transactions</p></li>
<li><p><strong>Coverage Collector:</strong> Tracks coverage metrics</p></li>
<li><p><strong>Scoreboard:</strong> Compares DUT vs reference model</p></li>
</ul>
</section>
<section id="test-configuration">
<h3>9.3 Test Configuration<a class="headerlink" href="#test-configuration" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Test Length:</strong> Configurable simulation length</p></li>
<li><p><strong>Random Seed:</strong> Configurable for reproducibility</p></li>
<li><p><strong>Verbosity:</strong> Configurable debug output</p></li>
<li><p><strong>Checkpoints:</strong> Save/restore simulation state</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="regression-testing">
<h2>18. Regression Testing<a class="headerlink" href="#regression-testing" title="Permalink to this heading"></a></h2>
<section id="regression-suite">
<h3>10.1 Regression Suite<a class="headerlink" href="#regression-suite" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Basic Functionality:</strong> All basic test cases</p></li>
<li><p><strong>Error Cases:</strong> All error handling tests</p></li>
<li><p><strong>Integration:</strong> All integration tests</p></li>
<li><p><strong>Performance:</strong> Performance benchmarks</p></li>
</ul>
</section>
<section id="regression-criteria">
<h3>10.2 Regression Criteria<a class="headerlink" href="#regression-criteria" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Pass Rate:</strong> 100% of tests must pass</p></li>
<li><p><strong>Performance:</strong> No regression in simulation speed</p></li>
<li><p><strong>Coverage:</strong> Maintain coverage goals</p></li>
</ul>
</section>
<section id="continuous-integration">
<h3>10.3 Continuous Integration<a class="headerlink" href="#continuous-integration" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Automated Runs:</strong> Nightly regression runs</p></li>
<li><p><strong>Coverage Reports:</strong> Automated coverage collection</p></li>
<li><p><strong>Failure Analysis:</strong> Automated failure reporting</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="appendix-a-unit-integration-test-case-summary-sections-4-15">
<h2>Appendix A: Unit/Integration Test Case Summary (Sections 4-15)<a class="headerlink" href="#appendix-a-unit-integration-test-case-summary-sections-4-15" title="Permalink to this heading"></a></h2>
<blockquote>
<div><p><strong>Note:</strong> The test cases in Sections 4-15 describe granular unit/integration scenarios. These are covered <strong>indirectly</strong> through the End-to-End tests (Section 16) which exercise complete data paths through all sub-components. See the E2E test table (Appendix A.2) for the implemented test functions.</p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Test ID</p></th>
<th class="head"><p>Component</p></th>
<th class="head"><p>Category</p></th>
<th class="head"><p>Priority</p></th>
<th class="head"><p>Covered By E2E Test(s)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>TC_INBOUND_SYS_001</p></td>
<td><p>TLBSysIn0</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_Pcie_TlbSys_SmnN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INBOUND_SYS_002</p></td>
<td><p>TLBSysIn0</p></td>
<td><p>Error</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_InvalidTlbEntry</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INBOUND_SYS_003</p></td>
<td><p>TLBSysIn0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToTlb</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INBOUND_SYS_004</p></td>
<td><p>TLBSysIn0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryRead_Complete</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INBOUND_SYS_005</p></td>
<td><p>TLBSysIn0</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_Pcie_TlbSys_SmnN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INBOUND_SYS_006</p></td>
<td><p>TLBSysIn0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassApp</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INBOUND_APP0_001</p></td>
<td><p>TLBAppIn0</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieRead_TlbApp0_NocN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INBOUND_APP0_002</p></td>
<td><p>TLBAppIn0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_MultipleTlbs</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INBOUND_APP0_003</p></td>
<td><p>TLBAppIn0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryRead_Complete</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INBOUND_APP0_004</p></td>
<td><p>TLBAppIn0</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieRead_TlbApp0_NocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INBOUND_APP1_001</p></td>
<td><p>TLBAppIn1</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INBOUND_APP1_002</p></td>
<td><p>TLBAppIn1</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INBOUND_APP1_003</p></td>
<td><p>TLBAppIn1</p></td>
<td><p>Integration</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_OUTBOUND_SYS_001</p></td>
<td><p>TLBSysOut0</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_SmnN_TlbSysOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_OUTBOUND_SYS_002</p></td>
<td><p>TLBSysOut0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_SmnConfigWrite_PcieDBI</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_OUTBOUND_SYS_003</p></td>
<td><p>TLBSysOut0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_SmnN_TlbSysOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_OUTBOUND_APP0_001</p></td>
<td><p>TLBAppOut0</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_OUTBOUND_APP0_002</p></td>
<td><p>TLBAppOut0</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_OUTBOUND_APP0_003</p></td>
<td><p>TLBAppOut0</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_NocMemoryRead_ToPcie</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_OUTBOUND_APP1_001</p></td>
<td><p>TLBAppOut1</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut1_PcieDBI</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_OUTBOUND_APP1_002</p></td>
<td><p>TLBAppOut1</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut1_PcieDBI</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_MSI_RELAY_001</p></td>
<td><p>MSI Relay</p></td>
<td><p>Register</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_MSI_RELAY_002</p></td>
<td><p>MSI Relay</p></td>
<td><p>Register</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToMsiRelay</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_MSI_RELAY_003</p></td>
<td><p>MSI Relay</p></td>
<td><p>Register</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_MSI_RELAY_004</p></td>
<td><p>MSI Relay</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_MSI_RELAY_005</p></td>
<td><p>MSI Relay</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToMsiRelay</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_MSI_RELAY_006</p></td>
<td><p>MSI Relay</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToMsiRelay</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_MSI_RELAY_007</p></td>
<td><p>MSI Relay</p></td>
<td><p>Functional</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_MultipleVectors</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_MSI_RELAY_008</p></td>
<td><p>MSI Relay</p></td>
<td><p>Error</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_AddressDecodeError</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_MSI_RELAY_009</p></td>
<td><p>MSI Relay</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_MultipleVectors</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_MSI_RELAY_010</p></td>
<td><p>MSI Relay</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_CompleteMsixInterruptFlow</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_MSI_RELAY_011</p></td>
<td><p>MSI Relay</p></td>
<td><p>Functional</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_MultipleVectors</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INTEGRATION_001</p></td>
<td><p>Integration</p></td>
<td><p>Integration</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToMsiRelay</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INTEGRATION_002</p></td>
<td><p>Integration</p></td>
<td><p>Integration</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_INTEGRATION_003</p></td>
<td><p>Integration</p></td>
<td><p>Integration</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_InboundOutbound</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_INTEGRATION_004</p></td>
<td><p>Integration</p></td>
<td><p>Integration</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryRead_Complete</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SWITCH_NOC_PCIE_001</p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p>Routing</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieRead_TlbApp0_NocN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SWITCH_NOC_PCIE_002</p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p>Routing</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_Read_Route0xE</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SWITCH_NOC_PCIE_003</p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p>Isolation</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_GlobalBlock</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SWITCH_NOC_PCIE_004</p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p>Control</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SWITCH_NOC_PCIE_005</p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p>Bypass</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassApp</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SWITCH_NOC_PCIE_006</p></td>
<td><p>NOC-PCIE Switch</p></td>
<td><p>Address Conv</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassApp</span></code>, <code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassSys</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SWITCH_NOC_IO_001</p></td>
<td><p>NOC-IO Switch</p></td>
<td><p>Routing</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_DownstreamInput_Processing</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SWITCH_NOC_IO_002</p></td>
<td><p>NOC-IO Switch</p></td>
<td><p>External</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_NocMemoryRead_ToPcie</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SWITCH_NOC_IO_003</p></td>
<td><p>NOC-IO Switch</p></td>
<td><p>Routing</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SWITCH_NOC_IO_004</p></td>
<td><p>NOC-IO Switch</p></td>
<td><p>Timeout</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_TimeoutHandling</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SWITCH_SMN_IO_001</p></td>
<td><p>SMN-IO Switch</p></td>
<td><p>Routing</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToTlb</span></code>, <code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToSII</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SWITCH_SMN_IO_002</p></td>
<td><p>SMN-IO Switch</p></td>
<td><p>SerDes</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Stress_AddressSpaceSweep</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SWITCH_SMN_IO_003</p></td>
<td><p>SMN-IO Switch</p></td>
<td><p>External</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_SmnN_TlbSysOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SWITCH_SMN_IO_004</p></td>
<td><p>SMN-IO Switch</p></td>
<td><p>Timeout</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_TimeoutHandling</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SII_001</p></td>
<td><p>SII Block</p></td>
<td><p>Register</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToSII</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_SII_002</p></td>
<td><p>SII Block</p></td>
<td><p>CII Tracking</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_CDC_AxiToPcieClock</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_SII_003</p></td>
<td><p>SII Block</p></td>
<td><p>Control</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToSII</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_CONFIG_REG_001</p></td>
<td><p>Config Reg</p></td>
<td><p>TLB Config</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToTlb</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_CONFIG_REG_002</p></td>
<td><p>Config Reg</p></td>
<td><p>Status</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_Read_Route0xE</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_CONFIG_REG_003</p></td>
<td><p>Config Reg</p></td>
<td><p>Enable</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_CONFIG_REG_004</p></td>
<td><p>Config Reg</p></td>
<td><p>Isolation</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_GlobalBlock</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_CLOCK_RESET_001</p></td>
<td><p>Clock/Reset</p></td>
<td><p>Clock Gen</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_ColdResetSequence</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_CLOCK_RESET_002</p></td>
<td><p>Clock/Reset</p></td>
<td><p>Clock Gen</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_ColdResetSequence</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_CLOCK_RESET_003</p></td>
<td><p>Clock/Reset</p></td>
<td><p>Reset Seq</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_ColdResetSequence</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_CLOCK_RESET_004</p></td>
<td><p>Clock/Reset</p></td>
<td><p>Reset Seq</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_WarmResetSequence</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_CLOCK_RESET_005</p></td>
<td><p>Clock/Reset</p></td>
<td><p>Isolation</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_GlobalBlock</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_PLL_CGM_001</p></td>
<td><p>PLL/CGM</p></td>
<td><p>Lock</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_BootSequence</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_PLL_CGM_002</p></td>
<td><p>PLL/CGM</p></td>
<td><p>Config</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_ShutdownSequence</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_PHY_001</p></td>
<td><p>PHY Model</p></td>
<td><p>Config</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_BootSequence</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_PHY_002</p></td>
<td><p>PHY Model</p></td>
<td><p>Firmware</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Stress_AddressSpaceSweep</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_PHY_003</p></td>
<td><p>PHY Model</p></td>
<td><p>Lane Rev</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Stress_AddressSpaceSweep</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_EXTERNAL_NOC_001</p></td>
<td><p>NOC-N Interface</p></td>
<td><p>Forwarding</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_EXTERNAL_SMN_001</p></td>
<td><p>SMN-N Interface</p></td>
<td><p>Forwarding</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_SmnN_TlbSysOut0_Pcie</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_TOP_LEVEL_001</p></td>
<td><p>Top-Level</p></td>
<td><p>Reset</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_ColdResetSequence</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_TOP_LEVEL_002</p></td>
<td><p>Top-Level</p></td>
<td><p>Integration</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryRead_Complete</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_TOP_LEVEL_003</p></td>
<td><p>Top-Level</p></td>
<td><p>MSI Flow</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN</span></code></p></td>
</tr>
<tr class="row-even"><td><p>TC_TOP_LEVEL_004</p></td>
<td><p>Top-Level</p></td>
<td><p>Isolation</p></td>
<td><p>P0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_GlobalBlock</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>TC_TOP_LEVEL_005</p></td>
<td><p>Top-Level</p></td>
<td><p>Multi-Clock</p></td>
<td><p>P1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_CDC_AxiToPcieClock</span></code></p></td>
</tr>
</tbody>
</table>
<p><strong>Priority Legend:</strong></p>
<ul class="simple">
<li><p>P0: Critical, must pass for release</p></li>
<li><p>P1: Important, should pass for release</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="appendix-a-2-end-to-end-test-case-summary-section-16-implemented-in-keranous-pcie-tiletest-cc">
<h2>Appendix A.2: End-to-End Test Case Summary (Section 16) — Implemented in <code class="docutils literal notranslate"><span class="pre">Keranous_pcie_tileTest.cc</span></code><a class="headerlink" href="#appendix-a-2-end-to-end-test-case-summary-section-16-implemented-in-keranous-pcie-tiletest-cc" title="Permalink to this heading"></a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Test ID</p></th>
<th class="head"><p>Test Function</p></th>
<th class="head"><p>Feature Under Test</p></th>
<th class="head"><p>Priority</p></th>
<th class="head"><p>Status</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>(sanity)</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testAlwaysSucceeds()</span></code></p></td>
<td><p>Framework sanity check</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_INBOUND_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieRead_TlbApp0_NocN()</span></code></p></td>
<td><p>Inbound Read Data Path</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_INBOUND_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieWrite_TlbApp1_NocN()</span></code></p></td>
<td><p>Inbound Write (Large Pages)</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_INBOUND_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_Pcie_TlbSys_SmnN()</span></code></p></td>
<td><p>System Mgmt Inbound Path</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_INBOUND_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassApp()</span></code></p></td>
<td><p>App Bypass Routing (route=0x8)</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_INBOUND_005</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Inbound_PcieBypassSys()</span></code></p></td>
<td><p>Sys Bypass Routing (route=0x9)</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_OUTBOUND_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut0_Pcie()</span></code></p></td>
<td><p>Outbound Reverse TLB Read</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_OUTBOUND_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_SmnN_TlbSysOut0_Pcie()</span></code></p></td>
<td><p>System Outbound DBI Access</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_OUTBOUND_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Outbound_NocN_TlbAppOut1_PcieDBI()</span></code></p></td>
<td><p>App DBI Access (64KB Pages)</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_CONFIG_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToTlb()</span></code></p></td>
<td><p>TLB Config via SMN</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_CONFIG_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToSII()</span></code></p></td>
<td><p>SII Config via SMN</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_CONFIG_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Config_SmnToMsiRelay()</span></code></p></td>
<td><p>MSI Relay Config via SMN</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_MSI_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_Generation_ToNocN()</span></code></p></td>
<td><p>MSI Generation &amp; NOC Routing</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_MSI_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSI_DownstreamInput_Processing()</span></code></p></td>
<td><p>Downstream MSI Input</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_MSIX_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_MultipleVectors()</span></code></p></td>
<td><p>Multi-Vector MSI-X Config</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_STATUS_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_Read_Route0xE()</span></code></p></td>
<td><p>Status Register Routing</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_STATUS_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_StatusRegister_DisabledAccess()</span></code></p></td>
<td><p>Status Access Control</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_ISOLATION_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_GlobalBlock()</span></code></p></td>
<td><p>Global Isolation</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_ISOLATION_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Isolation_ConfigAccessAllowed()</span></code></p></td>
<td><p>Config During Isolation</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_ERROR_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_InvalidTlbEntry()</span></code></p></td>
<td><p>TLB Error Handling</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_ERROR_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_AddressDecodeError()</span></code></p></td>
<td><p>Address Decode DECERR</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_CONCURRENT_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_InboundOutbound()</span></code></p></td>
<td><p>Bidirectional Concurrency</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_CONCURRENT_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Concurrent_MultipleTlbs()</span></code></p></td>
<td><p>TLB Array Concurrency</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_RESET_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_ColdResetSequence()</span></code></p></td>
<td><p>Cold Reset &amp; Recovery</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_RESET_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Reset_WarmResetSequence()</span></code></p></td>
<td><p>Warm Reset (Config Preserved)</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_FLOW_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryRead_Complete()</span></code></p></td>
<td><p>Complete PCIe Read Cycle</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_FLOW_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_PcieMemoryWrite_Complete()</span></code></p></td>
<td><p>Complete PCIe Write Cycle</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_FLOW_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_NocMemoryRead_ToPcie()</span></code></p></td>
<td><p>NOC-to-PCIe Outbound Read</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_FLOW_004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Flow_SmnConfigWrite_PcieDBI()</span></code></p></td>
<td><p>SMN DBI Config Write</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_REFACTOR_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Refactor_FunctionCallbackChain()</span></code></p></td>
<td><p>Function Callback Chain</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_REFACTOR_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Refactor_NoInternalSockets_E126Check()</span></code></p></td>
<td><p>E126 Elimination</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_SYSTEM_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_BootSequence()</span></code></p></td>
<td><p>Boot &amp; Initialization</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_SYSTEM_003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_ErrorRecovery()</span></code></p></td>
<td><p>Error Recovery</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_MSIX_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_MSIX_CompleteMsixInterruptFlow()</span></code></p></td>
<td><p>Complete MSI-X Flow</p></td>
<td><p>P0</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_ERROR_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Error_TimeoutHandling()</span></code></p></td>
<td><p>Timeout Detection</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_CDC_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_CDC_AxiToPcieClock()</span></code></p></td>
<td><p>Clock Domain Crossing</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_PERF_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Perf_MaximumThroughput()</span></code></p></td>
<td><p>Max Throughput Burst</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_STRESS_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Stress_AddressSpaceSweep()</span></code></p></td>
<td><p>Address Space Sweep</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_STRESS_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Stress_TlbEntryExhaustion()</span></code></p></td>
<td><p>TLB 64-Entry Exhaustion</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-odd"><td><p>TC_E2E_POWER_001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_Power_IsolationModeEntryExit()</span></code></p></td>
<td><p>Isolation Entry/Exit</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
<tr class="row-even"><td><p>TC_E2E_SYSTEM_002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">testE2E_System_ShutdownSequence()</span></code></p></td>
<td><p>Graceful Shutdown</p></td>
<td><p>P1</p></td>
<td><p>✅ PASS</p></td>
</tr>
</tbody>
</table>
<p><strong>All E2E test cases are now implemented. No remaining gaps.</strong></p>
</section>
<hr class="docutils" />
<section id="appendix-b-test-execution-plan">
<h2>Appendix B: Test Execution Plan<a class="headerlink" href="#appendix-b-test-execution-plan" title="Permalink to this heading"></a></h2>
<section id="phase-1-unit-tests-weeks-1-3">
<h3>Phase 1: Unit Tests (Weeks 1-3)<a class="headerlink" href="#phase-1-unit-tests-weeks-1-3" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Inbound TLB basic tests</p></li>
<li><p>Outbound TLB basic tests</p></li>
<li><p>MSI Relay register tests</p></li>
<li><p>Switch routing tests</p></li>
<li><p>SII block tests</p></li>
<li><p>Config register tests</p></li>
<li><p>Clock/reset tests</p></li>
<li><p>PLL/CGM tests</p></li>
<li><p>PHY model tests</p></li>
</ul>
</section>
<section id="phase-2-functional-tests-weeks-4-5">
<h3>Phase 2: Functional Tests (Weeks 4-5)<a class="headerlink" href="#phase-2-functional-tests-weeks-4-5" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Address translation edge cases</p></li>
<li><p>Error handling tests</p></li>
<li><p>MSI generation tests</p></li>
<li><p>Switch routing edge cases</p></li>
<li><p>Timeout handling tests</p></li>
<li><p>Isolation tests</p></li>
<li><p>Reset sequence tests</p></li>
</ul>
</section>
<section id="phase-3-integration-tests-weeks-6-7">
<h3>Phase 3: Integration Tests (Weeks 6-7)<a class="headerlink" href="#phase-3-integration-tests-weeks-6-7" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>TLB + MSI Relay integration</p></li>
<li><p>Multiple TLB integration</p></li>
<li><p>Fabric integration</p></li>
<li><p>Switch integration</p></li>
<li><p>Clock domain integration</p></li>
<li><p>Top-level integration</p></li>
</ul>
</section>
<section id="phase-4-system-tests-week-8">
<h3>Phase 4: System Tests (Week 8)<a class="headerlink" href="#phase-4-system-tests-week-8" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>End-to-end transaction flows</p></li>
<li><p>Complete reset sequences</p></li>
<li><p>Isolation sequences</p></li>
<li><p>Performance tests</p></li>
<li><p>Stress tests</p></li>
</ul>
</section>
<section id="phase-5-regression-week-9">
<h3>Phase 5: Regression (Week 9)<a class="headerlink" href="#phase-5-regression-week-9" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Full regression suite</p></li>
<li><p>Coverage analysis</p></li>
<li><p>Performance benchmarking</p></li>
<li><p>VDK integration validation</p></li>
</ul>
<hr class="docutils" />
<p><strong>Document End</strong></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Keraunos_PCIE_Tile_SystemC_Design_Document.html" class="btn btn-neutral float-left" title="Keraunos PCIE Tile SystemC/TLM2.0 Design Document" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ENABLE_GATING_DESIGN.html" class="btn btn-neutral float-right" title="Enable Gating Feature - Design Documentation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, SystemC Modeling Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>