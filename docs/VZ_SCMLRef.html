<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VZ_SCMLRef &mdash; Keraunos PCIe Tile 2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="https://unpkg.com/mermaid@10.6.1/dist/mermaid.min.js"></script>
        <script>
mermaid.initialize({
    startOnLoad: true,
    theme: 'default',
    themeVariables: {
        primaryColor: '#e3f2fd',
        primaryTextColor: '#000',
        primaryBorderColor: '#1976d2',
        lineColor: '#1976d2',
        secondaryColor: '#fff4e1',
        tertiaryColor: '#e8f5e9'
    },
    flowchart: {
        useMaxWidth: true,
        htmlLabels: true,
        curve: 'basis',
        padding: 15
    },
    sequence: {
        useMaxWidth: true,
        diagramMarginX: 50,
        diagramMarginY: 10,
        actorMargin: 50,
        boxMargin: 10,
        boxTextMargin: 5,
        noteMargin: 10,
        messageMargin: 35
    },
    gantt: {
        useMaxWidth: true,
        barHeight: 20,
        barGap: 4,
        topPadding: 50,
        leftPadding: 75,
        gridLineStartPadding: 35
    },
    class: {
        useMaxWidth: true
    },
    state: {
        useMaxWidth: true
    }
});
</script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Keraunos PCIe Tile
          </a>
              <div class="version">
                2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html">Keraunos PCIe Tile - High-Level Design Document</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#table-of-contents">Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#introduction">1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#purpose">1.1 Purpose</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#scope">1.2 Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#definitions-and-acronyms">1.3 Definitions and Acronyms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#architecture-overview">2. Architecture Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#top-level-architecture">2.1 Top-Level Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#design-principles">2.2 Design Principles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#block-diagram">3. Block Diagram</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#tile-level-block-diagram">3.1 Tile-Level Block Diagram</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#data-flow-paths">3.2 Data Flow Paths</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#module-descriptions">4. Module Descriptions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#noc-pcie-switch">4.1 NOC-PCIE Switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#noc-io-switch">4.2 NOC-IO Switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#smn-io-switch">4.3 SMN-IO Switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#translation-lookaside-buffers-tlbs">4.4 Translation Lookaside Buffers (TLBs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#msi-relay-unit">4.5 MSI Relay Unit</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#system-information-interface-sii-block">4.6 System Information Interface (SII) Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#configuration-register-block">4.7 Configuration Register Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#clock-and-reset-control">4.8 Clock and Reset Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#pcie-phy-model">4.9 PCIe PHY Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#pll-cgm-clock-generation-module">4.10 PLL/CGM (Clock Generation Module)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#interface-specifications">5. Interface Specifications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#external-tlm-sockets">5.1 External TLM Sockets</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#control-input-signals">5.2 Control Input Signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#output-signals">5.3 Output Signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#internal-signals">5.4 Internal Signals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#address-map">6. Address Map</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#inbound-address-map-pcie-noc-smn">6.1 Inbound Address Map (PCIe → NOC/SMN)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#configuration-address-map-smn">6.2 Configuration Address Map (SMN)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#msi-relay-address-map-0x18800000">6.3 MSI Relay Address Map (0x18800000)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#data-flow">7. Data Flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#inbound-data-flow-pcie-noc">7.1 Inbound Data Flow (PCIe → NOC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#outbound-data-flow-noc-pcie">7.2 Outbound Data Flow (NOC → PCIe)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#configuration-access-flow-smn-config-registers">7.3 Configuration Access Flow (SMN → Config Registers)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#msi-generation-flow-noc-pcie-via-msi-relay">7.4 MSI Generation Flow (NOC → PCIe via MSI Relay)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#cii-interrupt-flow-pcie-config-write-config-update">7.5 CII Interrupt Flow (PCIe Config Write → config_update)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#clock-and-reset-strategy">8. Clock and Reset Strategy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#clock-domains">8.1 Clock Domains</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#reset-strategy">8.2 Reset Strategy</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#power-on-initialization">8.3 Power-On Initialization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#configuration-and-control">9. Configuration and Control</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#tile-initialization-sequence">9.1 Tile Initialization Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#runtime-control">9.2 Runtime Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#status-monitoring">9.3 Status Monitoring</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#references">10. References</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#related-documents">10.1 Related Documents</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#source-code-organization">10.2 Source Code Organization</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#key-design-decisions">10.3 Key Design Decisions</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#known-limitations-and-findings">10.4 Known Limitations and Findings</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#appendix-a-signal-timing-diagrams">Appendix A: Signal Timing Diagrams</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#a-1-cii-interrupt-timing">A.1 CII Interrupt Timing</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#a-2-isolation-sequence">A.2 Isolation Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#a-3-cold-reset-cycle">A.3 Cold Reset Cycle</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#appendix-b-address-decode-examples">Appendix B: Address Decode Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#b-1-inbound-tlb-translation-tlb-sys-in0">B.1 Inbound TLB Translation (TLB Sys In0)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#b-2-status-register-access">B.2 Status Register Access</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#b-3-smn-config-write-address-passthrough-issue">B.3 SMN Config Write (Address Passthrough Issue)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIe_Tile_HLD.html#appendix-c-test-coverage-summary">Appendix C: Test Coverage Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html">Keraunos PCIE Tile SystemC/TLM2.0 Design Document</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#sphinx-setup-instructions">Sphinx Setup Instructions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#install-required-extensions">1. Install Required Extensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configure-conf-py">2. Configure <code class="docutils literal notranslate"><span class="pre">conf.py</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#build-html-documentation">3. Build HTML Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#alternative-use-make">4. Alternative: Use make</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#key-implementation-features">⭐ Key Implementation Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#table-of-contents">Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#introduction">1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#purpose">1.1 Purpose</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scope">1.2 Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#references">1.3 References</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#implementation-version">1.4 Implementation Version</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#refactored-architecture-overview-new">1.5 Refactored Architecture Overview ⭐ NEW</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#why-refactoring-was-necessary">1.5.1 Why Refactoring Was Necessary</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#refactored-architecture-pattern">1.5.2 Refactored Architecture Pattern</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#original-design-socket-based">Original Design (Socket-Based):</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#refactored-design-function-based">Refactored Design (Function-Based):</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#function-callback-communication-pattern">1.5.3 Function Callback Communication Pattern</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#callback-type-definition">Callback Type Definition:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#setting-up-callbacks-wire-components">Setting Up Callbacks (Wire Components):</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#benefits-of-function-callbacks">Benefits of Function Callbacks:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#smart-pointer-memory-management">1.5.4 Smart Pointer Memory Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scml2-memory-integration">1.5.5 SCML2 Memory Integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#temporal-decoupling-support">1.5.6 Temporal Decoupling Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#modern-c-best-practices-applied">1.5.7 Modern C++ Best Practices Applied</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#file-organization">1.5.8 File Organization</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#component-communication-pattern">1.5.9 Component Communication Pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#null-safety-pattern">1.5.10 Null Safety Pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#performance-characteristics">1.5.11 Performance Characteristics</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#code-example-complete-transaction-path">1.5.12 Code Example - Complete Transaction Path</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#system-overview">2. System Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#keraunos-pcie-tile-context">2.1 Keraunos PCIE Tile Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#modeled-components">2.2 Modeled Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#design-objectives">2.3 Design Objectives</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#architecture">3. Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#overall-structure">3.1 Overall Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#component-hierarchy">3.2 Component Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#data-flow">3.3 Data Flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-traffic-flow">Inbound Traffic Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#outbound-traffic-flow">Outbound Traffic Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-flow">MSI Flow</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#component-design">4. Component Design</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlb-common-structures">4.1 TLB Common Structures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbentry-structure">4.1.1 TlbEntry Structure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-tlb-design">4.2 Inbound TLB Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#overview-and-use-cases">4.2.1 Overview and Use Cases</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbsysin0-system-management-inbound-tlb">4.2.2 TLBSysIn0 - System Management Inbound TLB</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbappin0-application-inbound-tlb-bar0-1">4.2.3 TLBAppIn0 - Application Inbound TLB (BAR0/1)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbappin1-application-inbound-tlb-bar4-5">4.2.4 TLBAppIn1 - Application Inbound TLB (BAR4/5)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-tlb-translation-flow">4.2.5 Inbound TLB Translation Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#address-translation-examples">4.2.6 Address Translation Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#axuser-field-format">4.2.7 AxUSER Field Format</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-and-initialization">4.2.8 Configuration and Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#error-handling">4.2.9 Error Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#integration-with-system">4.2.10 Integration with System</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#outbound-tlb-design">4.3 Outbound TLB Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id1">4.3.1 Overview and Use Cases</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbsysout0-system-management-outbound-tlb">4.3.2 TLBSysOut0 - System Management Outbound TLB</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbappout0-application-outbound-tlb-high-address">4.3.3 TLBAppOut0 - Application Outbound TLB (High Address)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlbappout1-application-outbound-tlb-dbi-access">4.3.4 TLBAppOut1 - Application Outbound TLB (DBI Access)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#outbound-tlb-translation-flow">4.3.5 Outbound TLB Translation Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id2">4.3.6 Address Translation Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id3">4.3.7 Configuration and Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id4">4.3.8 Error Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id5">4.3.9 Integration with System</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-relay-unit-design">4.4 MSI Relay Unit Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#overview">4.4.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id6">4.4.2 Architecture</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-x-table-entry">4.4.3 MSI-X Table Entry</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pending-bit-array-pba">4.4.4 Pending Bit Array (PBA)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-thrower-logic">4.4.5 MSI Thrower Logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#register-map">4.4.6 Register Map</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#intra-tile-fabric-switch-design">4.5 Intra-Tile Fabric Switch Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#noc-pcie-switch">4.5.1 NOC-PCIE Switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#noc-io-switch">4.5.2 NOC-IO Switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#smn-io-switch">4.5.3 SMN-IO Switch</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#system-information-interface-sii-block">4.6 System Information Interface (SII) Block</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id7">4.6.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#architecture-and-operation">4.6.2 Architecture and Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#cii-tracking-implementation">4.6.3 CII Tracking Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id8">4.6.4 Register Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#clock-domain-crossing">4.6.5 Clock Domain Crossing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#interrupt-generation-and-routing">4.6.6 Interrupt Generation and Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#interface-specification">4.6.7 Interface Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#implementation-details">4.6.8 Implementation Details</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-register-block">4.7 Configuration Register Block</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id9">4.7.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#status-registers">4.7.2 Status Registers</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#isolation-behavior">4.7.3 Isolation Behavior</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#clock-reset-control-module">4.8 Clock &amp; Reset Control Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id10">4.8.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#clock-domains">4.8.2 Clock Domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#reset-sequence">4.8.3 Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#interface">4.8.4 Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pll-cgm-clock-generation-module">4.9 PLL/CGM (Clock Generation Module)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id11">4.9.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pll-lock">4.9.2 PLL Lock</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id12">4.9.3 Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pcie-phy-model">4.10 PCIE PHY Model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id13">4.10.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#features">4.10.2 Features</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id14">4.10.3 Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#external-interface-modules">4.11 External Interface Modules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#noc-n-interface">4.11.1 NOC-N Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#smn-n-interface">4.11.2 SMN-N Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#top-level-keraunos-pcie-tile-module">4.12 Top-Level Keraunos PCIE Tile Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id15">4.12.1 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#external-interfaces">4.12.2 External Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#internal-connections">4.12.3 Internal Connections</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#interface-specifications">5. Interface Specifications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlm2-0-interfaces">5.1 TLM2.0 Interfaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#axi4-target-socket-inbound-tlbs">5.1.1 AXI4 Target Socket (Inbound TLBs)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#axi4-initiator-socket-all-tlbs">5.1.2 AXI4 Initiator Socket (All TLBs)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#apb-target-socket-configuration">5.1.3 APB Target Socket (Configuration)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#axi4-lite-initiator-socket-msi-relay">5.1.4 AXI4-Lite Initiator Socket (MSI Relay)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#systemc-signals">5.2 SystemC Signals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#control-signals">5.2.1 Control Signals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#address-translation-interfaces">5.3 Address Translation Interfaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlb-lookup-methods">5.3.1 TLB Lookup Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-methods">5.3.2 Configuration Methods</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id16">6. Implementation Details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#address-translation-algorithms">6.1 Address Translation Algorithms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-translation-tlbsysin0">6.1.1 Inbound Translation (TLBSysIn0)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#outbound-translation-tlbappout0">6.1.2 Outbound Translation (TLBAppOut0)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#id17">6.2 Error Handling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#invalid-tlb-entry">6.2.1 Invalid TLB Entry</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#out-of-range-index">6.2.2 Out-of-Range Index</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#msi-relay-unit-state-machine">6.3 MSI Relay Unit State Machine</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#threading-model">6.4 Threading Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#memory-modeling">6.5 Memory Modeling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#modeling-approach">7. Modeling Approach</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#abstraction-level">7.1 Abstraction Level</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scml2-usage">7.2 SCML2 Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#socket-type-selection-rationale">7.2.1 Socket Type Selection Rationale</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlm2-0-compliance">7.3 TLM2.0 Compliance</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#design-patterns">7.4 Design Patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#performance-considerations">8. Performance Considerations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#simulation-performance">8.1 Simulation Performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#optimization-opportunities">8.2 Optimization Opportunities</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scalability">8.3 Scalability</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#dependencies-and-requirements">9. Dependencies and Requirements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#software-dependencies">9.1 Software Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#hardware-dependencies">9.2 Hardware Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#integration-requirements">9.3 Integration Requirements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#detailed-implementation-architecture">9. Detailed Implementation Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#class-hierarchy-and-relationships">9.1 Class Hierarchy and Relationships</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#top-level-module-only-sc-module">Top-Level Module (Only sc_module):</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#internal-component-pattern">Internal Component Pattern:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#communication-architecture">9.2 Communication Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#transaction-flow-pattern">Transaction Flow Pattern:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#memory-management-architecture">9.3 Memory Management Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#smart-pointer-ownership-tree">Smart Pointer Ownership Tree:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#callback-wiring-implementation">9.4 Callback Wiring Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#complete-wiring-example">Complete Wiring Example:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#scml2-memory-usage-pattern">9.5 SCML2 Memory Usage Pattern</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-storage-implementation">Configuration Storage Implementation:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#component-lifecycle">9.6 Component Lifecycle</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#initialization-sequence">Initialization Sequence:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#transaction-processing-flow">9.7 Transaction Processing Flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#inbound-pcie-transaction-example">Inbound PCIe Transaction Example:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#routing-decision-implementation">9.8 Routing Decision Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#noc-pcie-switch-routing-logic">NOC-PCIE Switch Routing Logic:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlb-translation-implementation">9.9 TLB Translation Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#translation-algorithm">Translation Algorithm:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#error-handling-strategy">9.10 Error Handling Strategy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#layered-error-response">Layered Error Response:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-register-implementation">9.11 Configuration Register Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#register-access-pattern">Register Access Pattern:</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#implementation-guide">10. Implementation Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#building-the-design">10.1 Building the Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#prerequisites">Prerequisites:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#build-commands">Build Commands:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#build-output">Build Output:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#running-tests">10.2 Running Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#unit-tests-auto-generated">Unit Tests (Auto-Generated):</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-coverage">Test Coverage:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#adding-new-components">10.3 Adding New Components</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#pattern-for-c-class-components">Pattern for C++ Class Components:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#debugging-and-troubleshooting">10.4 Debugging and Troubleshooting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#common-issues-and-solutions">Common Issues and Solutions:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#debug-tools">Debug Tools:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#performance-tuning">10.5 Performance Tuning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#temporal-decoupling-configuration">Temporal Decoupling Configuration:</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#adding-timing-annotations">Adding Timing Annotations:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-development-guide">10.6 Test Development Guide</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#adding-new-test-cases">Adding New Test Cases:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#configuration-management">10.7 Configuration Management</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#tlb-configuration-example">TLB Configuration Example:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#integration-with-vdk-platform">10.8 Integration with VDK Platform</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#module-instantiation-in-platform">Module Instantiation in Platform:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#memory-management-best-practices">10.9 Memory Management Best Practices</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#raii-pattern-already-applied">RAII Pattern (Already Applied):</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#coding-standards-applied">10.10 Coding Standards Applied</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#modern-c-17-features-used">Modern C++17 Features Used:</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-infrastructure">11. Test Infrastructure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-framework-overview">11.1 Test Framework Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-categories-33-tests">11.2 Test Categories (33 Tests)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-execution-results">11.3 Test Execution Results</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#test-api-examples">11.4 Test API Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#coverage-goals">11.5 Coverage Goals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#migration-from-original-design">12. Migration from Original Design</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#for-developers-familiar-with-original">12.1 For Developers Familiar with Original</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#api-migration-guide">12.2 API Migration Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#backward-compatibility-notes">12.3 Backward Compatibility Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#known-limitations-and-future-work">13. Known Limitations and Future Work</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#current-limitations">13.1 Current Limitations</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#future-enhancements">13.2 Future Enhancements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#lessons-learned-and-best-practices">14. Lessons Learned and Best Practices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#architecture-decisions">14.1 Architecture Decisions</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#design-patterns-applied">14.2 Design Patterns Applied</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#recommendations-for-similar-projects">14.3 Recommendations for Similar Projects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#appendix-a-implemented-components-summary">Appendix A: Implemented Components Summary</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#a-1-complete-component-list">A.1 Complete Component List</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#a-2-component-statistics">A.2 Component Statistics</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#a-3-scml-compliance">A.3 SCML Compliance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#appendix-b-address-map-summary">Appendix B: Address Map Summary</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-1-tlb-configuration-space">B.1 TLB Configuration Space</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-2-msi-relay-unit-address-map">B.2 MSI Relay Unit Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-3-sii-block-address-map">B.3 SII Block Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-4-config-register-block-address-map">B.4 Config Register Block Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-5-smn-io-switch-address-map">B.5 SMN-IO Switch Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-6-noc-io-switch-address-map">B.6 NOC-IO Switch Address Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#b-7-noc-pcie-switch-routing-map">B.7 NOC-PCIE Switch Routing Map</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_SystemC_Design_Document.html#appendix-c-acronyms-and-abbreviations">Appendix C: Acronyms and Abbreviations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html">Keraunos PCIE Tile SystemC/TLM2.0 Testplan</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#table-of-contents">Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#introduction">1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#purpose">1.1 Purpose</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#scope">1.2 Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-objectives">1.3 Test Objectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#references">1.4 References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-traceability-matrix">1.5 Test Traceability Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-environment">2. Test Environment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#testbench-structure">2.1 Testbench Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-components">2.2 Test Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-tools">2.3 Test Tools</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-strategy">3. Test Strategy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-levels">3.1 Test Levels</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-methodology">3.2 Test Methodology</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-phases">3.3 Test Phases</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#inbound-tlb-test-cases">4. Inbound TLB Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlbsysin0-test-cases">4.1 TLBSysIn0 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-sys-001-basic-address-translation">TC_INBOUND_SYS_001: Basic Address Translation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-sys-002-invalid-entry-detection">TC_INBOUND_SYS_002: Invalid Entry Detection</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-sys-003-index-calculation">TC_INBOUND_SYS_003: Index Calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-sys-004-page-boundary-crossing">TC_INBOUND_SYS_004: Page Boundary Crossing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-sys-005-axuser-field-mapping">TC_INBOUND_SYS_005: AxUSER Field Mapping</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-sys-006-system-ready-bypass">TC_INBOUND_SYS_006: System Ready Bypass</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlbappin0-test-cases">4.2 TLBAppIn0 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-app0-001-bar0-1-translation">TC_INBOUND_APP0_001: BAR0/1 Translation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-app0-002-multiple-instance-support">TC_INBOUND_APP0_002: Multiple Instance Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-app0-003-16mb-page-size">TC_INBOUND_APP0_003: 16MB Page Size</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-app0-004-non-cacheable-and-qosid">TC_INBOUND_APP0_004: Non-Cacheable and QoSID</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlbappin1-test-cases">4.3 TLBAppIn1 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-app1-001-bar4-5-translation">TC_INBOUND_APP1_001: BAR4/5 Translation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-app1-002-8gb-page-size">TC_INBOUND_APP1_002: 8GB Page Size</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-inbound-app1-003-dram-mapping">TC_INBOUND_APP1_003: DRAM Mapping</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#outbound-tlb-test-cases">5. Outbound TLB Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlbsysout0-test-cases">5.1 TLBSysOut0 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-sys-001-dbi-access-translation">TC_OUTBOUND_SYS_001: DBI Access Translation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-sys-002-64kb-page-size">TC_OUTBOUND_SYS_002: 64KB Page Size</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-sys-003-all-16-entries">TC_OUTBOUND_SYS_003: All 16 Entries</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlbappout0-test-cases">5.2 TLBAppOut0 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-app0-001-high-address-translation-256tb">TC_OUTBOUND_APP0_001: High Address Translation (&gt;=256TB)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-app0-002-address-range-check">TC_OUTBOUND_APP0_002: Address Range Check</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-app0-003-16tb-page-size">TC_OUTBOUND_APP0_003: 16TB Page Size</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlbappout1-test-cases">5.3 TLBAppOut1 Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-app1-001-low-address-translation-256tb">TC_OUTBOUND_APP1_001: Low Address Translation (&lt;256TB)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-outbound-app1-002-dbi-access-from-application">TC_OUTBOUND_APP1_002: DBI Access from Application</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#msi-relay-unit-test-cases">6. MSI Relay Unit Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#register-access-tests">6.1 Register Access Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-001-msi-receiver-write">TC_MSI_RELAY_001: MSI Receiver Write</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-002-msi-x-table-configuration">TC_MSI_RELAY_002: MSI-X Table Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-003-outstanding-count">TC_MSI_RELAY_003: Outstanding Count</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#msi-generation-tests">6.2 MSI Generation Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-004-basic-msi-generation">TC_MSI_RELAY_004: Basic MSI Generation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-005-msi-x-enable-control">TC_MSI_RELAY_005: MSI-X Enable Control</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-006-global-mask-control">TC_MSI_RELAY_006: Global Mask Control</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-007-vector-mask-control">TC_MSI_RELAY_007: Vector Mask Control</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-008-invalid-entry-handling">TC_MSI_RELAY_008: Invalid Entry Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-009-multiple-pending-interrupts">TC_MSI_RELAY_009: Multiple Pending Interrupts</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-010-setip-signal">TC_MSI_RELAY_010: SetIP Signal</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-msi-relay-011-all-16-vectors">TC_MSI_RELAY_011: All 16 Vectors</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#integration-test-cases">7. Integration Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlb-msi-relay-integration">7.1 TLB + MSI Relay Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-integration-001-msi-x-table-access-via-tlb">TC_INTEGRATION_001: MSI-X Table Access via TLB</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-integration-002-msi-generation-through-fabric">TC_INTEGRATION_002: MSI Generation Through Fabric</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#multiple-tlb-integration">7.2 Multiple TLB Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-integration-003-concurrent-tlb-operations">TC_INTEGRATION_003: Concurrent TLB Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-integration-004-outbound-inbound-round-trip">TC_INTEGRATION_004: Outbound + Inbound Round Trip</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#switch-test-cases">8. Switch Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#noc-pcie-switch-test-cases">8.1 NOC-PCIE Switch Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-pcie-001-address-routing-based-on-axaddr-63-60">TC_SWITCH_NOC_PCIE_001: Address Routing Based on AxADDR[63:60]</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-pcie-002-status-register-special-routing">TC_SWITCH_NOC_PCIE_002: Status Register Special Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-pcie-003-isolation-support">TC_SWITCH_NOC_PCIE_003: Isolation Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-pcie-004-inbound-enable-control">TC_SWITCH_NOC_PCIE_004: Inbound Enable Control</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#enable-gating-test-cases-new-feb-2026">8.4 Enable Gating Test Cases (NEW - Feb 2026)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-negative-enable-001-inbound-enable-blocks-pcienoc-traffic">TC_NEGATIVE_ENABLE_001: Inbound Enable Blocks PCIe→NOC Traffic</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-negative-enable-002-outbound-enable-blocks-nocpcie-traffic">TC_NEGATIVE_ENABLE_002: Outbound Enable Blocks NOC→PCIe Traffic</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-negative-enable-003-both-enables-disabled-complete-isolation">TC_NEGATIVE_ENABLE_003: Both Enables Disabled - Complete Isolation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-negative-enable-004-both-enables-active-positive-control">TC_NEGATIVE_ENABLE_004: Both Enables Active - Positive Control</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#enable-gating-implementation-architecture">8.5 Enable Gating Implementation Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-pcie-005-bypass-path-routing">TC_SWITCH_NOC_PCIE_005: Bypass Path Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-pcie-006-address-conversion-64-bit-to-52-bit">TC_SWITCH_NOC_PCIE_006: Address Conversion (64-bit to 52-bit)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#noc-io-switch-test-cases">8.2 NOC-IO Switch Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-io-001-local-resource-routing">TC_SWITCH_NOC_IO_001: Local Resource Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-io-002-external-noc-routing">TC_SWITCH_NOC_IO_002: External NOC Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-io-003-high-address-routing-axaddr-51-48">TC_SWITCH_NOC_IO_003: High Address Routing (AxADDR[51:48])</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-noc-io-004-timeout-detection">TC_SWITCH_NOC_IO_004: Timeout Detection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#smn-io-switch-test-cases">8.3 SMN-IO Switch Test Cases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-smn-io-001-address-based-routing">TC_SWITCH_SMN_IO_001: Address-Based Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-smn-io-002-serdes-routing">TC_SWITCH_SMN_IO_002: SerDes Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-smn-io-003-external-smn-routing">TC_SWITCH_SMN_IO_003: External SMN Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-switch-smn-io-004-timeout-detection">TC_SWITCH_SMN_IO_004: Timeout Detection</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#sii-block-test-cases">9. SII Block Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#id1">9.1 Register Access Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-sii-001-configuration-register-access">TC_SII_001: Configuration Register Access</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-sii-002-cii-tracking">TC_SII_002: CII Tracking</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-sii-003-bus-device-number-assignment">TC_SII_003: Bus/Device Number Assignment</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#config-register-block-test-cases">10. Config Register Block Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#id2">10.1 Register Access Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-config-reg-001-tlb-configuration-space-access">TC_CONFIG_REG_001: TLB Configuration Space Access</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-config-reg-002-system-ready-register">TC_CONFIG_REG_002: System Ready Register</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-config-reg-003-pcie-enable-registers">TC_CONFIG_REG_003: PCIE Enable Registers</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-config-reg-004-isolation-behavior">TC_CONFIG_REG_004: Isolation Behavior</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#clock-reset-test-cases">11. Clock &amp; Reset Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#clock-generation-tests">11.1 Clock Generation Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-clock-reset-001-reference-clock-generation">TC_CLOCK_RESET_001: Reference Clock Generation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-clock-reset-002-pcie-clock-generation">TC_CLOCK_RESET_002: PCIE Clock Generation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#reset-sequence-tests">11.2 Reset Sequence Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-clock-reset-003-cold-reset-sequence">TC_CLOCK_RESET_003: Cold Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-clock-reset-004-warm-reset-sequence">TC_CLOCK_RESET_004: Warm Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-clock-reset-005-isolation-behavior">TC_CLOCK_RESET_005: Isolation Behavior</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#pll-cgm-test-cases">12. PLL/CGM Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#pll-lock-tests">12.1 PLL Lock Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-pll-cgm-001-pll-lock-sequence">TC_PLL_CGM_001: PLL Lock Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-pll-cgm-002-pll-configuration">TC_PLL_CGM_002: PLL Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#pcie-phy-test-cases">13. PCIE PHY Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#phy-configuration-tests">13.1 PHY Configuration Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-phy-001-apb-configuration-access">TC_PHY_001: APB Configuration Access</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-phy-002-ahb-firmware-download">TC_PHY_002: AHB Firmware Download</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-phy-003-lane-reversal-support">TC_PHY_003: Lane Reversal Support</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#external-interface-test-cases">14. External Interface Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#noc-n-interface-tests">14.1 NOC-N Interface Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-external-noc-001-transaction-forwarding">TC_EXTERNAL_NOC_001: Transaction Forwarding</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#smn-n-interface-tests">14.2 SMN-N Interface Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-external-smn-001-transaction-forwarding">TC_EXTERNAL_SMN_001: Transaction Forwarding</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#top-level-integration-test-cases">15. Top-Level Integration Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#full-tile-integration">15.1 Full Tile Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-top-level-001-complete-reset-sequence">TC_TOP_LEVEL_001: Complete Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-top-level-002-end-to-end-transaction-flow">TC_TOP_LEVEL_002: End-to-End Transaction Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-top-level-003-msi-end-to-end-flow">TC_TOP_LEVEL_003: MSI End-to-End Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-top-level-004-isolation-sequence">TC_TOP_LEVEL_004: Isolation Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-top-level-005-multiple-clock-domain-operation">TC_TOP_LEVEL_005: Multiple Clock Domain Operation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#end-to-end-test-cases">16. End-to-End Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#inbound-data-paths-pcie-noc-smn">16.1 Inbound Data Paths (PCIe → NOC/SMN)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-inbound-001-pcie-read-tlb-app0-noc-n">TC_E2E_INBOUND_001: PCIe Read → TLB App0 → NOC-N</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-inbound-002-pcie-write-tlb-app1-noc-n">TC_E2E_INBOUND_002: PCIe Write → TLB App1 → NOC-N</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-inbound-003-pcie-tlb-sys-smn-n">TC_E2E_INBOUND_003: PCIe → TLB Sys → SMN-N</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-inbound-004-pcie-bypass-app-path">TC_E2E_INBOUND_004: PCIe Bypass App Path</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-inbound-005-pcie-bypass-sys-path">TC_E2E_INBOUND_005: PCIe Bypass Sys Path</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#outbound-data-paths-noc-smn-pcie">16.2 Outbound Data Paths (NOC/SMN → PCIe)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-outbound-001-noc-n-tlb-app-out0-pcie">TC_E2E_OUTBOUND_001: NOC-N → TLB App Out0 → PCIe</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-outbound-002-smn-n-tlb-sys-out0-pcie">TC_E2E_OUTBOUND_002: SMN-N → TLB Sys Out0 → PCIe</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-outbound-003-noc-n-tlb-app-out1-pcie-dbi">TC_E2E_OUTBOUND_003: NOC-N → TLB App Out1 → PCIe DBI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#configuration-paths-smn-tlb-sii-msi-config">16.3 Configuration Paths (SMN → TLB/SII/MSI Config)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-config-001-smn-n-tlb-config">TC_E2E_CONFIG_001: SMN-N → TLB Config</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-config-002-smn-n-sii-config">TC_E2E_CONFIG_002: SMN-N → SII Config</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-config-003-smn-n-msi-relay-config">TC_E2E_CONFIG_003: SMN-N → MSI Relay Config</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#msi-interrupt-flows">16.4 MSI Interrupt Flows</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-msi-001-msi-generation-noc-n">TC_E2E_MSI_001: MSI Generation → NOC-N</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-msi-002-downstream-msi-input-processing">TC_E2E_MSI_002: Downstream MSI Input → Processing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#status-register-access">16.5 Status Register Access</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-status-001-status-register-read-route-0xe">TC_E2E_STATUS_001: Status Register Read (Route 0xE)</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-status-002-status-register-disabled-access">TC_E2E_STATUS_002: Status Register Disabled Access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#isolation-and-error-handling">16.6 Isolation and Error Handling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-isolation-001-global-isolation">TC_E2E_ISOLATION_001: Global Isolation</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-isolation-002-config-access-during-isolation">TC_E2E_ISOLATION_002: Config Access During Isolation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#multi-path-concurrent-traffic">16.7 Multi-Path Concurrent Traffic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-concurrent-001-simultaneous-inbound-outbound">TC_E2E_CONCURRENT_001: Simultaneous Inbound + Outbound</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-concurrent-002-multiple-tlb-simultaneous-access">TC_E2E_CONCURRENT_002: Multiple TLB Simultaneous Access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#reset-and-initialization-sequences">16.8 Reset and Initialization Sequences</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-reset-001-cold-reset-sequence">TC_E2E_RESET_001: Cold Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-reset-002-warm-reset-sequence">TC_E2E_RESET_002: Warm Reset Sequence</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#complete-transaction-flows">16.9 Complete Transaction Flows</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-flow-001-pcie-memory-read-noc-memory-response">TC_E2E_FLOW_001: PCIe Memory Read → NOC → Memory → Response</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-flow-002-pcie-memory-write-noc-memory-completion">TC_E2E_FLOW_002: PCIe Memory Write → NOC → Memory → Completion</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-flow-003-noc-memory-read-pcie-controller">TC_E2E_FLOW_003: NOC Memory Read → PCIe Controller</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-flow-004-smn-config-write-pcie-dbi">TC_E2E_FLOW_004: SMN Config Write → PCIe DBI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#error-injection-and-recovery">16.10 Error Injection and Recovery</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-error-001-invalid-tlb-entry">TC_E2E_ERROR_001: Invalid TLB Entry</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-error-002-timeout-handling">TC_E2E_ERROR_002: Timeout Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-error-003-address-decode-error">TC_E2E_ERROR_003: Address Decode Error</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#msi-x-end-to-end-flow">16.11 MSI-X End-to-End Flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-msix-001-complete-msi-x-interrupt-flow">TC_E2E_MSIX_001: Complete MSI-X Interrupt Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-msix-002-multiple-vector-interrupts">TC_E2E_MSIX_002: Multiple Vector Interrupts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#clock-domain-crossing">16.12 Clock Domain Crossing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-cdc-001-axi-clock-pcie-clock">TC_E2E_CDC_001: AXI Clock → PCIe Clock</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#performance-and-stress-tests">16.13 Performance and Stress Tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-perf-001-maximum-throughput-test">TC_E2E_PERF_001: Maximum Throughput Test</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-stress-001-address-space-sweep">TC_E2E_STRESS_001: Address Space Sweep</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-stress-002-tlb-entry-exhaustion">TC_E2E_STRESS_002: TLB Entry Exhaustion</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#power-management">16.14 Power Management</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-power-001-isolation-mode-entry-exit">TC_E2E_POWER_001: Isolation Mode Entry/Exit</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#system-integration-scenarios">16.15 System Integration Scenarios</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-system-001-boot-sequence">TC_E2E_SYSTEM_001: Boot Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-system-002-shutdown-sequence">TC_E2E_SYSTEM_002: Shutdown Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-system-003-error-recovery-scenario">TC_E2E_SYSTEM_003: Error Recovery Scenario</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#refactored-architecture-validation">16.16 Refactored Architecture Validation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-refactor-001-function-callback-chain">TC_E2E_REFACTOR_001: Function Callback Chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tc-e2e-refactor-002-no-internal-sockets-remain">TC_E2E_REFACTOR_002: No Internal Sockets Remain</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#coverage-goals">17. Coverage Goals</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#id3">16. Coverage Goals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#functional-coverage">16.1 Functional Coverage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#tlb-coverage">TLB Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#msi-relay-coverage">MSI Relay Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#switch-coverage">Switch Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#sii-coverage">SII Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#config-register-coverage">Config Register Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#clock-reset-coverage">Clock/Reset Coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#phy-coverage">PHY Coverage</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#code-coverage">16.2 Code Coverage</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#specification-coverage">16.3 Specification Coverage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-infrastructure">17. Test Infrastructure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#testbench-components">9.1 Testbench Components</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#stimulus-generator">Stimulus Generator</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#monitor">Monitor</a></li>
<li class="toctree-l4"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#reference-model">Reference Model</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-utilities">9.2 Test Utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#test-configuration">9.3 Test Configuration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#regression-testing">18. Regression Testing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#regression-suite">10.1 Regression Suite</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#regression-criteria">10.2 Regression Criteria</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#continuous-integration">10.3 Continuous Integration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#appendix-a-unit-integration-test-case-summary-sections-4-15">Appendix A: Unit/Integration Test Case Summary (Sections 4-15)</a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#appendix-a-2-end-to-end-test-case-summary-section-16-implemented-in-keranous-pcie-tiletest-cc">Appendix A.2: End-to-End Test Case Summary (Section 16) — Implemented in <code class="docutils literal notranslate"><span class="pre">Keranous_pcie_tileTest.cc</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#appendix-b-test-execution-plan">Appendix B: Test Execution Plan</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#phase-1-unit-tests-weeks-1-3">Phase 1: Unit Tests (Weeks 1-3)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#phase-2-functional-tests-weeks-4-5">Phase 2: Functional Tests (Weeks 4-5)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#phase-3-integration-tests-weeks-6-7">Phase 3: Integration Tests (Weeks 6-7)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#phase-4-system-tests-week-8">Phase 4: System Tests (Week 8)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Keraunos_PCIE_Tile_Testplan.html#phase-5-regression-week-9">Phase 5: Regression (Week 9)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ENABLE_GATING_DESIGN.html">Enable Gating Feature - Design Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#register-interface">Register Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#implementation">Implementation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#signal-propagation">Signal Propagation</a></li>
<li class="toctree-l3"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#key-features">Key Features</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ENABLE_GATING_DESIGN.html#test-coverage">Test Coverage</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Keraunos PCIe Tile</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">VZ_SCMLRef</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/VZ_SCMLRef.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="vz-scmlref">
<h1>VZ_SCMLRef<a class="headerlink" href="#vz-scmlref" title="Permalink to this heading"></a></h1>
<section id="page-1">
<h2>Page 1<a class="headerlink" href="#page-1" title="Permalink to this heading"></a></h2>
<p>SystemC Modeling Library Reference Manual
Version X-2025.06-SP1, October 2025</p>
</section>
<section id="page-2">
<h2>Page 2<a class="headerlink" href="#page-2" title="Permalink to this heading"></a></h2>
<p>Copyright and Proprietary Information
©2025 Synopsys, Inc. ALL RIGHTS RESERVED
This Synopsys software and all associated documentation are proprietary to Synopsys, Inc. and may
only be used pursuant to the terms and conditions of a written license agreement with Synopsys, Inc.
All other use, reproduction, modification, or distribution of the Synopsys software or the associated
documentation is strictly prohibited.
Licensed Products communicate with Synopsys servers for the purpose of providing software updates,
detecting software piracy and verifying that customers are using Licensed Products in conformity with
the applicable License Key for such Licensed Products. Synopsys will use information gathered in
connection with this process to deliver software updates and pursue software pirates and infringers.
Destination Control Statement
All technical data contained in this publication is subject to the export control laws of the United States
of America. Disclosure to nationals of other countries contrary to United States law is prohibited. It is the
reader’s responsibility to determine the applicable regulations and to comply with them.
Disclaimer
SYNOPSYS, INC., AND ITS LICENSORS MAKE NO WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, WITH REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
Trademarks
Synopsys and certain Synopsys product names are trademarks of Synopsys, as set forth at https://
www.synopsys.com/company/legal/trademarks-brands.html.
All other product or company names may be trademarks of their respective owners.
Free and Open-Source Licensing Notices
If applicable, Free and Open-Source Software (FOSS) licensing notices are available in the product
installation.
Third-Party Links
Any links to third-party websites included in this document are for your convenience only. Synopsys
does not endorse and is not responsible for such websites and their practices, including privacy
practices, availability, and content.
www.synopsys.com
SystemC Modeling Library Reference Manual
X-2025.06-SP1
2</p>
</section>
<section id="page-3">
<h2>Page 3<a class="headerlink" href="#page-3" title="Permalink to this heading"></a></h2>
<p>Contents
About This Manual … … … … … … … … … … … … … … … … … … … … … 9
Documentation Conventions … … … … … … … … … … … … … … … … … … . .9
Terminology … … … … … … … … … … … … … … … … … … … … … … . .11
References … … … … … … … … … … … … … … … … … … … … … … . . 12
Customer Support … … … … … … … … … … … … … … … … … … … … …12
Statement on Inclusivity and Diversity … … … … … … … … … … … … … … … . . 13</p>
<ol class="arabic simple">
<li><p>Introduction … … … … … … … … … … … … … … … … … … … … … … … … … . 14
1.1. SCML2 Introduction … … … … … … … … … … … … … … … … … … … .14
1.2. Header Files … … … … … … … … … … … … … … … … … … … … … 14
1.3. SCML2 FT Modeling Interfaces … … … … … … … … … … … … … … … … 14
1.3.1. Introduction to TLM2.0 … … … … … … … … … … … … … … … … …15
1.3.2. Extending TLM2.0 Base Protocol … … … … … … … … … … … … … … 17
1.4. SCML2 Modeling Objects … … … … … … … … … … … … … … … … … . . 18
1.4.1. Storage Modeling Objects … … … … … … … … … … … … … … … … 18
1.4.2. Timing and Synchronization … … … … … … … … … … … … … … … . .21
1.4.3. Utility Objects … … … … … … … … … … … … … … … … … … … .22</p></li>
<li><p>Memory Objects … … … … … … … … … … … … … … … … … … … … … … … … 24
2.1. Introduction … … … … … … … … … … … … … … … … … … … … … . 24
2.2. Overview … … … … … … … … … … … … … … … … … … … … … … 24
2.2.1. Transaction Routing From Socket to Memories … … … … … … … … … … . 25
2.2.2. Memory Map Modeling … … … … … … … … … … … … … … … … . . 25
2.2.3. Properties and Attributes … … … … … … … … … … … … … … … … . 25
2.2.4. Behavior … … … … … … … … … … … … … … … … … … … … . . 26
2.2.5. Callbacks … … … … … … … … … … … … … … … … … … … … . 27
2.2.6. Access Restrictions … … … … … … … … … … … … … … … … … . . 29
2.2.7. Vectors of Memory Objects … … … … … … … … … … … … … … … . . 35
2.3. memory … … … … … … … … … … … … … … … … … … … … … … . 35
2.3.1. Types … … … … … … … … … … … … … … … … … … … … … . 36
2.3.2. Constructors … … … … … … … … … … … … … … … … … … … . .36
2.3.3. Properties … … … … … … … … … … … … … … … … … … … … .36
2.3.4. Behaviors … … … … … … … … … … … … … … … … … … … … . 37
3</p></li>
</ol>
</section>
<section id="page-4">
<h2>Page 4<a class="headerlink" href="#page-4" title="Permalink to this heading"></a></h2>
<p>Contents
 
2.3.5. Callbacks … … … … … … … … … … … … … … … … … … … … . 40
2.3.6. Access Restrictions … … … … … … … … … … … … … … … … … . . 41
2.4. memory_alias … … … … … … … … … … … … … … … … … … … … . . 42
2.4.1. Types … … … … … … … … … … … … … … … … … … … … … . 42
2.4.2. Constructors … … … … … … … … … … … … … … … … … … … . .43
2.4.3. Properties … … … … … … … … … … … … … … … … … … … … .43
2.4.4. Behaviors … … … … … … … … … … … … … … … … … … … … . 44
2.4.5. Callbacks … … … … … … … … … … … … … … … … … … … … . 47
2.4.6. Access Restrictions … … … … … … … … … … … … … … … … … . . 48
2.5. reg … … … … … … … … … … … … … … … … … … … … … … … . . 48
2.5.1. Types … … … … … … … … … … … … … … … … … … … … … . 48
2.5.2. Constructors … … … … … … … … … … … … … … … … … … … . .49
2.5.3. Properties … … … … … … … … … … … … … … … … … … … … .49
2.5.4. Behaviors … … … … … … … … … … … … … … … … … … … … . 50
2.5.5. Callbacks … … … … … … … … … … … … … … … … … … … … . 54
2.5.6. Access Restrictions … … … … … … … … … … … … … … … … … . . 57
2.6. bitfield … … … … … … … … … … … … … … … … … … … … … … . . 57
2.6.1. Types … … … … … … … … … … … … … … … … … … … … … . 58
2.6.2. Constructors … … … … … … … … … … … … … … … … … … … . .58
2.6.3. Properties … … … … … … … … … … … … … … … … … … … … .59
2.6.4. Behaviors … … … … … … … … … … … … … … … … … … … … . 60
2.6.5. Callbacks … … … … … … … … … … … … … … … … … … … … . 61
2.6.6. Access Restrictions … … … … … … … … … … … … … … … … … . . 64
2.7. router … … … … … … … … … … … … … … … … … … … … … … … 64
2.7.1. Types … … … … … … … … … … … … … … … … … … … … … . 65
2.7.2. Constructors … … … … … … … … … … … … … … … … … … … . .65
2.7.3. Properties … … … … … … … … … … … … … … … … … … … … .66
2.7.4. Behaviors … … … … … … … … … … … … … … … … … … … … . 67
2.7.5. Callbacks … … … … … … … … … … … … … … … … … … … … . 71
2.8. memory utilities … … … … … … … … … … … … … … … … … … … … . 71
2.8.1. memory_index_reference … … … … … … … … … … … … … … … … .72
2.8.2. mappable_if … … … … … … … … … … … … … … … … … … … . . 73
2.8.3. Callback Base Classes … … … … … … … … … … … … … … … … . . 74
2.8.4. Convenience Functions … … … … … … … … … … … … … … … … . . 76
2.9. Deprecated API’s and Adapters … … … … … … … … … … … … … … … … 77
2.9.1. Callbacks … … … … … … … … … … … … … … … … … … … … . 77
2.9.2. TLM2 Adapters … … … … … … … … … … … … … … … … … … . . 79
2.9.3. tlm2_gp_target_adapter … … … … … … … … … … … … … … … … . . 79
2.9.4. tlm2_gp_initiator_adapter … … … … … … … … … … … … … … … … .82
4</p>
</section>
<section id="page-5">
<h2>Page 5<a class="headerlink" href="#page-5" title="Permalink to this heading"></a></h2>
<p>Contents
 
3. SCML2 Fast Timed (FT) Modeling … … … … … … … … … … … … … … … … … … … .83
3.1. Introduction to Fast Timed Modeling … … … … … … … … … … … … … … …83
3.1.1. SystemC Transaction-Level Modeling … … … … … … … … … … … … … 84
3.1.2. Use Cases … … … … … … … … … … … … … … … … … … … … 85
3.1.3. Fast Timed Modeling (FTM) Coding Style … … … … … … … … … … … …88
3.1.4. Modeling Concepts … … … … … … … … … … … … … … … … … . . 91
3.1.5. Creating FT Models … … … … … … … … … … … … … … … … … . . 94
3.2. Modeling Objects … … … … … … … … … … … … … … … … … … … …95
3.2.1. Payloads … … … … … … … … … … … … … … … … … … … … . .95
3.2.2. Sockets … … … … … … … … … … … … … … … … … … … … …97
3.2.3. Port Adaptors … … … … … … … … … … … … … … … … … … … .98
3.2.4. Protocol States … … … … … … … … … … … … … … … … … … . .124
3.2.5. Alignment in FT Protocols … … … … … … … … … … … … … … … . . 126
3.3. Protocol Definitions … … … … … … … … … … … … … … … … … … … 127
3.3.1. FT GFT Protocol Definition … … … … … … … … … … … … … … … . 127
3.3.2. FT AXI Protocol Definition … … … … … … … … … … … … … … … . . 136
3.3.3. FT ACE Protocol Definition … … … … … … … … … … … … … … … . 146
3.3.4. FT AXI4 Stream Protocol Definition … … … … … … … … … … … … … 149
3.3.5. FT CHI Protocol Definition … … … … … … … … … … … … … … … . .152
3.3.6. FT PCIe Protocol Definition … … … … … … … … … … … … … … … .154
3.3.7. FT CXL Protocol Definition … … … … … … … … … … … … … … … . 157
3.4. API Definitions … … … … … … … … … … … … … … … … … … … … .162
3.4.1. FT GFT API Definition … … … … … … … … … … … … … … … … . . 162
3.4.2. FT AXI API Definition … … … … … … … … … … … … … … … … . . 166
3.4.3. FT ACE API Definition … … … … … … … … … … … … … … … … . .175
3.4.4. FT AXI4 Stream API Definition … … … … … … … … … … … … … … . 176
3.4.5. FT CHI API Definition … … … … … … … … … … … … … … … … . . 179
3.4.6. FT PCIe API Definition … … … … … … … … … … … … … … … … . 184
3.4.7. FT CXL API Definition … … … … … … … … … … … … … … … … . . 185
3.5. Protocol Checker … … … … … … … … … … … … … … … … … … … . .185
3.5.1. Introduction … … … … … … … … … … … … … … … … … … … . .185
3.5.2. Features … … … … … … … … … … … … … … … … … … … … . 186
3.5.3. Input Requirements … … … … … … … … … … … … … … … … … . 187
3.5.4. Getting Started … … … … … … … … … … … … … … … … … … . .187
3.6. Protocol Conversion … … … … … … … … … … … … … … … … … … . . 192
3.7. Fast Track Logging in Fast Time Modeling … … … … … … … … … … … … …193
3.8. Examples … … … … … … … … … … … … … … … … … … … … … . . 195
3.9. The FT_blocks  Library … … … … … … … … … … … … … … … … … . . 197
5</p>
</section>
<section id="page-6">
<h2>Page 6<a class="headerlink" href="#page-6" title="Permalink to this heading"></a></h2>
<p>Contents
 
3.9.1. ft_cxs_bridge  Block … … … … … … … … … … … … … … … … . 198
3.9.2. ft_image_loader  Block … … … … … … … … … … … … … … … . .199
3.9.3. ft_axi_rd_wr_mux  Block … … … … … … … … … … … … … … … .201
3.9.4. ft_axi_rd_wr_demux  Block … … … … … … … … … … … … … … . 202
3.9.5. ft_axi_reorder_buffer  Block … … … … … … … … … … … … … . 204
3.9.6. ft_axi_splitter  Block … … … … … … … … … … … … … … … . .205
3.9.7. ft_axi_buffer  Block … … … … … … … … … … … … … … … … . 208
4. Clock Objects … … … … … … … … … … … … … … … … … … … … … … … … . 211
4.1. Overview … … … … … … … … … … … … … … … … … … … … … . . 211
4.2. Clocks and Reset … … … … … … … … … … … … … … … … … … … . 212
4.2.1. scml_clock … … … … … … … … … … … … … … … … … … … . . 212
4.2.2. scml_divided_clock … … … … … … … … … … … … … … … … … . 217
4.2.3. Dynamic Clock Parameter Change and Reset … … … … … … … … … … . 218
4.3. Modeling Objects for Clocks (Clock Objects) … … … … … … … … … … … … . 221
4.3.1. scml_clock_gate … … … … … … … … … … … … … … … … … … .222
4.3.2. scml_clock_counter … … … … … … … … … … … … … … … … … . 223
4.4. Base Classes … … … … … … … … … … … … … … … … … … … … . 223
4.4.1. scml2::clocked_module … … … … … … … … … … … … … … … … . 224
4.5. Modeling Objects for Base Classes (Modeling Objects) … … … … … … … … … . .226
4.5.1. scml2::clocked_timer … … … … … … … … … … … … … … … … … 226
4.6. Convenience Classes … … … … … … … … … … … … … … … … … … . 228
4.6.1. scml2::clocked_callback … … … … … … … … … … … … … … … … .228
4.6.2. scml2::clocked_event … … … … … … … … … … … … … … … … …230
4.7. Modeling Objects for Convenience Classes (Convenience Objects) … … … … … … . 233
4.7.1. scml2::clocked_peq_container … … … … … … … … … … … … … … . .233
4.7.2. scml2::clocked_peq … … … … … … … … … … … … … … … … … . 237
4.8. Code Example … … … … … … … … … … … … … … … … … … … … .242
4.8.1. Programmable Clock Peripherals … … … … … … … … … … … … … . . 242
5. Pulse TLM Modeling … … … … … … … … … … … … … … … … … … … … … … . . 244
5.1. The Pulse Interface … … … … … … … … … … … … … … … … … … …244
5.1.1. The Pulse Definition Interface … … … … … … … … … … … … … … . . 245
5.1.2. The Pulse Observer Interface … … … … … … … … … … … … … … . . 249
6. Modeling Utilities … … … … … … … … … … … … … … … … … … … … … … … . 252
6.1. Port Utilities … … … … … … … … … … … … … … … … … … … … … 252
6</p>
</section>
<section id="page-7">
<h2>Page 7<a class="headerlink" href="#page-7" title="Permalink to this heading"></a></h2>
<p>Contents
 
6.1.1. dmi_handler … … … … … … … … … … … … … … … … … … … . 252
6.1.2. initiator_socket … … … … … … … … … … … … … … … … … … . . 254
6.1.3. Pin Callback Functions … … … … … … … … … … … … … … … … . 257
6.1.4. Utility APIs … … … … … … … … … … … … … … … … … … … . . 258
6.2. Commands … … … … … … … … … … … … … … … … … … … … … 259
6.2.1. scml_command_processor … … … … … … … … … … … … … … … . 259
6.2.2. scml_loader … … … … … … … … … … … … … … … … … … … . 262
6.3. Parameters … … … … … … … … … … … … … … … … … … … … … 263
6.3.1. scml_property … … … … … … … … … … … … … … … … … … …264
6.3.2. scml_property_registry … … … … … … … … … … … … … … … … . .266
6.3.3. scml_property_server_if … … … … … … … … … … … … … … … … .268
6.3.4. scml_simple_property_server … … … … … … … … … … … … … … . . 269
6.4. Reporting … … … … … … … … … … … … … … … … … … … … … . . 270
6.4.1. status … … … … … … … … … … … … … … … … … … … … … 271
6.4.2. stream … … … … … … … … … … … … … … … … … … … … . . 272
6.4.3. severity … … … … … … … … … … … … … … … … … … … … . .273
6.5. FastTrack … … … … … … … … … … … … … … … … … … … … … . .274
6.5.1. FastTrack API … … … … … … … … … … … … … … … … … … . . 275
6.5.2. FastTrack Categories … … … … … … … … … … … … … … … … …277
6.5.3. Implicit FastTrack Messages … … … … … … … … … … … … … … … 281
6.5.4. Suppressing FastTrack Messages … … … … … … … … … … … … … . .283
7. Functional Coverage … … … … … … … … … … … … … … … … … … … … … … . .286
7.1. Functional Coverage … … … … … … … … … … … … … … … … … … . . 286
7.1.1. Coverage Semantics … … … … … … … … … … … … … … … … … 287
7.1.1.0. Functional Coverage Constructs … … … … … … … … … … … … . 287
7.1.1.0. Functional Coverage Exemptions … … … … … … … … … … … … 288
7.1.1.0. Functional Coverage Calculation … … … … … … … … … … … … . 289
7.1.2. SCML Functional Coverage Reference … … … … … … … … … … … … .289
7.1.2.0. Covergroup … … … … … … … … … … … … … … … … … … 290
7.1.2.0. Coverage Point Base Class … … … … … … … … … … … … … . . 290
7.1.2.0. Storage Coverage Points … … … … … … … … … … … … … … . 292
7.1.2.0. Parameter and Status Coverage Points … … … … … … … … … … . 294
7.1.2.0. Clock Coverage Point … … … … … … … … … … … … … … … 294
7.1.2.0. Signal Port Coverage Point … … … … … … … … … … … … … . . 294
7.1.2.0. TLM Socket Coverage Point … … … … … … … … … … … … … . 295
7.1.2.0. Generic Function Coverage Point … … … … … … … … … … … … 295
7.1.2.0. Coverbins … … … … … … … … … … … … … … … … … … . 296
7.1.2.0. Default Bin … … … … … … … … … … … … … … … … … … 297
7.1.3. Examples … … … … … … … … … … … … … … … … … … … … 298
7</p>
</section>
<section id="page-8">
<h2>Page 8<a class="headerlink" href="#page-8" title="Permalink to this heading"></a></h2>
<p>Contents
 
8. Modeling Guidelines … … … … … … … … … … … … … … … … … … … … … … . . 300
8.1. Requirements for a Virtual Prototype Model … … … … … … … … … … … … . .300
8.2. Virtual Prototype Model Content … … … … … … … … … … … … … … … . . 301
8.3. The SCML Modeling Guidelines for LT … … … … … … … … … … … … … …304
8.3.1. Modeling Methodology Guidelines … … … … … … … … … … … … … . .304
8.3.2. Coding Style Guidelines … … … … … … … … … … … … … … … … 310
8.4. Synchronization and Modeling for Speed … … … … … … … … … … … … … . 313
8.4.1. LT-Centric Simulation Techniques Overview … … … … … … … … … … … 314
8.4.2. Debugging Temporally Decoupled Systems … … … … … … … … … … … 318
8.4.3. Modeling Fast Target and Router Peripherals … … … … … … … … … … . .321
8.4.4. Optimizing Simulation Performance for FT Models … … … … … … … … … .325
8.5. Getting Started … … … … … … … … … … … … … … … … … … … … 339
8.5.1. Modeling a Memory … … … … … … … … … … … … … … … … … . 339
8.5.2. Modeling an Interrupt Controller … … … … … … … … … … … … … … 346
8.5.3. Modeling a Watchdog Peripheral … … … … … … … … … … … … … …359
8.5.4. Modeling a DMA … … … … … … … … … … … … … … … … … … 376
8.5.5. Modeling a Cache … … … … … … … … … … … … … … … … … . . 384
8.5.6. Example Timer Specification … … … … … … … … … … … … … … … 394
Index … … … … … … … … … … … … … … … … … … … … … … … … … … … . . 398
8</p>
</section>
<section id="page-9">
<h2>Page 9<a class="headerlink" href="#page-9" title="Permalink to this heading"></a></h2>
<p>9
Preface
The preface of the SystemC Modeling Library Reference Manual describes:
•
About This Manual
•
Documentation Conventions
•
Terminology
•
References
•
Customer Support
•
Statement on Inclusivity and Diversity
About This Manual
This manual describes SystemC Modeling Library 1 (SCML1) and SystemC Modeling Library 2
(SCML2) modeling objects. It also provides the guidelines on how to use SCML to create virtual
prototype models. SCML stands for SystemC Modeling Library; it is a C++ library of modeling
components built on top of TLM2.0 and SystemC, which are modeling libraries as well.
It is assumed that you have some knowledge of SystemC.
This manual is organized as follows:
•
Introduction gives an overview of the modeling objects and describes header files to be included.
•
Memory Objects describes the SystemC Modeling Library (SCML) modeling objects.
•
SCML2 Fast Timed (FT) Modeling discusses the different FT modeling interfaces and objects.
•
Clock Objects describes the SystemC Modeling Library (SCML) clock objects.
•
Pulse TLM Modeling describes the pulse interface which is the basis for Pulse TLM modeling.
•
Modeling Utilities describes the SCML modeling utilities.
•
Functional Coverage describes the SCML functional coverage reference for SystemC TLM
modeling.
•
Modeling Guidelines explains the guidelines for FT and LT modeling.
Documentation Conventions
This section lists and explains the documentation conventions used throughout this manual.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
9</p>
</section>
<section id="page-10">
<h2>Page 10<a class="headerlink" href="#page-10" title="Permalink to this heading"></a></h2>
<p>Preface
Documentation Conventions
Convention
Description and Examples
italic
Is used in running text for:
• GUI elements. For example:
The Enumeration field contains a space-separated list of values.
• New terms. For example:
A protocol library is a collection of protocol definitions.
• Web sites. For example:
For more information, see www.eclipse.org.
• E-mail addresses. For example:
Contact customer support through e-mail at vp_support&#64;synopsys.com.
• Manual names. For example:
The preface of the Analysis Manual describes:
courier
Is used for:
• Code text. For example:
list_library_configurations
myConfig
In this example, myConfig  is used.
• System messages. For example:
JVM not found.
• Text you must type literally. For example:
At the prompt, type go.
• Names (of environment variables, commands, utilities, prompts, paths, macros,
and so on). For example:
The build-options  command sets build parameters.
courier italic
Indicates variables. For example:
scope specifies a module, a channel, or a refined port.
courier bold
Serves to draw your attention to the text in question. For example:
coreId = cwrSAGetCoreId(“mycore”);
[ ]
Square brackets enclose optional items. For example:
clean [-pch]
If you must type a square bracket as part of the syntax, it is enclosed in single
quote. For example:
‘[’–use-vector’]’
{ }
Braces enclose a list from which you must choose one or more items. For example:
add {signalPattern|portPattern}ID
If you must type a brace as part of the syntax, it is enclosed in single quote. For
example:
DECLARE ‘{’ Item1 Item1 ‘}’
|
A vertical bar separates items in a list of choices. For example:
autoflush {on | off}</p>
<p>A right angle bracket separates menu commands. For example:
The Project &gt; Update System Library menu command is available.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
10</p>
</section>
<section id="page-11">
<h2>Page 11<a class="headerlink" href="#page-11" title="Permalink to this heading"></a></h2>
<p>Preface
Terminology
11
Convention
Description and Examples
…
A horizontal ellipsis in syntax indicates that the preceding expression may have
zero, one, or more occurrences. For example:
build-options -option optionArgs…
A horizontal ellipsis in examples and system messages indicates material that has
been omitted. For example:
::scsh&gt; dtrace add top1.signal_* <span class="math notranslate nohighlight">\(t1
          ::scsh&gt; dtrace add top1.clk_* \)</span>t1 …
::scsh&gt; dtrace flush *
Terminology
This section lists and explains the terminologies used throughout this manual.
A
p
p
l
i
c
a
t
i
o
n</p>
<p>P
r
o
g
r
a
m
m
e
r
’
s</p>
<p>I
n
t
e
r
f
a
c
e
.</p>
<p>S
e
e</p>
<p>A
P
I
A
P
I
,</p>
<p>d
e
f
i
n
i
t
i
o
n
API
Application Programmer’s Interface
A
S
I</p>
<p>T
L
M</p>
<p>W
G
,</p>
<p>d
e
f
i
n
i
t
i
o
n
ASI TLM WG
Accellera Systems Initiative Transaction-Level Modeling Work Group
A
p
p
r
o
x
i
m
a
t
e
l
y</p>
<p>T
i
m
e
d
.</p>
<p>S
e
e</p>
<p>A
T
A
d
d
r
e
s
s</p>
<p>T
y
p
e
.</p>
<p>S
e
e</p>
<p>A
T
A
T
,</p>
<p>d
e
f
i
n
i
t
i
o
n
AT
In the context of PV, AT stands for Address Type. In the context of TLM2, AT
stands for Approximately Timed.
A
r
c
h
i
t
e
c
t
’
s</p>
<p>V
i
e
w
.</p>
<p>S
e
e</p>
<p>A
V
A
V
,</p>
<p>d
e
f
i
n
i
t
i
o
n
AV
Architect’s View
C
o
m
p
u
t
e</p>
<p>E
x
p
r
e
s
s</p>
<p>L
i
n
k
.</p>
<p>S
e
e</p>
<p>C
X
L
C
X
L
,</p>
<p>d
e
f
i
n
i
t
i
o
n
CXL
Compute Express Link
D
i
r
e
c
t</p>
<p>M
e
m
o
r
y</p>
<p>A
c
c
e
s
s
.</p>
<p>S
e
e</p>
<p>D
M
A
D
M
A
,</p>
<p>d
e
f
i
n
i
t
i
o
n
DMA
Direct Memory Access
D
a
t
a</p>
<p>T
y
p
e
.</p>
<p>S
e
e</p>
<p>D
T
D
T
,</p>
<p>d
e
f
i
n
i
t
i
o
n
DT
Data Type
F
i
r
s
t</p>
<p>I
n</p>
<p>F
i
r
s
t</p>
<p>O
u
t
.</p>
<p>S
e
e</p>
<p>F
I
F
O
F
I
F
O
,</p>
<p>d
e
f
i
n
i
t
i
o
n
FIFO
First In First Out
I
n
t
e
l
l
e
c
t
u
a
l</p>
<p>P
r
o
p
e
r
t
y
.</p>
<p>S
e
e</p>
<p>I
P
I
P
,</p>
<p>d
e
f
i
n
i
t
i
o
n
IP
Intellectual Property
L
o
o
s
e
l
y</p>
<p>T
i
m
e
d
.</p>
<p>S
e
e</p>
<p>L
T
L
T
,</p>
<p>d
e
f
i
n
i
t
i
o
n
LT
Loosely Timed
P
l
a
i
n</p>
<p>O
l
d</p>
<p>D
a
t
a</p>
<p>T
y
p
e
.</p>
<p>S
e
e</p>
<p>P
O
D
T
P
O
D
T
,</p>
<p>d
e
f
i
n
i
t
i
o
n
PODT
Plain Old Data Type
P
e
r
i
p
h
e
r
a
l</p>
<p>C
o
m
p
o
n
e
n
t</p>
<p>I
n
t
e
r
c
o
n
n
e
c
t</p>
<p>E
x
p
r
e
s
s
.</p>
<p>S
e
e</p>
<p>P
C
I</p>
<p>E
x
p
r
e
s
s
P
C
I</p>
<p>E
x
p
r
e
s
s
,</p>
<p>d
e
f
i
n
i
t
i
o
n
PCI Express
Peripheral Component Interconnect Express
P
r
o
g
r
a
m
m
e
r
’
s</p>
<p>V
i
e
w
.</p>
<p>S
e
e</p>
<p>P
V
P
V
d
e
f
i
n
i
t
i
o
n
PV
Programmer’s View
P
u
l
s
e</p>
<p>W
i
d
t
h</p>
<p>M
o
d
u
l
a
t
i
o
n
.</p>
<p>S
e
e</p>
<p>P
W
M
P
W
M
d
e
f
i
n
i
t
i
o
n
PWM
Pulse Width Modulation
S
y
s
t
e
m
C</p>
<p>M
o
d
e
l
i
n
g</p>
<p>L
i
b
r
a
r
y</p>
<p>1
.</p>
<p>S
e
e</p>
<p>S
C
M
L
1
S
C
M
L
1
,</p>
<p>d
e
f
i
n
i
t
i
o
n
SCML1
SystemC Modeling Library 1
S
y
s
t
e
m
C</p>
<p>M
o
d
e
l
i
n
g</p>
<p>L
i
b
r
a
r
y</p>
<p>2
.</p>
<p>S
e
e</p>
<p>S
C
M
L
2
S
C
M
L
2
,</p>
<p>d
e
f
i
n
i
t
i
o
n
SCML2
SystemC Modeling Library 2
S
o
c
k
e
t</p>
<p>T
r
a
n
s
a
c
t
i
o
n</p>
<p>L
a
n
g
u
a
g
e
.</p>
<p>S
e
e</p>
<p>S
T
L
S
T
L
,</p>
<p>d
e
f
i
n
i
t
i
o
n
STL
Socket Transaction Language
SystemC Modeling Library Reference Manual
X-2025.06-SP1
11</p>
</section>
<section id="page-12">
<h2>Page 12<a class="headerlink" href="#page-12" title="Permalink to this heading"></a></h2>
</section>
<section id="preface-references-t-r-a-n-s-a-c-t-i-o-n">
<h2>Preface
References
T
r
a
n
s
a
c
t
i
o
n<a class="headerlink" href="#preface-references-t-r-a-n-s-a-c-t-i-o-n" title="Permalink to this heading"></a></h2>
<p>L
e
v
e
l</p>
<p>M
o
d
e
l
i
n
g
.</p>
<p>S
e
e</p>
<p>T
L
M
T
L
M
,</p>
<p>d
e
f
i
n
i
t
i
o
n
TLM
Transaction-Level Modeling
V
i
r
t
u
a
l</p>
<p>P
r
o
c
e
s
s
i
n
g</p>
<p>U
n
i
t
.</p>
<p>S
e
e</p>
<p>V
P
U
V
P
U
,</p>
<p>d
e
f
i
n
i
t
i
o
n
VPU
Virtual Processing Unit
References
This manual focuses on the use of SystemC, TLM2.0, and SCML for the creation of virtual prototype
models. For more details on other use cases and detailed semantics of the libraries, see the following
manuals:
•
SystemC Language Reference Manual,IEEE Std 1666™-2023
•
IEEE Standard for Standard SystemC®  Language Reference Manual,IEEE Std 1666™-2023
For details on interconnect components and the integration of processor models, see the Integrating
Third-Party Instruction-Accurate Models manual.
Customer Support
For technical support (regarding license keys, IP downloads, Host ID, Project ID, documentation or
general support), contact the Support Center with a description of your question and supplying the
debug information, using one of the following methods:
•
Go to https://solvnetplus.synopsys.com and sign-in with your Synopsys SolvNetPlus credentials.
Select Cases from the menu bar, and select Create a New Case. Provide the requested information,
including:
◦
Product L1: Virtual Prototyping.
◦
Product L2: Select the product type that closest matches yours.
◦
Case Type: Select the case type from the drop-down menu.
◦
Case Severity: Select the case severity from the drop-down menu.
◦
Subject: Provide a brief summary of the issue or list the error message you have encountered.
◦
Description:  For simulation issues, include the timestamp of any signals or locations in
waveforms that are not understood.
After creating the case, attach the debug files you have created, if any.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
12</p>
</section>
<section id="page-13">
<h2>Page 13<a class="headerlink" href="#page-13" title="Permalink to this heading"></a></h2>
<p>Preface
Statement on Inclusivity and Diversity
13
•
Or, send an e-mail message to vp_support&#64;synopsys.com. Your email is queued and then, on a
first-come, first-served basis, manually routed to the correct support engineer:
◦
Include the Product name, Sub Product name, and Tool Version number in your email;
so that it can be routed correctly. For this information, see <span class="math notranslate nohighlight">\(SNPS_VP_HOME/common/etc/
release_name.txt  in your installation.
◦
Include exact Patch-level detail of the Tool Version also in your email. To view the list of patches 
installed for the tool, execute the command:
\)</span>SNPS_VP_HOME/common/bin/patch_history.sh
◦
For simulation issues, include the timestamp of any signals or locations in waveforms that are not
understood.
◦
Attach any debug files you created in the previous step.
•
Or, telephone your local support center:
◦
North America:
Call 1-800-245-8005 from 7:00 AM to 5:30 PM Pacific time, Monday through Friday.
◦
All other countries:
https://www.synopsys.com/support/global-support-centers.html
Statement on Inclusivity and Diversity
Synopsys is committed to creating an inclusive environment where every employee, customer, and
partner feels welcomed. We are reviewing and removing exclusionary language from our products
and supporting customer-facing collateral. Our effort also includes internal initiatives to remove biased
language from our engineering and working environment, including terms that are embedded in our
software and IPs. At the same time, we are working to ensure that our web content and software
applications are usable to people of varying abilities. You may still find examples of non-inclusive
language in our software or documentation as our IPs implement industry-standard specifications that
are currently under review to remove exclusionary language.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
13</p>
</section>
<section id="page-14">
<h2>Page 14<a class="headerlink" href="#page-14" title="Permalink to this heading"></a></h2>
<p>Chapter 1
Introduction
This chapter describes:
•
SCML2 Introduction
•
Header Files
•
SCML2 FT Modeling Interfaces
•
SCML2 Modeling Objects
1.1. SCML2 Introduction
SCML2 is an easy-to-use abstraction layer on top of SystemC and TLM2. It hides a lot of the complexity
and common code that is required to correctly manage TLM2 transactions and it provides with modeling
objects that handle common aspects of Virtual Prototype modeling.
1.2. Header Files
All SCML2 header files can be included by including scml2.h. The SCML2 headers enable the Memory
objects as well as the FT Model interface APIs and objects.
All SCML2 logging header files can be included by including scml2_diagnostics.h.
The utility objects as well as the deprecated modeling objects are available after the scml.h  file has
been included.
#include “scml.h”
The clock modeling objects are available after the scml_clock.h  file has been included.
#include “scml_clock.h”
1.3. SCML2 FT Modeling Interfaces
This section describes:
•
Introduction to TLM2.0
•
Extending TLM2.0 Base Protocol
SystemC Modeling Library Reference Manual
X-2025.06-SP1
14</p>
</section>
<section id="page-15">
<h2>Page 15<a class="headerlink" href="#page-15" title="Permalink to this heading"></a></h2>
<p>Chapter 1: Introduction
 
1.3.1. Introduction to TLM2.0
The SCML2 FT modeling interfaces are based on the TLM2.0 standard, but extended to provide the
support for additional hardware protocols while maintaining maximal interoperability and increased ease
of use.
The basic communication elements defined in TLM2.0 are based on interfaces and sockets.
•
TLM2.0 defines communication between components through a combination of a forward path and
a backward path. These paths are implemented as interface method calls, as supported in the IEEE
SystemC standard. This approach allows both the initiator of a transaction as well as the target to
control the progress and timing of a transaction.
•
SystemC defines ports and exports as the endpoints of a communication connection, each capable
of initiating or implementing a communication interface. TLM2.0 extends this with sockets which are
a combination of a port and an export so that the combined forward and backward path can be tied
together using a single communication connection.
Combining these together leads to components that have sockets as endpoints for communication,
where each socket enables both the forward path and backward path interface definitions. By definition,
a TLM2.0 protocol defines a point-to-point communication interface. Therefore, it should always be
possible to connect any TLM2.0 initiator to a TLM2.0 target if they use the same protocol definition. This
is graphically represented below.
Figure 1: TLM2.0 Background
The interface definitions themselves each define a set of method calls:
•
In the forward part, the following methods are defined:
void b_transport(TRANS &amp;trans, sc_core::sc_time &amp;t)
◦
b_transport: Is used in the loosely timed coding style to implement a transaction exchange
between initiator and target. When the call returns, the transaction is finished. There are two
timing points: the start and end of a transaction. The call is blocking, which means the initiator
should start the call from a sc_thread. The target is allowed to call wait to implement a delay.
There is also a sc_time  argument in the call which allows to annotate the timing delay for the
endpoint of the transaction. The other argument of the call is the transaction payload.
enum tlm_sync_enum { TLM_ACCEPTED, TLM_UPDATED, TLM_COMPLETED};</p>
<p>tlm_sync_enum nb_transport_fw(TRANS &amp;trans, PHASE &amp;phase, sc_core::sc_time &amp;t)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
15</p>
</section>
<section id="page-16">
<h2>Page 16<a class="headerlink" href="#page-16" title="Permalink to this heading"></a></h2>
<p>Chapter 1: Introduction
 
◦
nb_transport_fw: Is used in the approximately timed coding style and implements part of a
transaction exchange between initiator and target. The call is non-blocking, which means that it
is not allowed to call wait in the implementation, so that it can be called from an sc_method. Also,
this call has an sc_time  argument to allow timing annotation. The other arguments are payload
and phase, where phase  indicates the timing point or state of the protocol state machine. The
return value is an indicator whether the payload  and phase  have been updated by the interface
implementation before returning the call, or whether the transaction is completed.
bool get_direct_mem_ptr(TRANS&amp; trans, tlm_dmi&amp; dmi_data)
◦
get_direct_mem_ptr: This call is used by the initiator to request direct access to the data
storage that corresponds to the payload access request. The argument dmi_data  is a data
structure specific to make DMI requests, which is setup by the initiator and completed by the
target in case DMI is allowed (which is indicated by the return value).
unsigned int transport_dbg(TRANS&amp; trans)
◦
transport_dbg  interface: This debugging call is used by the initiator to access storage in the
system, all interconnect and target models should implement the debug interface so that there
are no side-effects (no delay, event notifications, state change and so on).
In the backward path the following methods are defined:
tlm_sync_enum nb_transport_bw(TRANS &amp;trans, PHASE &amp;phase, sc_core::sc_time &amp;t)
◦
nb_transport_bw: This is the corresponding interface for the nb_transport_fw, now called
from the target side of the connection.
void invalidate_direct_mem_ptr(sc_dt::uint64 start_range,
sc_dt::uint64 end_range)
◦
invalidate_direct_mem_ptr: A method used by the target side of a connection to indicate that
direct memory access to a certain address region is no longer allowed. This could be caused by
a remap or reprogramming of the address regions in the interconnect components.
TLM2.0 also defines a base protocol, which contains a generic memory-mapped payload and defines
a set of generic protocol timing points to be used for this protocol in the AT coding style. The payload
definition contains address, data, data_length, command, response  and more attributes so that a
generic memory mapped data transfer can be modeled. There are four timing points defined for the
base protocol, they represent two transfers or basic exchanges between the initiator and the target.
•
BEGIN_REQ, END_REQ: Represents the start of the transaction and indicates a request by the initiator
to exchange data. The target responds when it is ready to accept the data.
•
BEGIN_RESP, END_RESP: Represents the completion of the transaction and indicates the response
by the target that it has consumed the transaction. The initiator responds when it has accepted the
completion of the transaction.
The base protocol only allows one REQ  or RESP  transfer at a time, so an initiator cannot start another
transaction until it has received an END_REQ  or a target cannot complete a new transaction until it has
received the END_RESP  of the previous one. This is graphically represented below.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
16</p>
</section>
<section id="page-17">
<h2>Page 17<a class="headerlink" href="#page-17" title="Permalink to this heading"></a></h2>
<p>Chapter 1: Introduction
 
Figure 2: Initiator and Target
With these combined interfaces, a TLM2.0 socket supports both an LT and AT modeling style, even
more: every TLM2.0 component is required to support both modeling styles. The FT coding style
further builds on this aspect of the TLM2.0 standard, but provides ease of use and interoperability
features through specialized sockets and payload definitions. The TLM2.0 interfaces are untouched
and all modifications are done in a TLM2.0 compatible way so that interoperability with strict TLM2.0
components remains.
1.3.2. Extending TLM2.0 Base Protocol
The TLM2.0 base protocol is not intended to resemble any real life hardware protocol, but is intended
as a generic interface. Key problems for the TLM2.0 base protocol are:
•
It does not provide with timing points for the individual data beats of a burst transfer.
•
It requires all address and data information to be available for writes at the start of the transaction.
•
It is not possible to have concurrent read and write requests.
Therefore, it is required to have dedicated payload  and phases  to model a hardware protocol. The
TLM2.0 standard intends that the base protocol can serve as bases to create payload  and phase
definitions that accurately model a real hardware protocol. The TLM2.0 standard also provides some
basic rules and advice on how to do this by defining mandatory and ignorable extensions to the TLM2.0
base protocol. Extensions are additional payload attributes that can be added to the standard payload
to add the additional features of real hardware protocols. It is also possible to extend or overwrite
the phase  definitions that are used in the non-blocking transport API calls. The standard requires
mandatory extensions whenever a component is required to recognize and react to a payload or phase
extension. The drawback of mandatory extensions is that they imply a change to the types used in
the interfaces of the TLM2.0 sockets, which in turn makes it impossible to connect components with
different mandatory extensions with each other. The benefit of this approach is that incompatible
components are easily recognized.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
17</p>
</section>
<section id="page-18">
<h2>Page 18<a class="headerlink" href="#page-18" title="Permalink to this heading"></a></h2>
<p>Chapter 1: Introduction
 
The FT modeling interfaces take a different approach to this problem. Transactors or protocol
conversion blocks are a major modeling pain when assembling a system and also a major cause for
performance issues. Therefore, the FT modeling approach starts by requiring that all interfaces remain
compatible with the TLM2.0 base protocol and rely on extended sockets and payload to provide the
necessary protocol conversion logic so that conversions are only done when they are required and can
be inserted automatically.
As a consequence the FT modeling interfaces use ignorable payload extensions:
•
Each protocol defines a protocol state extension. This is a payload extension carrying the actual
protocol timing label, indicating the current state in the protocol state machine.
•
For each protocol, there can be protocol-specific attributes added using an extension. This should
be limited to those attributes that do not map to the TLM2.0 base protocol. These extensions are
ignorable in the sense that a model should assume they have a default in case they are not present
in the payload. At the same time, they are non-ignorable since a model can ignore the TLM2.0 base
protocol semantics that are overruled by the protocol specific attributes.
There is one ignorable phase extension defined for the TLM2.0 base protocol: FT_TIMING. This is
presented as an additional timing point indicating that the protocol state extension should be used to
determine the actual current protocol state.
The FT modeling interfaces are compatible with the TLM2.0 standard in the sense that through the
protocol conversion mechanisms, any TLM2.0 base protocol component will never notice that it is
interfacing with a component that internally does not use the base protocol phases or parts of the
payload.
This protocol conversion relies on an extended socket that has one additional user API namely
set_protocol. This API indicates the protocol extensions that is used inside the model. At the start
of the simulation, the initiators and target sockets checks what protocol is used by the socket they are
connected to and insert a protocol conversion if available. A protocol conversion to the TLM2.0 base
protocol should always be available. When defining an FT protocol interface, the base protocol mapping
is a part of the definition. Conversion from and to AXI and GFT protocol is also available as part of the
extended socket semantics.
1.4. SCML2 Modeling Objects
SCML2 contains a wide range of modeling objects addressing different aspects of modeling. They are
discussed in more detail in the coming sections.
1.4.1. Storage Modeling Objects
The storage modeling objects in SCML2 have been created to abstract and hide some of the tedious
details of the TLM2.0 APIs while providing a simple mechanism to describe the memory map of a
peripheral and to develop the behaviors that are associated with the different registers and bitfields of
the component.
o
v
e
r
v
i
e
w
S
t
o
r
a
g
e</p>
<p>M
o
d
e
l
i
n
g</p>
<p>O
b
j
e
c
t
s
The following table provides an overview of the SCML2 modeling objects.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
18</p>
</section>
<section id="page-19">
<h2>Page 19<a class="headerlink" href="#page-19" title="Permalink to this heading"></a></h2>
<p>Chapter 1: Introduction
 
Table 1: SCML2 Modeling Objects
Modeling Object
Description
memory
Models memories and register files.
memory_alias
Models an alias for a memory region of another memory or
memory_alias object.
reg
A register; it models a memory_alias object of size 1.
bitfield
Models an alias for a number of consecutive bits in a reg object.
router
Models a dynamic address decoder that can map a memory region to a
region in another memory, router, or tlm2_gp_initiator_adapter object.
All the modeling objects and global functions are part of the scml2  namespace.
The following table provides an overview of the SCML helper functions.
Table 2: SCML2 Helper Functions
Helper Functions
Description
memory_index_reference
Is an intermediate object used when dealing with indexes on memory  and
memory_alias  objects.
mappable_if
Is the definition of the interface to the memory objects. It is used by the
target adapter and the router object.
These modeling objects are structured hierarchically as follows:
•
Memories:
◦
Memory: Is the top-level entry for a component memory map. It is the only modeling object that
maintains actual storage. This modeling object can have associated behavior.
◦
Memory_alias: Refers to a section of the memory and can be used to define specialized
behaviors per region or to provide with logical names for different sections in the memory map.
◦
Reg: Is an alias of size one word.
◦
Bitfield: Is a subword region.
•
Router: is used to model programmable forwarding of memory accesses to different internal
memories or initiator ports.
The memory storage objects have a default behavior that corresponds to the TLM2.0 blocking transport
and debug APIs, plus they implement the get_direct_memory_ptr  interface. Memories can be
connected to the FT sockets using an adapter which implements a couple of conversions to make sure
the SCML2 memory semantics can remain simple and also takes care of the non-blocking to blocking
transport conversion if needed. Through this combination of features, it becomes extremely simple to
SystemC Modeling Library Reference Manual
X-2025.06-SP1
19</p>
</section>
<section id="page-20">
<h2>Page 20<a class="headerlink" href="#page-20" title="Permalink to this heading"></a></h2>
<p>Chapter 1: Introduction
 
build a memory model. Simply instantiating a SCML2 memory and connecting it to a TLM2.0 target
socket using an adapter is sufficient. All TLM2.0 APIs are taken care of automatically and are of no
worry to the developer. Adding aliases and registers allows the creation of a meaningful memory map
for the component. All address decoding is automatically taken care of. Finally by registering callbacks
to implement the register behavior it is very easy to construct the functional model of a component.
There are a set of default behaviors available that can be registered with the memory objects.
These are behaviors like: ignore, read_only, write_only, clear_on_read, word_only, error,
set_on_read, clear_on_write_1, clear_on_write_0, set_on_write_1, set_on_write_0. Some
of these are only available for the register objects. For a complete list and API details, see Memory
Objects.
As already mentioned, it is possible to override the default behavior (which is storage) by registering a
callback with a storage object. The following callback types are available:
•
Transport callback: This is a callback that reuses the TLM2.0 transport API arguments and gives
full control over the interpretation and handling of the transaction payload. This can be used when
additional extensions of the payload need to be accessed which are not handled by the storage
objects.
•
Read and Write callbacks: are callbacks that only override the read or write behavior. Various
versions of these callbacks exist: they have a data pointer as argument, but variants with and
without byte_enables, sc_time  argument exist. There is also a tagged version that can be used
to pass the index of the memory element that is accessed into the callback. The return value of the
callbacks is the tlm_response_status  attribute as used in the payload. The storage object passes
this back using the transaction payload.
•
Debug: An API to override the default debug behavior of that storage object.
Callbacks can be registered and unregistered so that context-specific behavior can be enabled, or
also as speed optimization when there is only need to have a certain behavior when the component
is in a specific state. Callbacks disable DMI behavior and as a consequence have an impact on the
simulation speed. This is typically not an issue since callbacks are typically associated with peripheral
components that are accessed infrequently (compared to memory and caches). It is possible to create
additional “custom” callbacks that can be reused for different modules by creating a class that derives
from scml2::memory_callback_base  and that implements the execute(payload, sc_time) interface.
Callbacks are related to the LT coding style, this means it is allowed to call wait()  in the callback
implementation and there are different synchronization possibilities that can be indicated when a
callback is registered.
•
NEVER_SYNCING: This means that the call is non blocking by nature and that it never calls wait.
•
SELF_SYNCING: This means the callback is blocking and might call wait.
•
AUTO_SYNCING: In this case, the callback is blocking and may call wait. The memory object
synchronizes with the SystemC time before calling the callback. The timing annotation passed to the
callback always be SC_ZERO_TIME.
For a more detailed overview of every callback and access function that is available for the storage
objects, see Memory Objects.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
20</p>
</section>
<section id="page-21">
<h2>Page 21<a class="headerlink" href="#page-21" title="Permalink to this heading"></a></h2>
<p>Chapter 1: Introduction
 
1.4.2. Timing and Synchronization
The timing and synchronization modeling objects are mostly related to the clocked modeling style
and provide ease of use features to align the execution of models with clock boundaries since timing
annotation on the TLM2.0 interfaces is not guaranteed to be aligned with the internal clock of a model.
The FT modeling style defines a set of additional clock objects and interfaces, but is created such
that compatibility with the traditional SystemC clocked modeling style is maintained. Traditionally in
SystemC, a clock connection is represented by a Boolean signal. This means that clock ports are
represented by a sc_in<bool>  port in SystemC. The FT modeling style maintains this style. So all clock
connections are preferably done through signals and sc_in/out<bool>  ports.
For full compatibility, clock generators should provide with an scml_clock  object (see below) to provide
the signal interface on the ports. This coding pattern allows to mix and match components that use a
traditional SystemC clocked modeling style and the FT clock modeling style.
To retrieve the incoming clock from an sc_in<bool>  input, the following API is provided:
// sc_in<bool> -&gt; SCML clock
scml_clock_if* scml2::get_scml_clock(sc_core::sc_in<bool>&amp; clk,
bool allow_stubbed=false);
The API retrieves the corresponding scml_clock_if*  for the incoming clock. The second argument
allow_stubbed  controls the behavior if the signal interface is not bound to an SCML clock. If it is false
or not provided and no SCML clock could be retrieved from the signal interface, then the API fails by
printing an error message and terminating the simulation. If allow_stub  is set to true, it is possible to
stub the input signal by binding it to any bool  output port. In that case, the API returns a NULL  pointer
when no clock could be retrieved from the signal interface.
This coding pattern is supported by the GenericIPLib  clock generator that is provided with Platform
Creator. It is very much advised that each component that has a clock output follows the same pattern
to ensure that there is a signal interface as well as an scml_clock  object available for each clock
connection.
Figure 3: The Coding Pattern
The following clocked modeling objects are provided for the FT modeling style:
Table 3: Clocked Modeling Objects
Modeling Object
Description
scml_clock
Implements sc_clock_if. It is an optimized version of sc_clock.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
21</p>
</section>
<section id="page-22">
<h2>Page 22<a class="headerlink" href="#page-22" title="Permalink to this heading"></a></h2>
<p>Chapter 1: Introduction
 
Table 3: Clocked Modeling Objects (Continued)
Modeling Object
Description
scml_clock_gate
This is a module which takes a clock and an enable as inputs and produces a
gated clock as output.
scml_divided_clock
This is a clock derived from another clock by multiplying the start time and/or
the period with specified integer factors.
clocked_module
This is the base class for modules that want to receive SCML clock tick
callbacks.
clocked_callback
This is a convenience class that forwards a clock tick callback to any member
function of a module without the need to inherit from the clocked_module
base class.
clocked_timer
This is a modeling object that provides a timer callback mechanism based on
an SCML clock.
clocked_event
This is a convenience class that allows a SystemC method or thread to wait
until a certain clock tick happens.
clocked_peq_container
This is a modeling object for TLM2 FT models using the non-blocking APIs. It
buffers payload arriving in the model, like multiple outstanding transactions,
possibly coming with different timing annotations from different initiators.
clocked_peq
This is a modeling object similar to the clocked_peq_container  that can
trigger a callback whenever an element from the payload buffer becomes
available.
A detailed reference documentation of the clocked modeling objects can be found in Clock Objects.
1.4.3. Utility Objects
SCML2 also contains a set of ease of use objects that deal with various aspects of creating
a component model. Since they do not really fit one of the main categories (timing  and
synchronization) an overview for all of them is given in this section.
o
v
e
r
v
i
e
w
U
t
i
l
i
t
y</p>
<p>O
b
j
e
c
t
s
The following table provides an overview of the SCML2 utility objects.
Table 4: SCML2 Utility Objects
Modeling Object
Description
tlm2_gp_target_adapter
Allows a memory object to bind to a tlm2_target_socket.
tlm2_gp_initiator_adapter
Allows a router object to map a memory region to a region on a
tlm2_initiator_socket.
dmi_handler
Is a convenience object to do the bookkeeping of DMI pointers.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
22</p>
</section>
<section id="page-23">
<h2>Page 23<a class="headerlink" href="#page-23" title="Permalink to this heading"></a></h2>
<p>Chapter 1: Introduction
 
Table 4: SCML2 Utility Objects (Continued)
Modeling Object
Description
initiator_socket
Is a convenience socket that first tries to do a DMI access before doing a
bus access.
status
Is a simple object that holds a status value in string format.
stream
Is the front-end object of SCML2 logging library. It formats the output and
sends it to the back-end logger objects for processing.
severity
Holds a severity name and a value. Lower severity values mean a higher
severity level.
For more details on the objects, see Memory Objects and Modeling Utilities.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
23</p>
</section>
<section id="page-24">
<h2>Page 24<a class="headerlink" href="#page-24" title="Permalink to this heading"></a></h2>
<p>Chapter 2
Memory Objects
This chapter describes:
•
Introduction
•
Overview
•
memory
•
memory_alias
•
reg
•
bitfield
•
router
•
memory utilities
•
Deprecated API’s and Adapters
2.1. Introduction
The SCML memory objects serve several purposes:
•
They provide with a default implementation of the TLM2 interfaces and generic payload.
•
They provide with a mechanism to describe the memory map of a component.
•
They should be used to model simple storage objects in a component.
•
They have the necessary hooks to model the behaviors that are associated with an access to the
elements in the memory map of a component.
The SCML memory objects only implement the Loosely Timed API’s of the TLM2 interface, so they
cannot interface directly with the TLM2 sockets, a port_adapter  is required to handle timing and
protocol conversion features of FT models (see Port Adaptors).
The interface used by the SCML memory objects is the mappable_if  (see mappable_if).
2.2. Overview
This section provides a short overview of the different memory objects and their common features.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
24</p>
</section>
<section id="page-25">
<h2>Page 25<a class="headerlink" href="#page-25" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
2.2.1. Transaction Routing From Socket to Memories
The scml2::memory  is the top-level object to model the internal storage of a component, the other
objects specify subregions within a memory. An scml2::memory  can be bound to a target socket using
a port_adapter. Multiple target sockets can be bound, each with its own port_adapter, to the same
memory. All target sockets sees the memory at the same address.
To model multiple memory regions in a component, or when storage is seen at different locations from
different sockets, an scml2::router  can be used.
The scml2::router  object is used to implement local address decoding and/or transaction forwarding
in a model. A router  can be bound to a target socket using a port_adapter. The router  maintains a
map of address regions for the target port. Each address region is associated with a memory or initiator
port to which the transactions in that address region need to be forwarded. This allows to connect
multiple memories to a single target port at different addresses, but it also allows complex and dynamic
transaction routing to memories and initiator ports.
2.2.2. Memory Map Modeling
The different memory objects can be used to model the memory map of a component.
The starting point for a memory map is the scml2::memory  object. This object provides with the basic
storage implementation, the handling of the TLM2 API’s and the semantics of the generic payload.
It is not possible to create a memory map consisting only of registers or bitfields, these objects need
the scml2::memory  object to convert generic payload transactions into simple register and bitfield
accesses.
All other memory objects need an scml2::memory  as parent object (directly or indirectly). A
memory_alias  represents a subrange in a memory and takes either a memory or another alias as
parent. The address range represented by the alias should be smaller or have the same size as its
parent object. The scml2::reg  is intended to represent a single word in a memory map and can have
a memory or an alias as parent. A bitfield represents a range of bits within a register, it can only have a
register as parent.
Each memory object is templatized by its datatype (<DT>). The datatype defines the size of the
individual elements (or words) in the memory object. The size of that datatype (in bytes) is also used
to determine the address range represented by the memory object. The scml2::memory  object
determines the base size for all objects in its hierarchy. It is possible, for example, registers in a memory
to have a word size that is a multiple of the word size of the memory. This allows to model memory
maps with varying sized registers, in such a case it is easiest to work with an scml2::memory  with
datatype unsigned char  which allows registers of any other supported datatype to be used in that
memory map.
2.2.3. Properties and Attributes
All memory objects have a name and a width. The width gives the size of the datatype in bytes.
They also have a DMI attribute to control whether the TLM2 direct memory interface is enabled for
SystemC Modeling Library Reference Manual
X-2025.06-SP1
25</p>
</section>
<section id="page-26">
<h2>Page 26<a class="headerlink" href="#page-26" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
that object. Each object can control this individually, a hierarchical object forwards its setting to all its
children.
An scml2::memory  has latency parameters. These are latency parameters that apply for all objects in
that memory hierarchy.
All objects, except scml2::reg  have a size attribute and all child object have a reference to their parent
object.
2.2.4. Behavior
To access the content of the storage objects there are multiple APIs available to support the different
situations where memory access could be required. The variants differ in the way callbacks are
triggered and debugger watchpoints are intended to be triggered.
Table 5: Behavior Type and Available APIs
Type
API
Callback
Watchpoints
Simple
Put/get
No
Yes
Simple-Debug
Put/get_debug
No
No
Trigger-Callbacks
Put/get_with_triggering_callbacks
Regular
Yes
Trigger-Debug-Callba
cks
Put/get_with_triggering_debug_callbacks
Debug
No
For each variant, there are also different signatures available.
Table 6: Different Signatures of Each Variant
Style
Arguments
TLM2
address, dataPtr, data_length, byte_enablePtr, enableLength
TLM2-Word
address, dataPtr, data_length
Word
index, DT
SubWord
index, DT, size, offset
In total, this gives 2x16 different access methods that are supported by the memory objects,
summarized in the following table:
Table 7: Access Methods Supported by Memory Objects
Style
TLM2
TLM2-Word
Word
SubWord
Type
SystemC Modeling Library Reference Manual
X-2025.06-SP1
26</p>
</section>
<section id="page-27">
<h2>Page 27<a class="headerlink" href="#page-27" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Table 7: Access Methods Supported by Memory Objects (Continued)
Style
TLM2
TLM2-Word
Word
SubWord
Simple
x
x
x
x
Simple-Debug
x
x
x
x
Trigger-Callbacks
x
x
x
x
Trigger-Debug-Callbacks
x
x
x
x
2.2.5. Callbacks
The SCML memory objects provide with callbacks to model the behaviors that are associated with an
access to the elements in the memory map of a component. Callbacks are methods in the component
class that are registered with a memory object and that is executed whenever there is an incoming
transaction to the address range of that memory object. Callbacks can also be triggered using a Trigger-
Callbacks or Trigger-Debug-Callbacks type of access to the memory object (see Behavior).
Callback Properties
In the memory map of a model, there can be multiple memory objects that cover the address range
accessed by a transaction (for example, the top-level memory as well as a register). In such a case,
SystemC Modeling Library does the following:</p>
<ol class="arabic simple">
<li><p>To execute all behaviors that should be triggered by the transaction, the transaction is “unrolled”
to fit with the address range of the memory object with a callback: a burst access is unrolled into
accessed to the individual registers in the range, and an access to a register is split into accesses to
the bitfields it contains (provided at least one of them has a callback).</p></li>
<li><p>Only the callback of the “most refined” memory object is called. That is the callback for the memory
object that sits deepest in the object hierarchy (and that has a callback registered). This rule does
not apply to bitfields, this means that when a register as well as one of its bitfields have a callback,
then the register callback is executed. It is up to the user to trigger the execution of the bitfield
callbacks from the register callback (see Operators).
Following are the additional properties of callbacks:
•
Callbacks can be registered either for debug or regular accesses and can be specialized for read or
write accesses.
•
The functions implementing a callback is called as part of the TLM2 LT transport interface
implementation. This means that calling wait()  is allowed in a regular callback.
•
In a callback, the address passed in the payload argument is adjusted so that it is relative to the start
of the memory object to which the callback is registered.
•
Registering a callback (regular callback or a debug callback) to a memory object disables DMI
access to this memory object.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
27</p></li>
</ol>
</section>
<section id="page-28">
<h2>Page 28<a class="headerlink" href="#page-28" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
It is possible to extend SCML with additional callback mechanisms (see Callback Base Classes).
Registering Callbacks
Several convenience functions are defined to register predefined callbacks to a memory object.
These functions are defined in the scml2/memory_callback_functions.h  and scml2/
memory_debug_callback_functions.h  files, respectively.
The following functions are available to register a member method as a callback to a memory object:
Regular callback registration
set_callback(mem, SCML2_CALLBACK(method), syncType, tag)
set_read_callback(mem, SCML2_CALLBACK(method), syncType, tag)
set_read_no_store_callback(mem, SCML2_CALLBACK(method), syncType, tag)
set_write_callback(mem, SCML2_CALLBACK(method), syncType, tag)
set_word_read_callback(mem, SCML2_CALLBACK(method), syncType, tag)
set_word_write_callback(mem, SCML2_CALLBACK(method), syncType, tag)
set_post_write_callback(mem, SCML2_CALLBACK(method), syncType, tag);
Note:
set_read_callback  stores the value returned to the initiator in the memory,
set_read_no_store_callback  does not store the return value. If a callback already calculates and
stores the next value for the register, you need to use set_read_no_store  variant, to prevent the
new value from being overwritten when the call returns.
The following functions are available to register a member method as a debug callback to a memory
object:
Debug callback registration
set_debug_callback(mem, SCML2_CALLBACK(method), tag)
set_debug_read_callback(mem, SCML2_CALLBACK(method), tag)
set_debug_write_callback(mem, SCML2_CALLBACK(method), tag)
Where the arguments represent the following:
mem
Is the memory object to which the callback is registered.
SCML2_CALLBACK  (method)
Is macro that helps pass the callback into the registration function.
method  is the name of the callback method, which should be a
member of the model class of the memory object. The supported
signatures of the callback method are explained in the sections of the
relevant memory objects.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
28</p>
</section>
<section id="page-29">
<h2>Page 29<a class="headerlink" href="#page-29" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
syncType
Can be one of the following:
• NEVER_SYNCING  indicates that the callback is nonblocking and must
never call wait().
• SELF_SYNCING  indicates that the callback is blocking and may call
wait(). The timing annotation is passed unmodified to the callback.
• AUTO_SYNCING  indicates that the callback is blocking and may call
wait(). The memory object synchronizes before and after calling
the callback. The timing annotation passed to the callback is always
SC_ZERO_TIME.
These types are defined in the scml2/types.h  file.
The Post predefined behavior callbacks do not support
SELF_SYNCING  callbacks (since the callback does not have a time
argument)
tag
Is an optional argument. When provided it is a user-provided integer
that is passed to the callback. For example, so that the same callback
can be attached to all registers in a register array.
Removing Callbacks
Callbacks can be removed at runtime. This is usually not needed, but to improve simulation
performance it is a good idea to disable the callbacks for memory objects that are very often accessed
(for example, in a polling loop) but where the behavior that is modeled in the callback is rarely needed.
In such a case, a performance improvement is to remove the callback and register it again when the
external event that the polling loop is checking for has happened.
The following API’s are available to unregister callbacks from a memory object:
Unregistering Regular Callbacks
void remove_callback()
void remove_read_callback()
void remove_write_callback()
Unregistering Debug Callbacks
void remove_debug_callback()
void remove_debug_read_callback()
void remove_debug_write_callback()
Callback Methods
Every callback registration function accepts a few signatures for the callback methods. For a detailed
list of the callback signatures, see sections: Callbacks, Callbacks, Callbacks, Callbacks, and Callbacks.
2.2.6. Access Restrictions
Access restrictions are a special type of callbacks. They are intended to control whether transactions
can access memory objects or parts of them. Typically, access to certain registers or bitfields in a
memory map might be controlled by other registers or bitfields to prevent that the component is pushed
into an illegal state through some external input.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
29</p>
</section>
<section id="page-30">
<h2>Page 30<a class="headerlink" href="#page-30" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Such behavior could be modeled using regular callbacks, but it can be tedious due to the “most refined”
rule that applies to regular callbacks. Often the restriction applies for all bitfields in a register, forcing
you to add the access check to all bitfield callbacks, or to replace the bitfield callbacks with a register
callback.
Properties of Access Restrictions
Access restrictions have the following properties:</p>
<ol class="arabic simple">
<li><p>Access restriction callbacks are executed for an incoming transaction before any of the behavior
(regular) callbacks are executed.</p></li>
<li><p>Access restrictions are executed for all memory objects in the memory map that have an address
range that overlaps with the address range of the transaction.</p></li>
<li><p>To execute all registered access restrictions, the transaction is “unrolled” to fit with the address
range of the memory object with an access restriction: a burst access is unrolled into accessed to
the individual registers in the range, and an access to a register is split into accesses to the bitfields
it contains (provided at least one of them has an access restriction).</p></li>
<li><p>An access restriction determines which part of an access is restricted allowed by manipulating
the byte_enable  argument in the TLM2 Generic Payload. The byte enable uses 0xFF  per byte,
for access restrictions the limitation that only value 0x0  and 0xFF  are allowed is lifted and the
byte_enable  value is used as a bit enable.</p></li>
<li><p>Access restrictions are cumulative: All access restrictions on the path to a certain memory object are
executed. Each of them can further modify the byte_enable  argument of the transaction.</p></li>
<li><p>When access is disabled for all bits of a memory object, the corresponding behavior callback is not
executed (this includes the default behavior of a memory object).</p></li>
<li><p>The restrict callback should take care of the data in the payload and the storage to ensure that any
callback that might be executed works with the expected value. For example, in case a bitfield has
an access restriction, but there is also a callback on the parent register, the access restriction may
want to modify the transaction data so that the register callback gets the current value of the bitfield
rather than what is specified in the original transaction payload.</p></li>
<li><p>The return value of an access restriction is used to update the transaction response field. The return
type of a restrict callback is scml2::access_restriction_result. Possible values are:
scml2::RESTRICT_NO_ERROR
No change in transaction response, it is up to the callbacks to
finalize the value (both restrict callbacks as well as behavior
callbacks).
scml2::RESTRICT_ERROR
The transaction response is modified to
TLM_GENERIC_ERROR_RESPONSE  and the transaction is immediately
abandoned. No further restrictions are checked and no behavior
callbacks are executed.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
30</p></li>
</ol>
</section>
<section id="page-31">
<h2>Page 31<a class="headerlink" href="#page-31" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Registering a Restriction
Several convenience functions are defined to register access restrictions to a memory object. These
functions are defined in the scml2/memory_restriction_functions_include.h  and scml2/
bitfield_restriction_functions_include.h  file, respectively.
The following functions are available to register a member method as an access restriction for a
memory object:
Access restriction registration
set_restriction(mem, SCML2_CALLBACK(method), tag)
set_read_restriction(mem, SCML2_CALLBACK(method), tag)
set_write_restriction(mem, SCML2_CALLBACK(method), tag)
Where the arguments represent the following:
mem
Is the memory object to which the callback is registered.
SCML2_CALLBACK(method)
Is the macro that helps pass the callback into the registration function.
method  is the name of the callback method, which should be a member
of the model class of the memory object. The supported signatures of the
callback method are explained in section Access Restriction Methods.
tag
Is an optional argument. When provided, it is a user-provided integer that
is passed to the callback. For example, so that the same callback can be
attached to all registers in a register array.
This is similar to the registration of a regular behavior callback with the exception that restrictions do not
have a syncType  as they are not allowed to influence the timing of the transaction.
Removing an Access Restriction
Access restrictions can be removed with the following API’s:
API’s to remove access restrictions
scml2::remove_ restriction();
scml2::remove_read_restriction();
scml2::remove_write_restriction();
Access Restriction Methods
There are two forms of access restriction methods supported:
•
A simple one available for registers, and bitfields, and
•
a TLM2-based restriction method available for all memory objects.
The signature for these variants is as follows:
scml2::access_restriction_result MyRestrictFtion(DT&amp; data, DT&amp; bit_enables, inttag)
scml2::access_restriction_result MyRestrictFtion(tlm::tlm_generic_payload&amp; trans,
inttag)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
31</p>
</section>
<section id="page-32">
<h2>Page 32<a class="headerlink" href="#page-32" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
With the following arguments:
Table 8: Access Restriction Methods - Arguments
Argument
Description
DT&amp; data
Specifies the data argument, which is used to represent the data
from the payload from the parts of the access that are not restricted,
that is, the parts of the transaction that should be processed in
the behavior callbacks. The data that should be assumed by the
callbacks for the parts of the access that are restricted. This is the
data that is already processed by the restriction.
DT&amp; bit_enables
Indicates which parts of the data vector are restricted (corresponding
bits set to zero). This influences whether callbacks are executed.
Callbacks are not executed if all bit_enables  are zero for the object
the callback is associated with.
Int  tag
Is an optional argument. A tag can be set when registering a callback,
that same tag value is passed to the access restriction each time it is
called.
tlm::tlm_generic_paylo
ad&amp; trans
Is the TLM transaction payload with updated byte_enables  and
address value (address is always relative to the base-address of
the memory object), also streamin_width  is already handled and
converted into byte_enables. This variant gives access to all other
payload attributes to decide on the restriction. It can be used to check
for extensions or to deal with burst accesses.
scml2::access_restrictio
n_result
The return value should be either scml2::RESTRICT_NO_ERROR
or scml2::RESTRICT_ERROR. In the latter case, the transaction is
immediately abandoned and a TLM_GENERIC_ERROR_RESPONSE  is
returned.
Predefined Access Restrictions
For a number of frequent access restriction types, a predefined SCML2 API is provided to set a
restriction on a memory object:
Predefined Access Restrictions
scml2::set_ignore_restriction(mem, DT value = 0);
scml2::set_error_restriction(mem);
scml2::set_word_restriction(mem);
scml2::set_read_ignore_restriction(mem, DT value = 0);
scml2::set_read_error_restriction(mem);
scml2::set_read_word_restriction(mem);
scml2::set_write_ignore_restriction(mem, DT value = 0);
scml2::set_write_error_restriction(mem);
scml2::set_write_word_restriction(mem);
scml2::set_read_unmapped_error_restriction(mem)
scml2::set_write_unmapped_error_restriction(mem)
scml2::set_unmapped_error_restriction(mem)
scml2::set_read_unmapped_ignore_restriction(mem)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
32</p>
</section>
<section id="page-33">
<h2>Page 33<a class="headerlink" href="#page-33" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
scml2::set_write_unmapped_ignore_restriction(mem)
scml2::set_unmapped_ignore_restriction(mem)
scml2::set_byte_error_restriction(mem)
scml2::set_short_error_restriction(mem)
scml2::set_int_error_restriction(mem)
scml2::set_byte_ignore_restriction(mem, DT value = 0)
scml2::set_short_ignore_restriction(mem, DT value = 0)
scml2::set_int_ignore_restriction(mem, DT value = 0)
scml2::set_read_byte_error_restriction(mem)
scml2::set_read_short_error_restriction(mem)
scml2::set_read_int_error_restriction(mem)
scml2::set_read_byte_ignore_restriction(mem, DT value = 0)
scml2::set_read_short_ignore_restriction(mem, DT value = 0)
scml2::set_read_int_ignore_restriction(mem, DT value = 0)
scml2::set_write_byte_error_restriction(mem)
scml2::set_write_short_error_restriction(mem)
scml2::set_write_int_error_restriction(mem)
scml2::set_write_byte_ignore_restriction(mem, DT value = 0)
scml2::set_write_short_ignore_restriction(mem, DT value = 0)
scml2::set_write_int_ignore_restriction(mem, DT value = 0)
These API’s have the following properties:
•
The predefined access restrictions can be set for all accesses, or only for read or write accesses.
•
The predefined access restrictions can be set on any memory object (except the word-access
limitation that cannot be set on a bitfield).
•
The error restriction is set the transaction response to TLM_GENERIC_ERROR_RESPONSE .
•
The value argument for the scml2::set_read_ignore_restriction  is stored in the data pointer of
the transaction payload.
•
The value argument for the scml2::set_write_ignore_restriction  should be set to the value of
the memory object for which the restriction is set, to make sure that any callback on a memory object
higher up in the memory map hierarchy does not overwrite that memory object.
◦
So typically, scml2::set_write_ignore_restriction(mem,  (DT)mem) ;
◦
Other values are possible, for example, passing 0  as value implements a set_0_on_write  while
still allowing for other behavior callbacks to be executed.
•
A word access restriction allows any transaction that is,
◦
Word aligned
◦
Data-length is a multiple of word-size
◦
All byte_enables  are set
This means that an aligned 128-bit access in a 64-bit memory object is allowed. Multiple register
callbacks could be triggered, but all can assume the access is for the full word.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
33</p>
</section>
<section id="page-34">
<h2>Page 34<a class="headerlink" href="#page-34" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Access Restrictions Implementation Helper Functions
To facilitate the implementation of an access restriction, a number of helper functions are available that
represent typical functionality in a restrict callback:
Access restriction helper functions:
scml2::restrict_all(DT&amp; data, DT&amp; bit_enables, DT&amp; restrict_value = 0);
scml2::restrict_all<DT>(tlm::tlm_generic_payload&amp; trans,
DT restrict_value = 0);
scml2::restrict_all_and_store(DT&amp; data, DT&amp; bit_enables, DT&amp; restrict_value,
MEM_OBJECT<DT>&amp; mem_obj);
scml2::restrict_some(DT&amp; data, DT&amp; bit_enables, DT&amp; restrict_value,
DT in_data_mask);
scml2::restrict_some_and_store(DT&amp; data, DT&amp; bit_enables,
DT&amp; restrict_value, DT in_data_mask,
MEM_OBJECT<DT>&amp; mem_obj);
Properties of the helper functions:
•
restrict_all  is set bit_enables  to 0  and pass the restrict_value  as data (by default set to 0).
•
restrict_all_and_store  is set bit_enables  to 0 , pass the restrict_value  as data and store
the restrict value in the memory object.
•
restrict_some  can be used to partially restrict the access. The data_mask  should indicate the valid
bits in the data (bits set to 1  in the data_mask  is restricted, that is, bit_enables  is set to 0). The
restrict_value  is passed as data.
•
restrict_some_and_store  can be used to partially restrict the access. The data_mask  should
indicate the valid bits in the data (bits set to 1  in the data_mask  is restricted, that is, bit_enables  is
set to 0). The restrict_value  is passed as data and also is stored in the memory object.
•
All convenience functions return scml2::RESTRICT_NO_ERROR.
Access Restrictions Versus Behavior Callbacks
•
Restrictions
◦
All restrictions along the path of a transaction are checked: All elements in the memory hierarchy
to the leaf nodes that get accessed can add restrictions.
◦
Restrictions should manipulate bit_enables/byte_enables  to implement the restrictions.
◦
Are only allowed to further restrict (not to overwrite restrictions elsewhere in the path).
◦
Restrictions should manipulate payload data to ensure consistency independent of other
restrictions and behavior callbacks.
•
Behavior callbacks
◦
Only the ‘most specified’ behavior gets executed.
◦
Behaviors have full access/control over transaction payload.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
34</p>
</section>
<section id="page-35">
<h2>Page 35<a class="headerlink" href="#page-35" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
◦
No need to care about any other callbacks or restrictions that might get executed.
◦
Behavior callbacks is not executed when bit_enables/byte_enables  are all disabled for the
memory object.
◦
Word-style behavior callbacks does not check whether all byte-enables  are set if there is a
restriction somewhere on the path to the callback.
2.2.7. Vectors of Memory Objects
When managing vectors of memory objects, one can use the scml2::vector  class which is API-
compatible with sc_core::sc_vector, but has a different naming convention for the objects created in
the array.
The names are ‘<name>_0, <name>_1, …, <name>_n’. For sc_core::sc_vector, these names would be
‘<name>, <name>_1, …, <name>_n’.
Except for this difference, the two classes are intended to have identical behavior.
You can also use the scml2::vector  class for other modeling objects (such as ports) to instantiate
vectors of objects with the adapted naming convention.
2.3. memory
The scml2::memory  represents the top-level object for the local memory or register file description of
a model. The memory does the actual storage allocation and can be bound to a TLM2 target socket
using an adapter. It implements the mappable_if  interface which requires and object to implement the
TLM2 LT interfaces (b_transport, transport_dbg  and get_direct_mem_ptr). The mappable_if  is
provided in SCML2 as a link between the storage objects and the TLM2 socket interfaces. For details,
see mappable_if. A memory can have aliases and/or registers to specify the detailed memory hierarchy
of the component.
The include file of the memory objects is scml2/memory.h.
It has the following properties:
•
name  and size, as provided with the constructor of the object. The name of the memory is used by
the debug and analysis tools to refer to this object.
•
width: representing the datawidth that is stored in the memory. This is derived from the datatype
template argument for the class.
•
The scml2::memory  also has a default read and write latency which is used in the implementation of
the default behavior. Any b_transport  read or write call gets the latency implemented accordingly
through timing annotation. This value also is passed when the storage pointer is made available on a
DMI request from an initiator. It is the only object with this parameter.
•
The memory object also implements the index operation ([]) and has an initialize call to define an
initial value for the storage.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
35</p>
</section>
<section id="page-36">
<h2>Page 36<a class="headerlink" href="#page-36" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
2.3.1. Types
The memory class is templated with the underlying value type:
Template <typename DT> class memory
The following types are supported:
Table 9: Supported Data types
Supported Data types
Word size
unsigned char
8
unsigned short
16
unsigned int
32
unsigned long long
64
sc_dt::sc_biguint&lt;128&gt;
128
sc_dt::sc_biguint&lt;256&gt;
256
sc_dt::sc_biguint&lt;512&gt;
512
2.3.2. Constructors
The following constructor is available
memory(const std::string&amp; name, unsigned long long size);
This creates a new memory. The size argument must be specified in words.
2.3.3. Properties
The following methods are available to access the properties of a memory:
•
const std::string&amp; get_name() const
Returns the full hierarchical name of the memory object.
•
unsigned long long get_size() const
Returns the size of the memory object in words.
•
unsigned int get_width() const
Returns the width in bytes of the underlying data type of the memory object.
•
void set_default_read_latency(const sc_core::sc_time&amp; t)
const sc_core::sc_time&amp; get_default_read_latency() const
SystemC Modeling Library Reference Manual
X-2025.06-SP1
36</p>
</section>
<section id="page-37">
<h2>Page 37<a class="headerlink" href="#page-37" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
void set_default_write_latency(const sc_core::sc_time&amp; t)
const sc_core::sc_time&amp; get_default_write_latency() const
Sets/gets the latency returned in the tlm::tlm_dmi  structure of the get_direct_mem_ptr()
call. If no callback is attached, this latency is also added to the timing annotation argument of the
b_transport()  call.
•
bool is_dmi_enabled()
Returns true  if DMI accesses are allowed for the object, false  otherwise. DMI is enabled by
default.
•
void enable_dmi()
void disable_dmi()
Enables/disables DMI accesses for the object.
•
const std::string&amp; get_description() const
void set_description(const std::string&amp;)
Gets/sets the description for the memory object. This description can be displayed in debuggers.
•
bool has_default_read_behavior() const;
bool has_default_write_behavior() const;
bool has_default_debug_read_behavior() const;
bool has_default_debug_write_behavior() const;
bool has_never_syncing_read_behavior() const;
bool has_never_syncing_write_behavior() const;
bool is_dmi_allowed() const;
bool is_dmi_read_allowed() const;
bool is_dmi_write_allowed() const;
These are a set of API’s to query what type of behavior is associated with the memory and whether
DMI is enabled.
•
bool has_default_restriction() const;
bool has_default_read_restriction() const;
bool has_default_write_restriction() const;
These API’s query whether there is a restriction set for the memory.
The memory object can be bound to a TLM2 target socket using a port_adapter. For details, see Port
Adaptors. A target port adaptor may be bound to a SCML2 memory, as shown in the following code.
// bind adaptor to memory scml2::memory my_memory(“my_memory”, 0x100);
(*my_port_adapter)(my_memory);
2.3.4. Behaviors
This section describes
SystemC Modeling Library Reference Manual
X-2025.06-SP1
37</p>
</section>
<section id="page-38">
<h2>Page 38<a class="headerlink" href="#page-38" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Initialization
The initialize()  method can be used to put the specified initial value in the whole memory array:
void initialize (const DT&amp; value = DT())
In case no argument is given, the value returned by the default constructor for the underlying data type
is used.
Transport Calls
The following transport methods are available on the memory  objects:
The memory  object implements the following TLM2 methods:
void b_transport(tlm::tlm_generic_payload&amp; trans, sc_core::sc_time&amp; t)
unsigned int transport_dbg(tlm::tlm_generic_payload&amp; trans)
bool get_direct_mem_ptr(tlm::tlm_generic_payload&amp; trans,
tlm::tlm_dmi&amp; dmiData)
These methods trigger the callbacks registered to the memory object hierarchy represented by the
memory.
The memory  object also implements the following TLM2-like methods:
void transport_without_triggering_callbacks(tlm::tlm_generic_payload&amp; trans)
void transport_debug_without_triggering_callbacks(
tlm::tlm_generic_payload&amp; trans)
These transport methods do not trigger any callbacks. They access the current content of the memory
object. The debug methods also do not trigger any watchpoints on the memory  object.
Put/Get Access
The memory  object supports the different put/get behaviors as described in Behavior. The following set
of access functions is supported according to the different types and styles as defined in Behavior:
Table 10: Pit/Get Access
Type
API
Callb
ack
Watchpoi
nts
Simple
Put/get
No
Yes
Simple-Debug
Put/get_debug
No
No
Trigger-Callbacks
Put/get_with_triggering_callbacks
Regular Yes
Trigger-Debug-Callba
cks
Put/get_with_triggering_debug_callbacks
Debug
No
SystemC Modeling Library Reference Manual
X-2025.06-SP1
38</p>
</section>
<section id="page-39">
<h2>Page 39<a class="headerlink" href="#page-39" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
For each variant, there are also different signatures available:
Table 11: Different Signatures of Each Variant
Style
Arguments
TLM2
address, dataPtr, data_length, byte_enablePtr, enableLength
TLM2-Word
address, dataPtr, data_length
Word
index, DT
SubWord
index, DT, size, offset
The following table describes the arguments mentioned in the Table 11.
Table 12: Argument Descriptions
Argument name
C++
Description
address
unsigned long long address Byte address as in TLM2 GP.
dataPtr
(const) unsigned char*
data
Data array as in TLM2 GP.
data_length
unsigned int dataLength
The length of the transaction in bytes as in
TLM2 GP.
byte_enablePtr
const unsigned char*
byteEneblePtr
Specifies a byte enable array which can be 0
as in TLM2 GP.
enableLength
unsigned int
byteEnableLength
Length of the byte enable array in bytes as
in TLM2 GP.
index
unsigned long long index
The word index as specified by the DT
template of the memory object.
DT
(const) DT&amp; data
Is the data.
size
unsigned int size
Is the size of the access in bytes.
offset
unsigned int offset
Is the offset for the access in bytes.
Additional notes:
•
The Trigger- Callback access functions take an additional sc_time  argument. They return the TLM2
response status, returned by the triggered callback.
•
The get()  and get_debug()  methods for word or subword accesses return the read data instead of
passing it as an argument.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
39</p>
</section>
<section id="page-40">
<h2>Page 40<a class="headerlink" href="#page-40" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
•
The put_debug_with_triggering_callbacks()  and
get_debug_with_triggering_callbacks()  calls must not use byte_enables  (the
byteEnablePtr  must be 0) since TLM2 does not support byte enables for debug calls.
•
The debug versions of these methods do not trigger watchpoints.
In total, this gives 2x16 different access methods that are supported by the memory objects,
summarized in the following table:
Table 13: Memory Objects
Style
TLM2
TLM2-Word
Word
SubWord
Type
Simple
x
x
x
x
Simple-Debug
x
x
x
x
Trigger-Callbacks
x
x
x
x
Trigger-Debug-Callbacks
x
x
x
x
For a complete list with all arguments, see the include file of the memory: scml2/memory.h.
Operators
The following assignment operators are available:
reference operator[](unsigned long longindex)
DT operator[](unsigned long longindex) const
The lvalue  version of the index  operator returns a memory_index_reference object that
forwards all operations to the referenced memory object. The const  version returns the current
value.
iterator begin()
const_iterator begin() const
Returns a random access iterator pointing to the first element in the memory  object.
iterator end()
const_iterator end() const
Returns a random access iterator pointing to the end of the memory  object.
2.3.5. Callbacks
The memory object supports the callbacks listed in this manual. For more information on callbacks, see
also Callbacks.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
40</p>
</section>
<section id="page-41">
<h2>Page 41<a class="headerlink" href="#page-41" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Regular Callbacks
The memory object only supports the set_callback  registration-style callback methods.
Regular callback registration
set_callback(mem, SCML2_CALLBACK(method), syncType, tag)
set_read_callback(mem, SCML2_CALLBACK(method), syncType, tag)
set_read_no_store_callback(mem, SCML2_CALLBACK(method), syncType, tag)
set_write_callback(mem, SCML2_CALLBACK(method), syncType, tag)
It accepts callback methods with the following signatures:
void transportCallback(tlm::tlm_generic_payload&amp;, sc_core::sc_time&amp;, int tag)
void transportCallback(tlm::tlm_generic_payload&amp;, int tag)
Additional notes:
•
In all the preceding callback methods, tag  is an optional argument, only to be used when the
callback is registered with a tag.
•
The untimed callback (without the sc_time  parameter) cannot be SELF_SYNCING  callbacks.
Debug Callbacks
The memory object support the following registration API’s for debug callbacks:
Debug callback registration
set_debug_callback(mem, SCML2_CALLBACK(method), tag)
set_debug_read_callback(mem, SCML2_CALLBACK(method), tag)
set_debug_write_callback(mem, SCML2_CALLBACK(method), tag)
For debug callbacks, method must have one of the following signatures:
unsigned int transportCallback(tlm::tlm_generic_payload&amp;)
unsigned int transportCallback(tlm::tlm_generic_payload&amp;, int tag)
The return value is the number of consecutive bytes successfully read or written. If the access cannot
be executed, 0  must be returned.
2.3.6. Access Restrictions
The memory object supports access restrictions as described in Access Restrictions. The memory
supports all predefined access restrictions as specified in Predefined Access Restrictions, but it only
supports TLM2-style access restriction callbacks:
scml2::access_restriction_result MyRestrictFtion(tlm::tlm_generic_payload&amp; trans,
int tag)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
41</p>
</section>
<section id="page-42">
<h2>Page 42<a class="headerlink" href="#page-42" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
2.4. memory_alias
The scml2::memory_alias  object specifies a subregion of a scml2::memory. A memory_alias  cannot
exist on its own, it always needs a scml2::memory  parent object. The alias does not come with its own
storage and can have further aliases and/or registers. The alias cannot be bound to a TLM2 target
socket (or the adapters) as it does not implement the mappable_if. The use of a memory_alias  is to
provide with a different name for a subregion to make sure the model reflects the design specification
of the component, but also serves as a hook so that specialized behavior can be associated with part
of the memory or register map of the component. The properties of an memory_alias  are similar to the
memory and provided using the memory_base  base class.
The include file of the memory_alias  objects is scml2/memory_alias.h.
It has the following properties:
•
The scml2::memory_alias  takes a name, parent memory, offset and size in the constructor. Offset
indicates the start index for this alias within the range of the parent memory (or memory_alias).
•
It has access functions for name, size, offset, parent and width. Exactly like these also exist for the
scml2::memory.
•
It also supports the index operator []  and the initialize call as exist for the memory.
•
Callbacks that are associated with a memory_alias  overrides the behavior of the parent memory.
Both the default behavior and the behavior that gets registered using the callback mechanism are
overruled this way.
2.4.1. Types
The memory_alias  class is templated with the underlying value type:
Template <typename DT> class memory_alias
The following types are supported:
Table 14: Supported Types
Supported Datatype
Word size
unsigned char
8
unsigned short
16
unsigned int
32
unsigned long long
64
sc_dt::sc_biguint&lt;128&gt;
128
sc_dt::sc_biguint&lt;256&gt;
256
SystemC Modeling Library Reference Manual
X-2025.06-SP1
42</p>
</section>
<section id="page-43">
<h2>Page 43<a class="headerlink" href="#page-43" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Table 14: Supported Types (Continued)
Supported Datatype
Word size
sc_dt::sc_biguint&lt;512&gt;
512
The memory alias should have a datatype where the word size is a multiple of that of its parent memory.
2.4.2. Constructors
The following constructors are available:
memory_alias(const std::string&amp;name,
memory<DT>&amp; parent,
unsigned long long offset,
unsigned long long size)
memory_alias(const std::string&amp; name,
memory_alias<DT>&amp; parent,
unsigned long long offset,
unsigned long long size)
Create a new memory_alias  object. The sizeand offset  argument must be specified in
words.
2.4.3. Properties
The following methods are available to access the properties of a memory_alias:
•
const std::string&amp; get_name() const
Returns the full hierarchical name of the of the memory_alias  object.
•
unsigned long long get_offset() const
Returns the offset in words relative to the top-level memory object.
•
unsigned long long get_size() const
Returns the size of the memory_alias  object in words.
•
unsigned int get_width() const
Returns the width in bytes of the underlying data type of the memory_alias  object.
•
memory_base* get_parent() const
Returns a pointer to the parent memory or memory_alias  object.
•
bool is_dmi_enabled()
Returns true  if DMI accesses are allowed for the object, false  otherwise. DMI is enabled by
default.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
43</p>
</section>
<section id="page-44">
<h2>Page 44<a class="headerlink" href="#page-44" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
•
void enable_dmi()
void disable_dmi()
Enables/disables DMI accesses for the object.
•
const std::string&amp; get_description() const void set_description(const
std::string&amp;)
Gets/sets the description for the memory_alias  object. This description can be displayed in
debuggers.
•
bool has_default_read_behavior() const;
bool has_default_write_behavior() const;
bool has_default_debug_read_behavior() const;
bool has_default_debug_write_behavior() const;
bool has_never_syncing_read_behavior() const;
bool has_never_syncing_write_behavior() const;
bool is_dmi_allowed() const;
bool is_dmi_read_allowed() const;
bool is_dmi_write_allowed() const;
These are a set of API’s to query what type of behavior is associated with the memory_alias  and
whether DMI is enabled.
•
bool has_default_restriction() const;
bool has_default_read_restriction() const;
bool has_default_write_restriction() const;
These API’s query whether there is a restriction set for the memory_alias.
2.4.4. Behaviors
Initialization
The initialize()  method can be used to put the specified initial value in the whole memory array:
void initialize (const DT&amp; value = DT())
In case no argument is given, the value returned by the default constructor for the underlying data type
is used.
Transport Calls
The following transport methods are available on the memory objects:
The memory_alias  object implements the following TLM2 methods:
void b_transport(tlm::tlm_generic_payload&amp; trans, sc_core::sc_time&amp; t) unsigned int
transport_dbg(tlm::tlm_generic_payload&amp; trans)
These methods trigger the callbacks registered to the memory_alias  object hierarchy represented by
the memory.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
44</p>
</section>
<section id="page-45">
<h2>Page 45<a class="headerlink" href="#page-45" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
The memory_alias  object also implements the following TLM2-like methods:
void transport_without_triggering_callbacks(tlm::tlm_generic_payload&amp; trans)
void transport_debug_without_triggering_callbacks(
tlm::tlm_generic_payload&amp; trans)
These transport methods do not trigger any callbacks. They access the current content of the
memory_alias  object. The debug methods also do not trigger any watchpoints on the memory_alias
object.
Put/Get Access
The memory_alias  object supports the different put/get behaviors as described in Behavior. The
following set of access functions is supported according to the different types and styles as defined in
Behavior:
Table 15: Supported Access Functions
Type
API
Callb
ack
Watchpoi
nts
Simple
Put/get
No
Yes
Simple-Debug
Put/get_debug
No
No
Trigger-Callbacks
Put/get_with_triggering_callbacks
Regular Yes
Trigger-Debug-Callba
cks
Put/get_with_triggering_debug_callbacks
Debug
No
For each variant, there are also different signatures available:
Table 16: Different Signatures of Each Variant
Style
Arguments
TLM2
address, dataPtr, data_length, byte_enablePtr, enableLength
TLM2-Word
address, dataPtr, data_length
Word
index, DT
SubWord
index, DT, size, offset
The following table describes the arguments mentioned in the Table 16.
Table 17: Argument Descriptions
Argument name C++
Description
address
unsigned long long address
Byte address as in TLM2 GP.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
45</p>
</section>
<section id="page-46">
<h2>Page 46<a class="headerlink" href="#page-46" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Table 17: Argument Descriptions (Continued)
Argument name C++
Description
dataPtr
(const) unsigned char* data
Data array as in TLM2 GP.
data_length
unsigned int dataLength
The length of the transaction in bytes as
in TLM2 GP.
byte_enablePtr const unsigned char*
byteEneblePtr
Specifies a byte enable array which can
be 0  as in TLM2 GP.
enableLength
unsigned int byteEnableLength
Length of the byte enable array in bytes
as in TLM2 GP.
index
unsigned long long index
The word index as specified by the DT
template of the memory object.
DT
(const) DT&amp; data
Is the data.
size
unsigned int size
Is the size of the access in bytes.
offset
unsigned int offset
Is the offset for the access in bytes.
Additional notes:
•
The Trigger-Callback access functions take an additional sc_time  argument. They return the TLM2
response status, returned by the triggered callback.
•
The get()  and get_debug()  methods for word or subword accesses return the read data instead of
passing it as an argument.
•
The put_debug_with_triggering_callbacks()  and
get_debug_with_triggering_callbacks()  calls must not use byte_enables  (the
byteEnablePtr  must be 0) since TLM2 does not support byte enables for debug calls.
•
The debug versions of these methods do not trigger watchpoints.
Table 18: Supported Access Methods
Style
TLM2
TLM2-Word
Word
SubWord
Type
Simple
x
x
x
x
Simple-Debug
x
x
x
x
Trigger-Callbacks
x
x
x
x
Trigger-Debug-Callbacks
x
x
x
x
SystemC Modeling Library Reference Manual
X-2025.06-SP1
46</p>
</section>
<section id="page-47">
<h2>Page 47<a class="headerlink" href="#page-47" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
In total, this gives 2x16 different access methods that are supported by the memory objects,
summarized in the following table:
For a complete list with all arguments check the include file of the memory_alias: scml2/
memory_alias.h.
Operators
The following assignment operators are available:
reference operator[](unsigned long longindex)
DT operator[](unsigned long longindex) const
The lvalue  version of the index  operator returns a memory_index_reference object that
forwards all operations to the referenced memory object. The const  version returns the current
value.
iterator begin()
const_iterator begin() const
Returns a random access iterator pointing to the first element in the memory_alias  object.
iterator end()
const_iterator end() const
Returns a random access iterator pointing to the end of the memory_alias  object.
2.4.5. Callbacks
The memory_alias  object supports the callbacks listed in this manual. For more information on
callbacks, see also Callbacks.
Regular Callbacks
The memory_alias  object only supports the set_callback  registration-style callback methods.
Regular callback registration
set_callback(mem, SCML2_CALLBACK(method),syncType,tag)
set_read_callback(mem, SCML2_CALLBACK(method),syncType,tag)
set_read_no_store_callback(mem, SCML2_CALLBACK(method),syncType,tag)
set_write_callback(mem, SCML2_CALLBACK(method),syncType,tag)
It accepts callback methods with the following signatures:
void transportCallback(tlm::tlm_generic_payload&amp;, sc_core::sc_time&amp;, inttag)
void transportCallback(tlm::tlm_generic_payload&amp;, inttag)
Additional notes:
•
In all the preceding callback methods, tag  is an optional argument, only to be used when the
callback is registered with a tag.
•
The untimed callback (without the sc_time  parameter) cannot be SELF_SYNCING  callbacks.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
47</p>
</section>
<section id="page-48">
<h2>Page 48<a class="headerlink" href="#page-48" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Debug Callbacks
The memory_alias  object support the following registration API’s for debug callbacks.
Debug callback registration
set_debug_callback(mem, SCML2_CALLBACK(method),tag)
set_debug_read_callback(mem, SCML2_CALLBACK(method),tag)
set_debug_write_callback(mem, SCML2_CALLBACK(method),tag)
For debug callbacks, method  must have one of the following signatures:
unsigned int transportCallback(tlm::tlm_generic_payload&amp;)
unsigned int transportCallback(tlm::tlm_generic_payload&amp;, int tag)
The return value is the number of consecutive bytes successfully read or written. If the access cannot
be executed, 0  must be returned.
2.4.6. Access Restrictions
The memory_alias  object supports access restrictions as described in Access Restrictions. The
memory_alias  supports all predefined access restrictions as specified in Predefined Access
Restrictions, but it only supports TLM2-style access restriction callbacks:
scml2::access_restriction_result MyRestrictFtion(tlm::tlm_generic_payload&amp; trans,
int tag)
2.5. reg
The scml2::reg  is a memory_alias  of size 1. That is, it represents a subrange of the memory which is
the same size as the width of the memory or in other words represents one storage location of the same
size as the datatype template argument of the storage classes. As with the memory_alias, it does not
implement its own storage and must have a parent memory or memory alias and cannot be bound to
the TLM2 target sockets (or adapters). On top of that it cannot have any other aliases and or registers,
but it can have bitfields associated with itself. It is the leave node of the memory hierarchy. The register
object has all the same properties and access methods as the memory_alias  (name, parent, offset,
index operator, callback overruling). The key additional feature for the register is that it can be used as a
regular variable.
The include file of the reg objects is scml2/reg.h.
2.5.1. Types
The register class is templated with the underlying value type:
Template <typename DT> class reg
SystemC Modeling Library Reference Manual
X-2025.06-SP1
48</p>
</section>
<section id="page-49">
<h2>Page 49<a class="headerlink" href="#page-49" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
The following types are supported:
Table 19: Supported Datatypes
Supported Datatypes
Word Size
unsigned char
8
unsigned short
16
unsigned int
32
unsigned long long
64
sc_dt::sc_biguint&lt;128&gt;
128
sc_dt::sc_biguint&lt;256&gt;
256
sc_dt::sc_biguint&lt;512&gt;
512
The register should have a datatype where the word size is a multiple of that of its parent memory or
memory_alias.
2.5.2. Constructors
The following constructors are available:
reg(const std::string&amp; name,
memory<DT>&amp; parent,
unsigned long long offset)
reg(const std::string&amp; name,
memory_alias<DT>&amp; parent,
unsigned long long offset)
Create a new reg  object. The offset  argument must be specified in words.
2.5.3. Properties
The following methods are available to access the properties of a register:
•
const std::string&amp; get_name() const
Returns the full hierarchical name of the of the reg  object.
•
unsigned long long get_offset() const
Returns the offset in words relative to the top-level memory  object.
•
unsigned int get_width() const
Returns the width in bytes of the underlying data type of the reg  object.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
49</p>
</section>
<section id="page-50">
<h2>Page 50<a class="headerlink" href="#page-50" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
•
memory_base* get_parent() const
Returns a pointer to the parent memory  or memory_alias  object.
•
bool is_dmi_enabled()
Returns true  if DMI accesses are allowed for the object, false  otherwise. DMI is enabled by
default.
•
void enable_dmi()
void disable_dmi()
Enables/disables DMI accesses for the object.
•
const std::string&amp; get_description() const
void set_description(const std::string&amp;)
Gets/sets the description for the register  object. This description can be displayed in debuggers.
•
bool has_default_read_behavior() const;
bool has_default_write_behavior() const;
bool has_default_debug_read_behavior() const;
bool has_default_debug_write_behavior() const;
bool has_never_syncing_read_behavior() const;
bool has_never_syncing_write_behavior() const;
bool is_dmi_allowed() const;
bool is_dmi_read_allowed() const;
bool is_dmi_write_allowed() const;
These are a set of API’s to query what type of behavior is associated with the register and whether
DMI is enabled.
•
bool has_default_restriction() const;
bool has_default_read_restriction() const;
bool has_default_write_restriction() const;
These API’s query whether there is a restriction set for the register.
2.5.4. Behaviors
Initialization
The initialize()  method can be used to put the specified initial value in the whole memory array:
void initialize (const DT&amp; value = DT())
In case no argument is given, the value returned by the default constructor for the underlying data type
is used.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
50</p>
</section>
<section id="page-51">
<h2>Page 51<a class="headerlink" href="#page-51" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Transport Calls
The following transport methods are available on the memory objects:
The reg  object implements the following TLM2 methods:
void b_transport(tlm::tlm_generic_payload&amp; trans, sc_core::sc_time&amp; t) unsigned int
transport_dbg(tlm::tlm_generic_payload&amp; trans)
These methods trigger the callbacks registered to the reg  object hierarchy represented by the memory.
The reg  object also implements the following TLM2-like methods
void transport_without_triggering_callbacks(tlm::tlm_generic_payload&amp; trans)
void transport_debug_without_triggering_callbacks(
tlm::tlm_generic_payload&amp; trans)
These transport methods do not trigger any callbacks. They access the current content of the reg
object. The debug methods also do not trigger any watchpoints on the reg  object.
Put/Get Access
The reg  object supports the different put/get behaviors as described in section Behavior. Unlike the
memory  object, the put  and get  methods of the reg  object do not take an index argument (since this
should always be 0). The following set of access functions is supported according to the different types
and styles as defined in Behavior:
Table 20: Supported Access Functions
Type
API
Callback Watchpoi
nts
Simple
Put/get
No
Yes
Simple-Debug
Put/get_debug
No
No
Trigger-Callbacks
Put/get_with_triggering_callbacks
Regular
Yes
Trigger-Debug-Callba
cks
Put/get_with_triggering_debug_callbacks
Debug
No
For each variant, there are also different signatures available:
Table 21: Different Signatures of Each Variant
Style
Arguments
TLM2
address, dataPtr, data_length, byte_enablePtr, enableLength
TLM2-Word
address, dataPtr, data_length
Word
DT
SystemC Modeling Library Reference Manual
X-2025.06-SP1
51</p>
</section>
<section id="page-52">
<h2>Page 52<a class="headerlink" href="#page-52" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Table 21: Different Signatures of Each Variant (Continued)
Style
Arguments
SubWord
DT, size, offset
The following table describes the arguments mentioned in the Table 21.
Table 22: Argument Description
Argument
Name
C++
Description
address
unsigned long long address Is the byte address as in TLM2 GP.
dataPtr
(const) unsigned char*
data
Is the data array as in TLM2 GP.
data_length
unsigned int dataLength
Is the length of the transaction in bytes as in
TLM2 GP.
byte_enablePtr const unsigned char*
byteEneblePtr
Specifies a byte enable array which can be 0 as
in TLM2 GP.
enableLength
unsigned int
byteEnableLength
Specifies the length of the byte enable array in
bytes as in TLM2 GP.
DT
(const) DT&amp; data
Specifies the data.
size
unsigned int size
Is the size of the access in bytes.
offset
unsigned int offset
Is the offset for the access in bytes.
Additional notes:
•
The Trigger-Callback access functions take an additional sc_time  argument. They return the TLM2
response status, returned by the triggered callback.
•
The get()  and get_debug()  methods for word or subword accesses return the read data instead of
passing it as an argument.
•
The put_debug_with_triggering_callbacks()  and
get_debug_with_triggering_callbacks()  calls must not use byte_enables  (the
byteEnablePtr  must be 0) since TLM2 does not support byte enables for debug calls.
•
The debug versions of these methods do not trigger watchpoints.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
52</p>
</section>
<section id="page-53">
<h2>Page 53<a class="headerlink" href="#page-53" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
In total, this gives 2x16 different access methods that are supported by the memory objects,
summarized in the following table:
Table 23: Supported Access Methods
Style
TLM2
TLM2-Word
Word
SubWord
Type
Simple
x
x
x
x
Simple-Debug
x
x
x
x
Trigger-Callbacks
x
x
x
x
Trigger-Debug-Callbacks
x
x
x
x
For a complete list with all arguments, see the include file of the register: scml2/reg.h.
Triggering Callbacks on Bitfields
The register also has a set of API’s to trigger the callbacks on its bitfields. These API’s can be used for
example, from within a callback.
API’s to trigger bitfield behavior from register callbacks
bool put_with_triggering_bitfield_callbacks(const DT&amp; data, sc_core::sc_time&amp; t)
bool put_with_triggering_bitfield_callbacks(const DT&amp; data, const DT&amp; bitMask,
sc_core::sc_time&amp; t)
bool get_with_triggering_bitfield_callbacks(DT&amp; data, sc_core::sc_time&amp; t)
bool get_with_triggering_bitfield_callbacks(DT&amp; data, const DT&amp; bitMask,
sc_core::sc_time&amp; t)
bool put_debug_with_triggering_bitfield_callbacks(const DT&amp; data, const DT&amp; bitMask)
bool put_debug_with_triggering_bitfield_callbacks(const DT&amp; data)
bool get_debug_with_triggering_bitfield_callbacks(DT&amp; data)
bool get_debug_with_triggering_bitfield_callbacks(DT&amp; data, const DT&amp; bitMask)
Operators
The following assignment operators are available:
iterator begin()
const_iterator begin() const
Returns a random access iterator pointing to the reg  object.
iterator end()
const_iterator end() const
Returns a random access iterator pointing to the end of the reg  object.
A reg  object can be converted to the underlying data type:
operator DT() const
SystemC Modeling Library Reference Manual
X-2025.06-SP1
53</p>
</section>
<section id="page-54">
<h2>Page 54<a class="headerlink" href="#page-54" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
The following assignment operators are available:
reg&amp; operator=(DT value)
reg&amp; operator =(const reg&amp;r)
The following arithmetic assignment operators are available and behave as defined for the underlying
data type:
reg&amp; operator+=(DTvalue)
reg&amp; operator-=(DT value)
reg&amp; operator/=(DT value)
reg&amp; operator*=(DT value)
reg&amp; operator%=(DT value)
reg&amp; operator^=(DT value)
reg&amp; operator&amp;=(DT value)
reg&amp; operator|=(DT value)
reg&amp; operator&gt;&gt;=(DT value)
reg&amp; operator&lt;&lt;=(DT value)
The following prefix and postfix decrement and increment operators are available:
reg&amp; operator–()
DT operator–(int)
reg&amp; operator++()
DT operator++(int)
The register object has all the same properties and access methods as the memory_alias  (name,
parent, offset, index operator, callback overruling). The key additional feature for the register is that it
can be used as a regular variable.
operator DT() const;
reg&amp; operator=(DT value);
reg&amp; operator =(const reg&amp; r);
reg&amp; operator+=(DT value);
reg&amp; operator-=(DT value);
reg&amp; operator/=(DT value);
reg&amp; operator*=(DT value);
reg&amp; operator%=(DT value);
reg&amp; operator^=(DT value);
reg&amp; operator&amp;=(DT value);
reg&amp; operator|=(DT value);
reg&amp; operator&gt;&gt;=(DT value);
reg&amp; operator&lt;&lt;=(DT value);
reg&amp; operator–();
DT operator–(int);
reg&amp; operator++();
DT operator++(int);
2.5.5. Callbacks
The reg  object supports the callbacks listed in this manual. For more information on callbacks, see also
Callbacks.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
54</p>
</section>
<section id="page-55">
<h2>Page 55<a class="headerlink" href="#page-55" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Regular Callbacks
Every callback registration function accepts a few signatures for the callback methods:
Regular callback registration
set_read_no_store_callback(reg, SCML2_CALLBACK(method), syncType, tag)
set_callback(reg, SCML2_CALLBACK(method), syncType, tag)
set_read_callback(reg, SCML2_CALLBACK(method), syncType, tag)
set_write_callback(reg, SCML2_CALLBACK(method), syncType, tag)
set_word_read_callback(reg, SCML2_CALLBACK(method), syncType, tag)
set_word_write_callback(reg, SCML2_CALLBACK(method), syncType, tag)
set_post_write_callback(reg, SCML2_CALLBACK(method), syncType, tag);
The set_callback  registration function accepts callback methods with the following signatures:
void transportCallback(tlm::tlm_generic_payload&amp;, sc_core::sc_time&amp;, int tag)
void transportCallback(tlm::tlm_generic_payload&amp;, int tag)
The set_read_callback  and set_read_no_store_callback  registration functions accept callback
methods with the following signatures:
bool readCallback(DT&amp; data, const DT&amp; byteEnables, sc_core::sc_time&amp;, int tag)
bool readCallback(DT&amp; data, const DT&amp; byteEnables, int tag)
bool readCallback(DT&amp; data, const DT&amp; byteEnables, sc_core::sc_time&amp;,
const scml2::tlm2_gp_extensions&amp; extensions int tag)
bool readCallback(DT&amp; data, const DT&amp; byteEnables,
const scml2::tlm2_gp_extensions&amp; extensions int tag)
The set_write_callback  registration function accepts callback methods with the following signatures:
bool writeCallback(const DT&amp; data, const DT&amp; byteEnables, sc_core::sc_time&amp;,
int tag)
bool writeCallback(const DT&amp; data, const DT&amp; byteEnables, int tag)
bool writeCallback(const DT&amp; data, const DT&amp; byteEnables, sc_core::sc_time&amp;,
const scml2::tlm2_gp_extensions&amp; extensions int tag)
bool writeCallback(const DT&amp; data, const DT&amp; byteEnables,
const scml2::tlm2_gp_extensions&amp; extensions int tag)
The set_word_read_callback  registration function accepts callback methods with the following
signatures:
bool wordReadCallback(DT&amp; data, sc_core::sc_time&amp;, int tag)
bool wordReadCallback(DT&amp; data, int tag)
bool wordReadCallback(DT&amp; data, sc_core::sc_time&amp;,
const scml2::tlm2_gp_extensions&amp; extensions int tag)
bool wordReadCallback(DT&amp; data, const scml2::tlm2_gp_extensions&amp; extensions int tag)
The set_word_write_callback  registration function accepts callback methods with the following
signatures:
bool wordWriteCallback(const DT&amp; data, sc_core::sc_time&amp;, int tag)
bool wordWriteCallback(const DT&amp; data, int tag)
bool wordWriteCallback(const DT&amp; data, sc_core::sc_time&amp;,
const scml2::tlm2_gp_extensions&amp; extensions int tag)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
55</p>
</section>
<section id="page-56">
<h2>Page 56<a class="headerlink" href="#page-56" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
bool wordWriteCallback(const DT&amp; data,
const scml2::tlm2_gp_extensions&amp; extensions int tag)
The set_post_write_callback  registration function accepts callback methods with the following
signature:
void postWriteCallback(int tag)
Additional notes:
•
The bool  return value indicates whether the access was successful. The transport style callbacks
should use the TLM2 response status.
•
In all the preceding callback methods, tag  is an optional argument, only to be used when the
callback is registered with a tag.
•
Streaming burst accesses are unrolled into word accesses and subword accesses are converted
into word accesses with byte enables.
•
The byteEnables  mask contains 0xff  for enabled bytes and 0x0  for disabled bytes.
•
The wordReadCallback  and wordWriteCallback  types are for word accesses only. For unaligned
accesses or subword accesses, an error response is returned.
•
The untimed callbacks (without the sc_time  parameter) cannot be SELF_SYNCING  callbacks.
Debug Callbacks
The reg  object support the following registration API’s for debug callbacks.
Debug callback registration
set_debug_callback(reg, SCML2_CALLBACK(method), tag)
set_debug_read_callback(reg, SCML2_CALLBACK(method), tag)
set_debug_write_callback(reg, SCML2_CALLBACK(method), tag)
For debug callbacks, callback must have one of the following signatures:
unsigned int transportCallback(tlm::tlm_generic_payload&amp;)
unsigned int transportCallback(tlm::tlm_generic_payload&amp;, int tag)
The return value is the number of consecutive bytes successfully read or written. If the access cannot
be executed, 0  must be returned.
Predefined Callbacks
The following functions are available to register specific read and write behavior to a register.
set_clear_on_read(reg)
Clears all bits of the memory when the memory is read.
set_set_on_read(reg)
Sets all bits of the memory when the memory is read.
set_clear_on_write_0(reg)
Clears all bits to which the bit 0  is written.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
56</p>
</section>
<section id="page-57">
<h2>Page 57<a class="headerlink" href="#page-57" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
set_clear_on_write_1(reg)
Clears all bits to which the bit 1  is written.
set_write_once(reg)
Sets all bits to which the bit 0  is written.
set_set_on_write_0(reg)
Sets all bits to which the bit 0  is written.
set_set_on_write_1(reg)
Sets all bits to which the bit 1  is written.
set_write_once_error(reg)
Allows a value to be written to the memory at one time. All
subsequent writes returns an error. See the note text given below.
set_write_once_ignore(reg)
Allows a value to be written to the memory at one time. All
subsequent writes is ignored. See the note text given below.
The write_once  callback function variants return a reference counted object of type
scml2::write_once_state. This object can be used to reset the state, such that the memory becomes
writable again, by calling reset()  on it.
2.5.6. Access Restrictions
The register  object supports access restrictions as described in Access Restrictions. The register
supports all predefined access restrictions as specified in Predefined Access Restrictions, it supports
both styles of access restriction callbacks:
scml2::access_restriction_result MyRestrictFtion(DT&amp; data, DT&amp; bit_enables, int tag)
scml2::access_restriction_result MyRestrictFtion(tlm::tlm_generic_payload&amp; trans,
int tag)
2.6. bitfield
The bitfield  object is intended to access subword ranges in a register. It does not have its own
storage, and must have a register as parent object. Bitfields are slightly different from the other storage
objects, since they can be smaller than the 8-bit  minimal access size of a TLM2 transport access.
Like a register, they cannot have any other aliases or registers; or by bound to the TLM2 target
sockets. They also have a limited set of callbacks, only the read  and write  callbacks are allowed (no
transport  callbacks or callbacks with byte-enables and so on). Moreover, they have a limited list of
access methods - only the ones with datatype  as argument.
Other properties of bitfield  object are:
•
The bitfield can only be constructed with a register as parent. It has name, offset, and
sizeparameters.
•
It is possible to use it as a regular variable like a register, and all operators are overloaded.
•
When a callback is registered with a bitfield, this overrides the behavior of the parent register.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
57</p>
</section>
<section id="page-58">
<h2>Page 58<a class="headerlink" href="#page-58" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
•
When both the register as well as the bitfield have a callback registered, the register callback is
triggered. The rule of most refined behavior stops at the register. The register has additional APIs to
call the bitfield callbacks from within the register callback implementation.
•
bitfield  objects can be attached to reg  objects or other bitfield  objects, to alias some of the
bits in the parent object.
•
The include file of the bitfield  objects is scml2/bitfield.h.
2.6.1. Types
The bitfield class is templated with the underlying value type:
Template <typename DT> class bitfield
The following types are supported:
Table 24: Supported Datatypes
Supported Datatypes
Word Size
unsigned char
8
unsigned short
16
unsigned int
32
unsigned long long
64
sc_dt::sc_biguint&lt;128&gt;
128
sc_dt::sc_biguint&lt;256&gt;
256
sc_dt::sc_biguint&lt;512&gt;
512
When instantiating a bitfield  object, it should have the same template value as its parent register.
2.6.2. Constructors
The following constructors are available:
bitfield(const std::string&amp; name,
reg<DT>&amp; reg,
unsigned int offset,
unsigned int size)
bitfield(const std::string&amp; name,
bitfield<DT>&amp; b,
unsigned int offset,
unsigned int size)
Creates a new bitfield. The offset  and size  arguments must be specified in bits.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
58</p>
</section>
<section id="page-59">
<h2>Page 59<a class="headerlink" href="#page-59" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
2.6.3. Properties
The following methods are available to access the properties of a bitfield:
•
b
i
t
f
i
e
l
d
g
e
t
_
n
a
m
e
(
)</p>
<p>m
e
t
h
o
d
const std::string&amp; get_name() const
Returns the full hierarchical name of the bitfield  object.
•
b
i
t
f
i
e
l
d
g
e
t
_
o
f
f
s
e
t
(
)</p>
<p>m
e
t
h
o
d
unsigned long long get_offset() const
Returns the offset (in bits) of the bitfield  start bit in the register.
•
b
i
t
f
i
e
l
d
g
e
t
_
s
i
z
e
(
)</p>
<p>m
e
t
h
o
d
unsigned long long get_size() const
Returns the size of the bitfield  object in bits.
•
b
i
t
f
i
e
l
d
g
e
t
_
r
e
g
i
s
t
e
r
(
)</p>
<p>m
e
t
h
o
d
reg<DT>* get_register() const
Returns a pointer to the parent register object.
•
b
i
t
f
i
e
l
d
s
e
t
_
d
e
s
c
r
i
p
t
i
o
n</p>
<p>m
e
t
h
o
d</p>
<p>b
i
t
f
i
e
l
d
g
e
t
_
d
e
s
c
r
i
p
t
i
o
n
(
)</p>
<p>m
e
t
h
o
d
const std::string&amp; get_description() const
void set_description(const std::string&amp;)
Gets/sets the description for the bitfield  object. This description can be displayed in debuggers.
•
b
i
t
f
i
e
l
d
i
s
_
d
m
i
_
w
r
i
t
e
_
a
l
l
o
w
e
d
(
)</p>
<p>m
e
t
h
o
d</p>
<p>b
i
t
f
i
e
l
d
i
s
_
d
m
i
_
r
e
a
d
_
a
l
l
o
w
e
d
(
)</p>
<p>m
e
t
h
o
d</p>
<p>b
i
t
f
i
e
l
d
h
a
s
_
n
e
v
e
r
_
s
y
n
c
i
n
g
_
w
r
i
t
e
_
b
e
h
a
v
i
o
r
(
)</p>
<p>m
e
t
h
o
d</p>
<p>b
i
t
f
i
e
l
d
h
a
s
_
n
e
v
e
r
_
s
y
n
c
i
n
g
_
r
e
a
d
_
b
e
h
a
v
i
o
r
(
)</p>
<p>m
e
t
h
o
d</p>
<p>b
i
t
f
i
e
l
d
h
a
s
_
d
e
f
a
u
l
t
_
d
e
b
u
g
_
w
r
i
t
e
_
b
e
h
a
v
i
o
r
(
)</p>
<p>m
e
t
h
o
d</p>
<p>b
i
t
f
i
e
l
d
h
a
s
_
d
e
f
a
u
l
t
_
d
e
b
u
g
_
r
e
a
d
_
b
e
h
a
v
i
o
r
(
)</p>
<p>m
e
t
h
o
d</p>
<p>b
i
t
f
i
e
l
d
h
a
s
_
d
e
f
a
u
l
t
_
w
r
i
t
e
_
b
e
h
a
v
i
o
r
(
)</p>
<p>m
e
t
h
o
d</p>
<p>b
i
t
f
i
e
l
d
h
a
s
_
d
e
f
a
u
l
t
_
r
e
a
d
_
b
e
h
a
v
i
o
r
(
)</p>
<p>m
e
t
h
o
d
bool has_default_read_behavior() const;
bool has_default_write_behavior() const;
bool has_default_debug_read_behavior() const;
bool has_default_debug_write_behavior() const;
bool has_never_syncing_read_behavior() const;
bool has_never_syncing_write_behavior() const;
bool is_dmi_read_allowed() const;
bool is_dmi_write_allowed() const;
These are a set of APIs to query what type of behavior is associated with the memory_alias  and
whether DMI is enabled.
•
b
i
t
f
i
e
l
d
h
a
s
_
d
e
f
a
u
l
t
_
w
r
i
t
e
_
r
e
s
t
r
i
c
t
i
o
n
(
)</p>
<p>m
e
t
h
o
d</p>
<p>b
i
t
f
i
e
l
d
h
a
s
_
d
e
f
a
u
l
t
_
r
e
a
d
_
r
e
s
t
r
i
c
t
i
o
n
(
)</p>
<p>m
e
t
h
o
d
bool has_default_read_restriction() const;
bool has_default_write_restriction() const;
These APIs query whether there is a restriction set for the bitfield.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
59</p>
</section>
<section id="page-60">
<h2>Page 60<a class="headerlink" href="#page-60" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
2.6.4. Behaviors
This section describes:
Put/Get Access
The bitfield  object supports a limited set of the different put/get  behaviors as described in Behavior.
The set of access functions supported according to the different types and styles defined in Behavior
are detailed in the following table:
Table 25: Access Functions
Type
API
Callback
Watchpoints
Simple
Put/get
No
Yes
Simple-Debug
Put/get_debug
No
No
Trigger-Callbacks
Put/get_with_triggering_callba
cks
Regular
Yes
Trigger-Debug-Callba
cks
Put/get_with_triggering_debug_
callbacks
Debug
No
For each variant, there are also different signatures available:
Table 26: Signatures Available for Access Functions
Style
Arguments
Bitfield access
DT
Additional notes:
•
The Trigger-Callback access functions take an additional sc_time  argument. They return the TLM2
response status, returned by the triggered callback.
•
The get()  and get_debug()  methods for word or subword accesses return the read  data, instead
of passing it as an argument.
•
The debug versions of these methods do not trigger watchpoints.
In total, this gives 2x4  different access methods that are supported by the memory  objects, summarized
in the following table:
Table 27: Access Methods Supported by Memory Objects
Style Type
Bitfield Access
Simple
x
SystemC Modeling Library Reference Manual
X-2025.06-SP1
60</p>
</section>
<section id="page-61">
<h2>Page 61<a class="headerlink" href="#page-61" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Table 27: Access Methods Supported by Memory Objects (Continued)
Style Type
Bitfield Access
Simple-Debug
x
Trigger-Callbacks
x
Trigger-Debug-Callbacks
x
Operators
A bitfield  object can be converted to the underlying data type:
operator DT() const
The following assignment operators are available:
bitfield&amp; operator=(DT value)
bitfield&amp; operator =(const bitfield&amp; b)
The following arithmetic assignment operators are available and behave as defined for the underlying
data type:
bitfield&amp; operator+=(DT value)
bitfield&amp; operator-=(DT value)
bitfield&amp; operator/=(DT value)
bitfield&amp; operator*=(DT value)
bitfield&amp; operator%=(DT value)
bitfield&amp; operator^=(DT value)
bitfield&amp; operator&amp;=(DT value)
bitfield&amp; operator|=(DT value)
bitfield&amp; operator&lt;&lt;=(DT value)
bitfield&amp; operator&gt;&gt;=(DT value)
The following prefix and postfix decrement and increment operators are available:
bitfield&amp; operator–()
DT operator–(int)
bitfield&amp; operator++()
DT operator++(int)
2.6.5. Callbacks
The bitfield  object supports the callbacks listed in this section. For more information on callbacks,
also see Callbacks.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
61</p>
</section>
<section id="page-62">
<h2>Page 62<a class="headerlink" href="#page-62" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Regular Callbacks
Note:
Standard bitfield  callback implementations should not read or change any other bitfield value
except the one they are registered on. The order of callback execution on the bitfields is undefined,
therefore reading or writing to another bitfield can lead to unintended situations. Use the post write
callbacks for reading and adapting consistent values of multiple bitfields after the complete read/
write operation has finished.
Every callback registration function accepts a few signatures for the callback methods:
Regular callback registration
•
b
i
t
f
i
e
l
d
s
e
t
_
r
e
a
d
_
n
o
_
s
t
o
r
e
_
c
a
l
l
b
a
c
k
(
)</p>
<p>m
e
t
h
o
d
set_read_no_store_callback(bitfield, SCML2_CALLBACK(method), syncType, tag)
•
b
i
t
f
i
e
l
d
s
e
t
_
r
e
a
d
_
c
a
l
l
b
a
c
k
(
)</p>
<p>m
e
t
h
o
d
set_read_callback(bitfield, SCML2_CALLBACK(method), syncType, tag)
•
b
i
t
f
i
e
l
d
s
e
t
_
w
r
i
t
e
_
c
a
l
l
b
a
c
k
(
)</p>
<p>m
e
t
h
o
d
set_write_callback(bitfield, SCML2_CALLBACK(method), syncType, tag)
•
b
i
t
f
i
e
l
d
s
e
t
_
p
o
s
t
_
w
r
i
t
e
_
c
a
l
l
b
a
c
k</p>
<p>m
e
t
h
o
d
set_post_write_callback(bitfield, SCML2_CALLBACK(method), syncType, tag);
The set_read_callback  and set_read_no_store_callback  registration functions accept callback
methods with the following signatures:
•
bool readCallback (DT&amp; value, sc_core::sc_time&amp;, int tag)
•
bool readCallback (DT&amp; value, int tag)
•
bool readCallback (DT&amp; value, sc_core::sc_time&amp;,
const scml2::tlm2_gp_extensions&amp; extensions int tag)
•
bool readCallback (DT&amp; value, const scml2::tlm2_gp_extensions&amp; extensions int
tag)
The set_write_callback  registration function accepts callback methods with the following signatures:
•
bool
writeCallback(const DT&amp; value, sc_core::sc_time&amp;, int tag)
•
bool writeCallback(const DT&amp; value, int tag)
•
bool writeCallback(const DT&amp; value, sc_core::sc_time&amp;, const
scml2::tlm2_gp_extensions&amp; extensions int tag)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
62</p>
</section>
<section id="page-63">
<h2>Page 63<a class="headerlink" href="#page-63" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
bool writeCallback(const DT&amp; value, const
scml2::tlm2_gp_extensions&amp; extensions int tag)
The set_post_write_callback  registration function accepts callback methods with the following
signature:
•
void postWriteCallback(int tag)
Additional notes:
•
The bool  return value indicates that the access was successful.
•
In all the preceding callback methods,tag is an optional argument, only to be used when the callback
is registered with a tag.
•
The untimed callbacks (without the sc_time  parameter) cannot be SELF_SYNCING  callbacks.
Debug Callbacks
The bitfield  object supports the following registration APIs for debug callbacks:
Debug callback registration:
•
b
i
t
f
i
e
l
d
s
e
t
_
d
e
b
u
g
_
c
a
l
l
b
a
c
k
(
)</p>
<p>m
e
t
h
o
d
set_debug_callback(bitfield, SCML2_CALLBACK(method), tag)
•
b
i
t
f
i
e
l
d
s
e
t
_
d
e
b
u
g
_
r
e
a
d
_
c
a
l
l
b
a
c
k
(
)</p>
<p>m
e
t
h
o
d
set_debug_read_callback(bitfield, SCML2_CALLBACK(method), tag)
•
b
i
t
f
i
e
l
d
s
e
t
_
d
e
b
u
g
_
w
r
i
t
e
_
c
a
l
l
b
a
c
k
(
)</p>
<p>m
e
t
h
o
d
set_debug_write_callback(bitfield, SCML2_CALLBACK(method), tag)
For debug callbacks, callback  must have one of the following signatures:
•
bool readCallback(DT&amp; value, int tag)
•
bool writeCallback(const DT&amp; value, int tag)
The bool  return indicates whether the debug access was successful.
Predefined Callbacks
The following functions are available to register-specific read, and write  behavior to a register.
set_clear_on_read(bitfield)
Clears all bits of the memory when the memory is read.
set_set_on_read(bitfield)
Sets all bits of the memory when the memory is read.
set_clear_on_write_0(bitfie
ld)
Clears all bits to which the bit 0  is written.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
63</p>
</section>
<section id="page-64">
<h2>Page 64<a class="headerlink" href="#page-64" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
set_clear_on_write_1(bitfie
ld)
Clears all bits to which the bit 1  is written.
set_set_on_write_0(bitfield)
Sets all bits to which the bit 0  is written.
set_set_on_write_1(bitfield)
Sets all bits to which the bit 1  is written.
The write_once  callback function variants return a reference counted object of type
scml2::write_once_state. This object can be used to reset the state, such that the memory becomes
writable again, by calling reset()  on it.
2.6.6. Access Restrictions
The bitfield  object supports access restrictions as described in Access Restrictions. The bitfield
supports all predefined access restrictions as specified in Predefined Access Restrictions, it supports
both styles of access restriction callbacks:
•
scml2::access_restriction_result MyRestrictFtion(DT&amp; data, DT&amp; bit_enables,
int tag)
•
scml2::access_restriction_result MyRestrictFtion(tlm::tlm_generic_payload&amp; trans,
int tag)
2.7. router
The router  is a SCML2 storage object that is intended to be used to create a configurable model,
where memory access calls can be redirected to different storage components. Examples of models
that can be built using a router  are caches, memory controller, even interconnect components, or a
dynamic address decoder. A router  is similar to an scml2::memory, so it can be instantiated as a top-
level memory object, but it does not implement any storage. It also does not have a default behavior;
it requires a transport callback to implement its behavior. The key feature is, however, the additional
mapping interface which allows routing certain memory regions to a scml2::memory, or an initiator
socket (or anything implementing the mappable_if). After a region is mapped, all accesses to that
region automatically is forwarded to the memory or socket without being evaluated in the router  again.
Only when the region is unmapped by the router, the transport implementation is called again.
The include  file of the router  objects is scml2/router.h.
Additional properties of the router  object are:
•
It is possible to have a different mapping for reads  and writes.
•
The router  has a limited set of put/get  access methods, basically the ones that are similar to the
TLM2 APIs.
•
The map  API maps a region of a certain size starting at the base address in the router, to a region
in the destination, implementing the mappable_if  interface starting from address  offset. The bool
SystemC Modeling Library Reference Manual
X-2025.06-SP1
64</p>
</section>
<section id="page-65">
<h2>Page 65<a class="headerlink" href="#page-65" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
return value indicates failure if the region is already mapped, out of range, or if the request is not
word-aligned.
•
A router  object is similar to a memory  object, but it has no associated storage and no default
behavior. A callback must be registered to the router  object that implements the required behavior
of the accesses to this memory range.
•
A router  object can map a memory region to a region into a memory  object, another router  object,
a tlm2_gp_initiator_adapter  object, or an object that implements the mappable_if  interface.
Accesses to mapped regions do not trigger the attached callback, but are automatically forwarded to
the destination object.
•
The router  object implements the mappable_if  object, which means that it can be the destination
for a mapped range of a router  object.
•
A router  object cannot have aliases and/or registers.
2.7.1. Types
The router  class is templated with the underlying value type:
Template <typename DT> class router
The following types are supported:
Table 28: Supported Datatypes
Supported Datatypes
Word Size
unsigned char
8
unsigned short
16
unsigned int
32
unsigned long long
64
sc_dt::sc_biguint&lt;128&gt;
128
sc_dt::sc_biguint&lt;256&gt;
256
sc_dt::sc_biguint&lt;512&gt;
512
2.7.2. Constructors
The following constructor is available:
router(const std::string&amp; name, unsigned long long size)
Creates a new router. The size  argument must be specified in words.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
65</p>
</section>
<section id="page-66">
<h2>Page 66<a class="headerlink" href="#page-66" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
2.7.3. Properties
The following methods are available to access the properties of a memory_alias:
•
r
o
u
t
e
r
g
e
t
_
n
a
m
e
(
)</p>
<p>m
e
t
h
o
d
const  std::string&amp;  get_name()  const
Returns the full hierarchical name of the of the router  object.
•
r
o
u
t
e
r
g
e
t
_
o
f
f
s
e
t
(
)</p>
<p>m
e
t
h
o
d
unsigned long long get_offset() const
Always returns 0  for a router  object.
•
r
o
u
t
e
r
g
e
t
_
s
i
z
e
(
)</p>
<p>m
e
t
h
o
d
unsigned long long get_size() const
Returns the size of the router  object in words.
•
r
o
u
t
e
r
g
e
t
_
w
i
d
t
h
(
)</p>
<p>m
e
t
h
o
d
unsigned int get_width() const
Returns the data width of the router  object in bytes.
•
r
o
u
t
e
r
i
s
_
d
m
i
_
e
n
a
b
l
e
d
(
)</p>
<p>m
e
t
h
o
d
bool is_dmi_enabled()
Returns true  if DMI accesses are allowed for the object, false  otherwise. DMI is enabled by
default.
•
r
o
u
t
e
r
d
i
s
a
b
l
e
_
d
m
i
(
)</p>
<p>m
e
t
h
o
d</p>
<p>r
o
u
t
e
r
e
n
a
b
l
e
_
d
m
i
(
)</p>
<p>m
e
t
h
o
d
void enable_dmi()
void disable_dmi()
Enables/disables DMI accesses for the object.
•
r
o
u
t
e
r
s
e
t
_
d
e
s
c
r
i
p
t
i
o
n</p>
<p>m
e
t
h
o
d</p>
<p>r
o
u
t
e
r
g
e
t
_
d
e
s
c
r
i
p
t
i
o
n
(
)</p>
<p>m
e
t
h
o
d
const std::string&amp; get_description() const
void set_description(const std::string&amp;)
Gets/sets the description for the memory_alias  object. This description can be displayed in
debuggers.
The router  object can be bound to a TLM2 target socket using a port_adapter  (see Port Adaptors). A
target port adaptor may be bound to a SCML2 router  as shown in the following code.
// bind adaptor to memory
scml2::router my_router(“my_ router “, 0x100);
(*my_port_adapter)(my_ router);
SystemC Modeling Library Reference Manual
X-2025.06-SP1
66</p>
</section>
<section id="page-67">
<h2>Page 67<a class="headerlink" href="#page-67" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
2.7.4. Behaviors
This section describes:
Mapping APIs
The following methods are available to map or unmap memory regions:
•
r
o
u
t
e
r
m
a
p
(
)</p>
<p>m
e
t
h
o
d
bool map(unsigned long long base,
unsigned long long size,
mappable_if&amp; destination,
unsigned long long offset;
Maps the memory range [base, base  + size]  of the socket to which the router  object is bound to
the memory range [offset, offset  + size]  of the destination.
Possible destinations are: memory, router, tlm2_gp_initiator_adapter, and objects implementing the
mappable_if interface.
The base, size, and offset  arguments must all be specified in bytes.
If the mapping succeeds, true  is returned; otherwise false  is returned. The mapping will fail if:
◦
the mapped range overlaps with a previously-mapped range, or
◦
if the mapped range is outside the memory range of the router  object, or
◦
if the base address or size of the mapped range is not aligned with the width of the router
object.
After mapping a region to a destination, all accesses coming to this region are automatically
forwarded to this destination. If a callback is registered to scml_router, it is not invoked. If a burst
goes across the boundary of a mapped region, then the burst is unrolled.
The map()  method maps the memory range both for read  access and write  accesses.
•
r
o
u
t
e
r
m
a
p
_
r
e
a
d
(
)</p>
<p>m
e
t
h
o
d
bool map_read(unsigned long long base,
unsigned long long size,
mappable_if&amp; destination,
unsigned long long offset);
Same as the map()  method, but the memory range is mapped only for read  accesses.
•
r
o
u
t
e
r
m
a
p
_
w
r
i
t
e
(
)</p>
<p>m
e
t
h
o
d
bool map_write(unsigned long long base,
unsigned long long size,
mappable_if&amp; destination,
unsigned long long offset);
Same as the map()  method, but the memory range is mapped only for write  accesses.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
67</p>
</section>
<section id="page-68">
<h2>Page 68<a class="headerlink" href="#page-68" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Note:
Mapped ranges for read  and for write  accesses are completely independent. A mapped range
for read  accesses is allowed to overlap with a mapped range for write  accesses.
•
r
o
u
t
e
r
u
n
m
a
p
(
)</p>
<p>m
e
t
h
o
d
bool unmap(unsigned long long base);
Unmaps a previously-mapped range for both read  and write  accesses.
Returns true  if a mapped range is found and removed, otherwise false.
•
r
o
u
t
e
r
u
n
m
a
p
_
r
e
a
d
(
)</p>
<p>m
e
t
h
o
d
bool unmap_read(unsigned long long base);
Same as the unmap()  method, but the memory range is unmapped only for read  accesses.
•
r
o
u
t
e
r
u
n
m
a
p
_
w
r
i
t
e
(
)</p>
<p>m
e
t
h
o
d
bool unmap_write(unsigned long long base);
Same as the unmap()  method, but the memory range is unmapped only for write  accesses.
•
r
o
u
t
e
r
u
n
m
a
p
_
a
l
l
(
)</p>
<p>m
e
t
h
o
d
void unmap_all();
Unmaps all previously mapped memory regions.
Note:
Mapping memory regions can be done:
•
statically from the constructor of the module,
•
or dynamically from the attached callback or from another SystemC thread.
Transport Calls
The router  object implements the following TLM2 methods:
•
r
o
u
t
e
r
t
r
a
n
s
p
o
r
t
_
d
b
g</p>
<p>m
e
t
h
o
d</p>
<p>r
o
u
t
e
r
b
_
t
r
a
n
s
p
o
r
t</p>
<p>m
e
t
h
o
d
void b_transport(tlm::tlm_generic_payload&amp;trans, sc_core::sc_time&amp;t)
unsigned int transport_dbg(tlm::tlm_generic_payload&amp;trans)
•
r
o
u
t
e
r
g
e
t
_
d
i
r
e
c
t
_
m
e
m
_
p
t
r</p>
<p>m
e
t
h
o
d
SystemC Modeling Library Reference Manual
X-2025.06-SP1
68</p>
</section>
<section id="page-69">
<h2>Page 69<a class="headerlink" href="#page-69" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
bool get_direct_mem_ptr(tlm::tlm_generic_payload&amp; trans,
tlm::tlm_dmi&amp;dmiData)
These methods trigger the callbacks registered to the router  object.
Put/Get access
The router  object supports some of the put/get  behaviors as described in Behavior. So, only access
methods that trigger callbacks are supported. The following set of access functions is supported
according to the different types and styles as defined in Behavior:
Table 29: Access Functions
Type
API
Callb
ack
Watchpoints
Trigger-Callbacks
Put/get_with_triggering_callbacks
Regu
lar
Yes
Trigger-Debug-Callba
cks
Put/get_with_triggering_debug_callbacks
Debug
No
For each variant, there are also different signatures available:
Table 30: Signatures Available for Access Functions
Style
Arguments
TLM2
address, dataPtr, data_length, byte_enablePtr, enableLength
TLM2-Word
address, dataPtr, data_length
Word
index, DT
SubWord
index, DT, size, offset
In the table Table 30, the arguments are as follows:
Table 31: Arguments for Signatures of Access Functions
Argument
Name
C++
Description
address
unsigned long long
address
Specifies the byte address as in TLM2 GP.
dataPtr
(const) unsigned char*
data
Specifies the data array as in TLM2 GP.
data_length
unsigned int dataLength Specifies the length of the transaction in bytes as in
TLM2 GP.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
69</p>
</section>
<section id="page-70">
<h2>Page 70<a class="headerlink" href="#page-70" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Table 31: Arguments for Signatures of Access Functions (Continued)
Argument
Name
C++
Description
byte_enable
Ptr
const unsigned char*
byteEneblePtr
Specifies a byte enable array which can be 0  as in
TLM2 GP.
enableLen
gth
unsigned int
byteEnableLength
Specifies the length of the byte enable array in bytes as
in TLM2 GP.
index
unsigned long long
index
Specifies the word index as specified by the DT
template of the memory  object.
DT
(const) DT&amp; data
Specifies the data.
size
unsigned int size
Specifies the size of the access in bytes.
offset
unsigned int offset
Specifies the offset for the access in bytes.
Additional notes:
•
The Trigger-Callback access functions take an additional sc_time  argument. They return the TLM2
response status, returned by the triggered callback.
•
The put_debug_with_triggering_callbacks()  and
get_debug_with_triggering_callbacks()  calls must not use byte_enables  (the
byteEnablePtr  must be 0 ), since TLM2 does not support byte enables for debug calls.
•
The debug versions of these methods do not trigger watchpoints.
In total, this gives 2x8  different access methods that are supported by the memory  objects, summarized
in the following table:
Table 32: Access Methods Supported by Memory Objects
Style
Type
TLM2 TLM2-Word
Word Subword
Trigger-Callbacks
x
x
x
x
Trigger-Debug-Callba
cks
x
x
x
x
For a complete list with all arguments, see the include  file of the memory: scml2/router.h.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
70</p>
</section>
<section id="page-71">
<h2>Page 71<a class="headerlink" href="#page-71" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
2.7.5. Callbacks
The router  object supports the callbacks listed in this section. For more information on callbacks, also
see Callbacks.
Regular Callbacks
The router  object only supports the set_callback  registration-style callback methods.
Regular callback registration:
•
r
o
u
t
e
r
s
e
t
_
c
a
l
l
b
a
c
k
(
)</p>
<p>f
u
n
c
t
i
o
n
set_callback(mem, SCML2_CALLBACK(method), syncType, tag)
It only accepts callback methods with the following signature:
•
void transportCallback(tlm::tlm_generic_payload&amp;, sc_core::sc_time&amp;, int tag)
Note:
In all the preceding callback methods, tag is an optional argument, only to be used when the
callback is registered with a tag.
Debug Callbacks
The memory  object supports the following registration APIs for debug callbacks:
Debug callback registration
•
r
o
u
t
e
r
s
e
t
_
d
e
b
u
g
_
c
a
l
l
b
a
c
k</p>
<p>f
u
n
c
t
i
o
n
set_debug_callback(mem, SCML2_CALLBACK(method), tag)
For debug callbacks, method  must have one of the following signatures:
•
unsigned int transportCallback(tlm::tlm_generic_payload&amp;)
•
unsigned int transportCallback(tlm::tlm_generic_payload&amp;,  int tag)
The return value is the number of consecutive bytes successfully read or written. If the access cannot
be executed, 0  must be returned.
2.8. memory utilities
This section describes:
•
memory_index_reference
•
mappable_if
SystemC Modeling Library Reference Manual
X-2025.06-SP1
71</p>
</section>
<section id="page-72">
<h2>Page 72<a class="headerlink" href="#page-72" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
•
Callback Base Classes
•
Convenience Functions
2.8.1. memory_index_reference
m
e
m
o
r
y
_
i
n
d
e
x
_
r
e
f
e
r
e
n
c
e
The memory_index_reference  object is returned by the lvalue  version (non- const  version) of the
index operator (operator[]) of memory and memory_alias objects.
The memory_index_reference  object forwards all operations to the referenced memory object.
The include file of the memory_index_reference  objects is scml2/memory_index_reference.h.
The following sections describe:
•
Types
•
Access Methods
•
Operators
Types
The following type definitions are available:
typedef DT data_type
typedef memory_index_reference<DT> reference
Access Methods
The following access methods are available:
m
e
m
o
r
y
_
i
n
d
e
x
_
r
e
f
e
r
e
n
c
e
p
u
t
_
d
e
b
u
g
(
)</p>
<p>m
e
t
h
o
d
m
e
m
o
r
y
_
i
n
d
e
x
_
r
e
f
e
r
e
n
c
e
p
u
t
(
)</p>
<p>m
e
t
h
o
d
void put(const DT&amp;value)
DT get() const</p>
<p>void put_debug(const DT&amp; value)
DT get_debug() const
Operators
A memory_index_reference  object can be converted to the underlying data type of the referenced
memory object:
operator DT() const
The following assignment operators are available:
reference&amp; operator=(DT value)
The following arithmetic assignment operators are available and behave as defined for the underlying
data type of the referenced memory object:
reference&amp; operator+=(DT value)
reference&amp; operator-=(DT value)
reference&amp; operator/=(DT value)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
72</p>
</section>
<section id="page-73">
<h2>Page 73<a class="headerlink" href="#page-73" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
reference&amp; operator*=(DT value)
reference&amp; operator%=(DT value)
reference&amp; operator^=(DT value)
reference&amp; operator&amp;=(DT value)
reference&amp; operator|=(DT value)
reference&amp; operator&gt;&gt;=(DT value)
reference&amp; operator&lt;&lt;=(DT value)
The following prefix and postfix decrement and increment operators are available:
reference&amp; operator–()
DT operator–(int)
reference&amp; operator++()
DT operator++(int)
2.8.2. mappable_if
m
a
p
p
a
b
l
e
_
i
f
The mappable_if  object is the abstract interface that must be implemented by an object to be able to
act as a destination for a mapped range of a router object.
The include file of the mappable_if  objects is scml2/mappable_if.h.
The following section describes:
•
TLM API Methods
TLM API Methods
The following methods must be implemented:
m
a
p
p
a
b
l
e
_
i
f
g
e
t
_
m
a
p
p
e
d
_
n
a
m
e
(
)</p>
<p>m
e
t
h
o
d
std::string get_mapped_name() const = 0
Should return the name of the mapped destination. For a memory or router object, this is the
name of the object. For a tlm2_gp_target_adapter object, this is the name of the TLM2 initiator
socket.
m
a
p
p
a
b
l
e
_
i
f
u
n
r
e
g
i
s
t
e
r
_
b
w
_
d
i
r
e
c
t
_
m
e
m
_
i
f
(
)</p>
<p>m
e
t
h
o
d
m
a
p
p
a
b
l
e
_
i
f
r
e
g
i
s
t
e
r
_
b
w
_
d
i
r
e
c
t
_
m
e
m
_
i
f
(
)</p>
<p>m
e
t
h
o
d
void register_bw_direct_mem_if(tlm::tlm_bw_direct_mem_if<em>bwInterface) = 0
void unregister_bw_direct_mem_if(tlm::tlm_bw_direct_mem_if</em>bwInterface) = 0
Is called to register/unregister a pointer to a tlm_bw_direct_mem_if  object. When the
object that inherits from the mappable_if  has to invalidate the DMI pointers, it has to call
invalidate_direct_mem_ptr()  on each registered interface.
Note:
If a tlm_bw_direct_mem_if  object is registered multiple times, it must only be stored at one time
and the invalidate call must only be called at one time.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
73</p>
</section>
<section id="page-74">
<h2>Page 74<a class="headerlink" href="#page-74" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
The following TLM2 API methods (see the IEEE Std 1666 TLM-2.0 Language Reference Manual) must
be implemented:
m
a
p
p
a
b
l
e
_
i
f
t
r
a
n
s
p
o
r
t
_
d
b
g
(
)</p>
<p>m
e
t
h
o
d
m
a
p
p
a
b
l
e
_
i
f
g
e
t
_
d
i
r
e
c
t
_
m
e
m
_
p
t
r
(
)</p>
<p>m
e
t
h
o
d
m
a
p
p
a
b
l
e
_
i
f
b
_
t
r
a
n
s
p
o
r
t
(
)</p>
<p>m
e
t
h
o
d
void b_transport(tlm::tlm_generic_payload&amp; trans, sc_core::sc_time&amp; t) = 0
bool get_direct_mem_ptr(tlm::tlm_generic_payload&amp; trans, tlm::tlm_dmi&amp; dmiData)
= 0
unsigned int transport_dbg(tlm::tlm_generic_payload&amp; trans) = 0
2.8.3. Callback Base Classes
c
a
l
l
b
a
c
k</p>
<p>b
a
s
e</p>
<p>c
l
a
s
s
e
s
This section describes:
•
memory_callback_base
•
memory_debug_callback_base
•
router_callback_base
•
router_debug_callback_base
•
bitfield_read_callback_base
•
bitfield_write_callback_base
•
bitfield_debug_read_callback_base
•
bitfield_debug_write_callback_base
memory_callback_base
Base class for regular callbacks of memory, memory_alias, or reg objects.
The following virtual methods must be implemented:
void execute(tlm::tlm_generic_payload&amp; trans, sc_core::sc_time&amp; t) = 0
Implementation of the callback behavior.
bool has_never_syncing_behavior() const = 0
Returns true  if the callback never synchronizes, otherwise false.
The include file of the memory_callback_base  objects is scml2/memory_callback_base.h.
memory_debug_callback_base
m
e
m
o
r
y
_
d
e
b
u
g
_
c
a
l
l
b
a
c
k
_
b
a
s
e
Base class for debug callbacks of memory, memory_alias, or reg objects.
The following virtual method must be implemented:
unsigned int execute(tlm::tlm_generic_payload&amp;trans) = 0
Implementation of the callback behavior.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
74</p>
</section>
<section id="page-75">
<h2>Page 75<a class="headerlink" href="#page-75" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
The include file of the memory_debug_callback_base  objects is scml2/
memory_debug_callback_base.h.
router_callback_base
r
o
u
t
e
r
_
c
a
l
l
b
a
c
k
_
b
a
s
e
Base class for regular callbacks of router objects.
The following virtual methods must be implemented:
void execute(tlm::tlm_generic_payload&amp; trans, sc_core::sc_time&amp;t) = 0
Implementation of the callback behavior.
bool has_never_syncing_behavior() const = 0
Returns true  if the callback never synchronizes, otherwise false.
The include file of the router_callback_base  objects is scml2/router_callback_base.h.
router_debug_callback_base
r
o
u
t
e
r
_
d
e
b
u
g
_
c
a
l
l
b
a
c
k
_
b
a
s
e
Base class for debug callbacks of router objects.
The following virtual method must be implemented:
unsigned int execute(tlm::tlm_generic_payload&amp;trans) = 0
Implementation of the callback behavior.
The include file of the router_debug_callback_base  objects is scml2/
router_debug_callback_base.h.
bitfield_read_callback_base
b
i
t
f
i
e
l
d
_
r
e
a
d
_
c
a
l
l
b
a
c
k
_
b
a
s
e
Templated base class for regular read callbacks of bitfield objects. The class has one template
parameter, which is the data type of the bitfield object.
The following virtual methods must be implemented:
bool read(DT&amp; value, sc_core::sc_time&amp;t) = 0
Implementation of the callback behavior.
bool has_never_syncing_behavior() const = 0
Returns true  if the callback never synchronizes, otherwise false .
The include file of the bitfield_read_callback_base  objects is scml2/
bitfield_read_callback_base.h.
bitfield_write_callback_base
b
i
t
f
i
e
l
d
_
w
r
i
t
e
_
c
a
l
l
b
a
c
k
_
b
a
s
e
Templated base class for regular write callbacks of bitfield objects. The class has one template
parameter, which is the data type of the bitfield object.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
75</p>
</section>
<section id="page-76">
<h2>Page 76<a class="headerlink" href="#page-76" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
The following virtual methods must be implemented:
bool write(const DT&amp; value, sc_core::sc_time&amp; t) = 0
Implementation of the callback behavior.
bool has_never_syncing_behavior() const = 0
Returns true  if the callback never synchronizes, otherwise false .
The include file of the bitfield_write_callback_base  objects is scml2/
bitfield_write_callback_base.h.
bitfield_debug_read_callback_base
b
i
t
f
i
e
l
d
_
d
e
b
u
g
_
r
e
a
d
_
c
a
l
l
b
a
c
k
_
b
a
s
e
Templated base class for debug read callbacks of bitfield objects. The class has one template
parameter, which is the data type of the bitfield object.
The following virtual method must be implemented:
bool read(DT&amp; value) = 0
Implementation of the callback behavior.
The include file of the bitfield_debug_read_callback_base  objects is scml2/
bitfield_debug_read_callback_base.h.
bitfield_debug_write_callback_base
b
i
t
f
i
e
l
d
_
d
e
b
u
g
_
w
r
i
t
e
_
c
a
l
l
b
a
c
k
_
b
a
s
e
Templated base class for debug write callbacks of bitfield objects. The class has one template
parameter, which is the data type of the bitfield object.
The following virtual method must be implemented:
bool write(const DT&amp; value) = 0
Implementation of the callback behavior.
The include file of the bitfield_debug_write_callback_base  objects is scml2/
bitfield_debug_write_callback_base.h.
2.8.4. Convenience Functions
The following convenience functions are available in scml2/utils.h:
template <typename DT> DT extract_bits(const DT&amp; v, unsigned int sizeBits,
unsigned int offsetBits)
Returns sizeBits  bits from offset offsetBits  of the data word v. offsetBits  and sizeBits
are specified in bits.
Little endian bit ordering is used (the offset of the lsb  is 0) .
SystemC Modeling Library Reference Manual
X-2025.06-SP1
76</p>
</section>
<section id="page-77">
<h2>Page 77<a class="headerlink" href="#page-77" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
template <typename DT> DT insert_bits(const DT&amp; v, const DT&amp; rhs,
unsigned int sizeBits, unsigned int offsetBits)
Inserts sizeBits  bits of the data passed in rhs  at offset offsetBits  in the data word v  and
returns the result. offsetBits  and sizeBits  are specified in bits.
Little endian bit ordering is used (the offset of the lsb  is 0).
2.9. Deprecated API’s and Adapters
This sections describes:
•
Callbacks
•
TLM2 Adapters
•
tlm2_gp_target_adapter
•
tlm2_gp_initiator_adapter
2.9.1. Callbacks
The following convenience callback functions are deprecated:
Disallow Access to Memory Object
The following functions are available to disallow the access to a memory object. These callbacks
register a callback of type memory_disallow_access_callback.
Predefined API’s to disallow access to a memory object
set_ignore_access(mem)
set_ignore_read_access(mem)
set_ignore_write_access(mem)
set_disallow_access(mem)
set_disallow_read_access(mem)
set_disallow_write_access(mem)
set_read_only(mem)
set_write_only(mem)
Where mem  is the memory object to which the callback is registered.
When an access is ignored, an ok response is returned; when an access is disallowed, an error
response is returned. Reading a write-only memory or writing a read-only memory is also return an error
response.
When an access is ignored or disallowed, the contents of the memory is not updated after the access.
The following functions are available to disallow the debug access to a memory. These callbacks
register a debug callback of type memory_disallow_debug_access_callback. The callback ignores
the access and returns 0. When an access is ignored or disallowed, the contents of the memory is not
updated after the access.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
77</p>
</section>
<section id="page-78">
<h2>Page 78<a class="headerlink" href="#page-78" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Predefined API’s to disallow debug accesses to a memory object
set_disallow_debug_access(mem)
set_disallow_debug_read_access(mem)
set_disallow_debug_write_access(mem)
where mem  is the memory object to which the callback is registered. When an access is ignored or
disallowed, the contents of the memory is not updated after the access.
Callbacks on Predefined Behaviors
The following functions are available to register a user-defined callback, in combination with the
predefined behaviors, where the user callback is called before the behavior callback:
Pre-predefined callback registration
set_clear_on_read_callback(mem,object,callback,name,syncType)
set_clear_on_read_callback(mem,object,callback,name,syncType,tag)
set_word_clear_on_read_callback(mem,object,callback,name,syncType)
set_word_clear_on_read_callback(mem,object,callback,name,syncType,tag)
set_set_on_read_callback(mem,object,callback,name, syncType)
set_set_on_read_callback(mem,object,callback,name,syncType,tag)
set_word_set_on_read_callback(mem,object,callback,name,syncType)
set_word_set_on_read_callback(mem,object,callback,name,syncType,tag)
set_clear_on_write_0_callback(mem,object,callback,name,syncType)
set_clear_on_write_0_callback(mem,object,callback,name,syncType,tag)
set_word_clear_on_write_0_callback(mem,object,callback,name,syncType)
set_word_clear_on_write_0_callback(mem,object,callback,name,syncType,tag)
set_clear_on_write_1_callback(mem,object,callback,name,syncType)
set_clear_on_write_1_callback(mem,object,callback,name,syncType,tag)
set_word_clear_on_write_1_callback(mem,object,callback,name,syncType)
set_word_clear_on_write_1_callback(mem,object,callback,name,syncType,tag)
set_write_once_ignore_callback(mem,object,callback,name,syncType)
set_write_once_ignore_callback(mem,object,callback,name,syncType,tag)
set_write_once_error_callback(mem,object,callback,name,syncType)
set_write_once_error_callback(mem,object,callback,name,syncType,tag)
set_word_write_once_ignore_callback(mem,object,callback,name,syncType)
set_word_write_once_ignore_callback(mem,object,callback,name,syncType,tag)
set_word_write_once_error_callback(mem,object,callback,name,syncType)
set_word_write_once_error_callback(mem,object,callback,name,syncType,tag)
set_set_on_write_0_callback(mem,object,callback,name,syncType)
set_set_on_write_1_callback(mem,object,callback,name,syncType)
set_set_on_write_1_callback(mem,object,callback,name,syncType,tag)
set_word_set_on_write_0_callback(mem,object,callback,name,syncType)
set_word_set_on_write_1_callback(mem,object,callback,name,syncType)
set_word_set_on_write_1_callback(mem,object,callback,name,syncType,tag)
The following functions are available to register a user-defined callback, in combination with the earlier
defined behaviors, where the user callback is called after the behavior callback:
Post-predefined callback registration
set_post_clear_on_write_0_callback(mem,object, callback, name, syncType)
set_post_clear_on_write_0_callback(mem, object, callback, name, syncType, tag)
set_post_clear_on_write_1_callback(mem, object, callback, name, syncType)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
78</p>
</section>
<section id="page-79">
<h2>Page 79<a class="headerlink" href="#page-79" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
set_post_clear_on_write_1_callback(mem, object, callback, name, syncType, tag)
set_post_write_once_ignore_callback(mem, object, callback, name, syncType)
set_post_write_once_ignore_callback(mem, object, callback, name, syncType, tag)
set_post_write_once_error_callback(mem, object, callback, name, syncType)
set_post_write_once_error_callback(mem, object, callback, name, syncType, tag)
set_post_set_on_write_0_callback(mem, object, callback, name, syncType)
set_post_set_on_write_1_callback(mem, object, callback, name, syncType)
set_post_set_on_write_1_callback(mem, object, callback, name, syncType, tag)
Where:
mem
Is the memory object to which the callback is registered.
object Is a pointer to the class containing the callback method.
callb
ack
Is a pointer to a member function of the object class. It must have one of the following
signatures:
For the regular callbacks, it should have one of the transportCallback, readCallback, or
wordReadCallback  signatures, as listed earlier.
For the post callbacks, it should be either:
void postWriteCallback()
void postWriteCallback(inttag)
name
Is a string specifying the name of the callback function.
syncT
ype
Can be one of the following:
• NEVER_SYNCING  indicates that the callback is nonblocking and must never call wait().
• SELF_SYNCING  indicates that the callback is blocking and may call wait(). The timing
annotation is passed unmodified to the callback.
• AUTO_SYNCING  indicates that the callback is blocking and may call wait(). The memory
object synchronizes before calling the callback. The timing annotation passed to the
callback is always SC_ZERO_TIME
These types are defined in the scml2/types.h  file.
The Post predefined behavior callbacks do not support SELF_SYNCING  callbacks (since
the callback does not have a time argument).
tag
Is a user-provided integer that is passed to the callback.
2.9.2. TLM2 Adapters
The tlm2_gp_target_adapter  and tlm2_gp_initiator_adapter  are deprecated in favor of the
port_adapters  described in Port Adaptors.
2.9.3. tlm2_gp_target_adapter
scml2::tlm2_gp_target_adapter  is an adapter that is used to bind a memory object to a tlm2 target
socket. It takes a TLM2 GP transaction and forwards it to the memory objects. The adapter takes care
of burst accesses (burst unrolling so that the different regions are accessed correctly) it also takes
care of the AT to LT conversion for the TLM2 base protocol. It ensures that all accesses to memory
SystemC Modeling Library Reference Manual
X-2025.06-SP1
79</p>
</section>
<section id="page-80">
<h2>Page 80<a class="headerlink" href="#page-80" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
objects can be executed as LT accesses (b_transport  semantics, that is, calling wait()  and so on
is allowed). The adapter does not touch any extensions so ignorable extensions are forwarded.
The adapter also implements the backward DMI interface, this means that the memories uses the target
adapter to issue the invalidate DMI pointer calls to the initiator.
t
l
m
2
_
g
p
_
t
a
r
g
e
t
_
a
d
a
p
t
e
r
The tlm2_gp_target_adapter  can be bound to any object implementing the mappable_if, for
example, an scml2::memory.
The tlm2_gp_target_adapter  is specific to the TLM2 base protocol, other protocol definitions may
need their own adapter implementation to take care of specific burst unrolling features or for their
specific AT to LT conversion. To create an adapter, it is required to create an object that implements the
following:
•
The tlm::tlm_fw_transport_if  so that it can be bound to a target socket.
•
A binding operation ()  with a mappable_if  so that the storage objects can be bound to it.
template <unsigned int BUSWIDTH>
class tlm2_gp_target_adapter   :
public sc_core::sc_object,
public tlm::tlm_fw_transport_if&lt;&gt;,
public tlm::tlm_bw_direct_mem_if
{
typedef tlm::tlm_base_target_socket&lt;BUSWIDTH,
tlm::tlm_fw_transport_if&lt;&gt;,
tlm::tlm_bw_transport_if&lt;&gt;,
N,
POL&gt; socket_type;</p>
<p>tlm2_gp_target_adapter(const std::string&amp; name, socket_type&amp; s);
void operator()(mappable_if&amp; destination);
…
};
The tlm2_gp_target_adapter  object is used to bind an object that implements the mappable_if (for
example, a memory or router object) to a tlm_target_socket.
All TLM2 API methods are forwarded to the object bound to the adapter.
The include file of the tlm2_gp_target_adapter  objects is scml2/tlm2_gp_target_adapter.h.
The following sections describe:
•
Types
•
Constructors
•
Binding
•
Custom Forwarding
SystemC Modeling Library Reference Manual
X-2025.06-SP1
80</p>
</section>
<section id="page-81">
<h2>Page 81<a class="headerlink" href="#page-81" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
Types
The tlm2_gp_target_adapter  class is templated with the BUSWIDTH:
template <unsigned int BUSWIDTH> class tlm2_gp_target_adapter
The BUSWIDTH  must be the same as the BUSWIDTH  of the TLM2 target socket to which the adapter is
bound.
Constructors
The following constructor is available:
tlm2_gp_target_adapter(const std::string&amp; name,
tlm::tlm_base_target_socket<BUSWIDTH>&amp; s)
Creates a target adapter and binds it to the TLM2 target socket.
Binding
The following method is available to bind objects that inherit from the mappable_if object to the
tlm2_gp_target_adapter  object:
t
l
m
2
_
g
p
_
t
a
r
g
e
t
_
a
d
a
p
t
e
r
o
p
e
r
a
t
o
r
(
)</p>
<p>m
e
t
h
o
d
void operator()(mappable_if&amp; destination)
Binds an object to the adapter class.
Custom Forwarding
By default, tlm2_gp_target_adapter  always forwards all TLM2 API methods to the first bound
mappable_if  object. It is possible to register a user-defined function to forward transactions to other
bound mappable_if  objects. This is done by calling set_select_callback(), and passing a SCML2
callback method which returns a mappable_if  pointer for a given TLM payload.
For example:
MyModule(sc_module_name name) …{
…
adapter(memory1);
adapter(memory2);
set_select_callback(adapter, SCML2_CALLBACK(selectMemory));
…
}</p>
<p>scml2::mappable_if* selectMemory(tlm::tlm_generic_payload&amp; trans) {
if (…) {
// Change the transaction address, and forward to memory 1
trans.set_address(4);
return &amp;memory1;
}
else {
// Change the transaction address, and forward to memory 2
trans.set_address(8);
return &amp;memory2;
SystemC Modeling Library Reference Manual
X-2025.06-SP1
81</p>
</section>
<section id="page-82">
<h2>Page 82<a class="headerlink" href="#page-82" title="Permalink to this heading"></a></h2>
<p>Chapter 2: Memory Objects
 
}
}
2.9.4. tlm2_gp_initiator_adapter
scml2::tlm2_gp_initiator_adaper  is an object that is used to map a memory region of a router
object to a tlm_initiator_socket. It implements the mappable_if, so you can use it as a destination
for the map API’s of the router  and bind it to an initiator socket.
t
l
m
2
_
g
p
_
i
n
i
t
i
a
t
o
r
_
a
d
a
p
t
e
r
The tlm2_gp_initiator_adapter  object is used to map a memory region of a router object to a
tlm_initiator_socket.
The tlm2_gp_initiator_adapter  object binds to the tlm_initiator_socket  and implements the
mappable_if.
The include file of the tlm2_gp_initiator_adapter  objects is scml2/
tlm2_gp_initiator_adapter.h.
template &lt;unsigned int BUSWIDTH, int N = 1,
sc_core::sc_port_policy POL = sc_core::SC_ONE_OR_MORE_BOUND&gt;
class tlm2_gp_initiator_adapter   :
public sc_core::sc_object,
public mappable_if,
public tlm::tlm_bw_transport_if
{
…
tlm2_gp_initiator_adapter(const std::string&amp; name, socket_type&amp; s);
…
};
The following sections describe:
•
Types
•
Constructors
Types
The tlm2_gp_initiator_adapter  is templated with the BUSWIDTH:
template <unsigned int BUSWIDTH> class tlm2_gp_initiator_adapter
The BUSWIDTH  must be the same as the BUSWIDTH  of the TLM2 initiator socket to which the adapter is
bound.
Constructors
The following constructor is available:
tlm2_gp_initiator_adapter(const std::string&amp; name,
tlm::tlm_base_initiator_adapter<BUSWIDTH>&amp; s)
Creates as initiator adapter and binds it to the TLM2 initiator socket.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
82</p>
</section>
<section id="page-83">
<h2>Page 83<a class="headerlink" href="#page-83" title="Permalink to this heading"></a></h2>
<p>Chapter 3
SCML2 Fast Timed (FT) Modeling
This chapter describes:
•
Introduction to Fast Timed Modeling
•
Modeling Objects
•
Protocol Definitions
•
API Definitions
•
Protocol Checker
•
Protocol Conversion
•
Fast Track Logging in Fast Time Modeling
•
Examples
•
The FT_blocks Library
3.1. Introduction to Fast Timed Modeling
S
C
M
L</p>
<p>m
o
d
e
l
i
n
g
,</p>
<p>i
n
t
r
o
d
u
c
i
n
g
I
n
t
r
o
d
u
c
t
i
o
n</p>
<p>t
o</p>
<p>S
C
M
L</p>
<p>F
T</p>
<p>M
o
d
e
l
i
n
g
S
C
M
L
p
u
r
p
o
s
e
The purpose of Fast Timed (FT) is to enable efficient modeling of virtual prototype components. This is
achieved by encapsulating certain aspects of the FT modeling standard with a generic implementation
covering the most common uses of TLM2.0. FT also provides a number of additional modeling objects
that provide model-to-tool interactivity and a set of reusable timing objects.
The aim of this section is to provide the context for FT modeling by explaining the background for
system-level modeling, TLM, and FT.
•
SystemC Transaction Level Modeling
•
Use Cases
•
Fast Timed Modeling (FTM) Coding Style
•
Modeling Concepts
•
Creating SCML FT Models
SystemC Modeling Library Reference Manual
X-2025.06-SP1
83</p>
</section>
<section id="page-84">
<h2>Page 84<a class="headerlink" href="#page-84" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
3.1.1. SystemC Transaction-Level Modeling
The background to FT modeling stems from the desire to create an abstract model for an embedded
systems design or an MPSOC so that software engineers, system architects, and verification engineers
can start working on the design ahead of the actual system, prototype, or RTL design. For this purpose,
SystemC was developed. SystemC is a C++ library containing a set of classes to model system
components and their communication interfaces, plus a co-operative multitasking environment to model
concurrent activity in a system. Executing the SystemC model allows to simulate the embedded design
or MPSOC.
T
L
M
d
e
s
c
r
i
p
t
i
o
n
Next to this basic functionality, a Transaction Level-Modeling (TLM) library was also developed. This
library supports a modeling style where the abstraction for the communication interfaces between
system components is not based on the individual wires or wire vectors but on function calls between
components and a payload representing the full semantics of the communication interface. This results
in a reduction of the number of synchronization points between component models, which improves
the overall simulation speed. TLM2.0 provides a standard set of APIs and payload constructs to create
memory-map-based TLM models.
There are many ways of using SystemC and TLM2.0 to build abstract models for an embedded
design or MPSOC: Software engineers, system architects, and verification engineers have different
requirements for the abstract model they need to perform their design task; and there are different
approaches to create a model according to these requirements. Therefore, a standardized modeling
style is required. Such a modeling style is based on use cases, coding style, and modeling objects and
interfaces.
•
Use cases identify the purpose for building a model and define what a user wants to achieve with the
platform. They define the requirements for accuracy, speed, visibility, tool interaction, and so on.
•
This manual focuses on the use of SystemC, TLM2.0, and FT for the creation of virtual prototype
models.
•
SystemC, TLM2.0, and FT provide the C++ modeling objects: the mechanisms, interfaces, and
semantics to create these models.
The following figure - taken from the TLM2.0 introduction presentation - shows the relation between use
cases, coding style, and TLM2.0 modeling objects.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
84</p>
</section>
<section id="page-85">
<h2>Page 85<a class="headerlink" href="#page-85" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 4: Relation Between Use Cases, Coding Style, and TLM2.0 Modeling Objects
3.1.2. Use Cases
u
s
e</p>
<p>c
a
s
e
s
When creating a model for an embedded system, the first question that should be asked is what the use
case for the model will be. This will determine which specific type of modeling style should be followed.
SCML supports a modeling style to create platform models that supports several use cases.
•
e
m
b
e
d
d
e
d</p>
<p>s
o
f
t
w
a
r
e</p>
<p>d
e
v
e
l
o
p
m
e
n
t</p>
<p>u
s
e</p>
<p>c
a
s
e
Embedded software development use case
In this use case, a virtual prototype is created that models (part of) an embedded system containing
one or more processors, possibly running one or multiple OSes to allow the development of
applications, middleware, or software drivers. This use case also covers certain aspects of the
software performance use case shown in figure SystemC Transaction-Level Modeling.
Such a model should provide enough details of the hardware system so that it is possible to validate
the functional correctness of the software being developed.
Another key aspect of a virtual prototype model is that it should provide an efficient use model
for the software developer. This means that, although it is a model for the system hardware, it
should allow interactive software debugging and have enough debug and analysis visibility for
software development. In a virtual prototype model, hardware functionality can be limited to what
is visible or important for the software development; this means that behavior and timing of the
SystemC Modeling Library Reference Manual
X-2025.06-SP1
85</p>
</section>
<section id="page-86">
<h2>Page 86<a class="headerlink" href="#page-86" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
different hardware components should be present but not detailed. For a virtual prototype model, it is
important that the following aspects are covered:
◦
The memory and memory-mapped register layout and content.
◦
How software interaction with memory-mapped registers influences their content or the content of
other memory-mapped registers.
◦
It is also important to have an indication of the frequency of the hardware interactions with
software (through interrupts, timers, and so on) and how fast register content is updated.
Virtual prototypes are developed to have a model available ahead of the actual hardware. It is
important that virtual prototypes can be created quickly and can be maintained to stay in sync with
the hardware development. Virtual prototypes are an alternative to the actual hardware since they
provide much more control and visibility into the operation of the system.
•
Software optimization and evaluation use case:
In this use case, the virtual prototype model of an embedded system that is described for the
previous use case is further extended to provide performance data of software execution so that
decisions can be made with regards to software optimization and the evaluation of performance
constraints. The virtual prototype model needs to be extended with additional timing details to
support this use case. This affects the processor model as well as the memory subsystem plus any
other timing critical components. It also implies that the model is further enhanced to contain all
necessary functional detail to make these performance metrics relevant, for example, the processor
pipeline needs to be modeled, as well as instruction and data-caches, any cache coherency
strategies that are employed by the system and so on.
On the other hand, this use case does not require the same level of interactive software debugging
and analysis as for the development use case. This allows to relax the simulation speed
performance requirements, or in different words: since the additional detail does not allow to
maintain the same level of simulation performance, it is better to configure the virtual prototype
model so that this detail can be left out whenever the focus is on software development, and only
have these details activated for batch processing.
For this extended virtual prototype, it is important to cover the following aspects on top of what is
listed for the embedded software development use case:
◦
Instruction execution timing, including the effects of the processor pipelining on the progress of
software execution.
◦
Processor memory interface including caches, cache coherency strategies, pre-fetch buffers
and other processor architecture aspects that are added to optimize the software execution
performance.
◦
Interconnect and memory timing: it is important to see the impact of the memory hierarchy on
the software execution, as well as the impact of resource contention in case of a multiprocessor
system.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
86</p>
</section>
<section id="page-87">
<h2>Page 87<a class="headerlink" href="#page-87" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
•
Architecture exploration and HW-SW validation use cases:
These use cases are closely related to the one described for software optimization and evaluation.
The difference is that they rely on an even more accurate representation of the overall platform.
For example the Architecture exploration use case may use a more accurate representation of the
memory subsystem to evaluate individual configuration trade-offs for the interconnect architecture
and memory controllers, the same holds for cache sizing and other architecture parameters.
Basically the requirements for this use case is to have additional flexibility in the model and possibly
some additional timing accuracy, but for all practical purposes the modeling style and guidelines for
these use cases coincide with the requirements for the software optimization and evaluation use
case and will not be treated separately in this document.
Other use cases for SystemC are (these are not addressed further in this manual):
•
f
u
n
c
t
i
o
n
a
l</p>
<p>s
p
e
c
i
f
i
c
a
t
i
o
n</p>
<p>u
s
e</p>
<p>c
a
s
e
Functional specification
In this use case, SystemC is used to create a model of a system to validate and/or analyze the
interaction of various functional components of the system before they are mapped to a hardware
implementation. SystemC provides a co-operative multitasking environment that allows modeling the
synchronization of various system components. The focus of this use case is on the synchronization
points of the different functional components of a system and (possibly) the relative timing of these
components. In most cases, timing is left out as these models would be used to determine the
functionality of a system. FT and TLM2.0 provide little help for this use case.
•
a
r
c
h
i
t
e
c
t
u
r
e</p>
<p>a
n
a
l
y
s
i
s</p>
<p>u
s
e</p>
<p>c
a
s
e
Architecture analysis
In this use case, a model for a system is created to explore different alternative implementations
for the system. The focus is either on the dimensioning and optimization of the interconnect and
memory subsystem, or on the mapping of functional components on different processing elements
and the consequences that has on the interconnect and memory configuration. For this purpose,
an accurate model of the interconnect is required so that the impact of different configurations and
mappings can be analyzed. This implies that more timing accuracy (typically cycle-accurate models)
as well as all behavior of the interconnect and memory subsystem should be modeled. Still it is
possible to use abstract models for the initiator and target models in the system, possibly reuse
some of the models created for a virtual prototype. FT and TLM2.0 are key to the development of
such a platform model.
•
h
a
r
d
w
a
r
e</p>
<p>v
e
r
i
f
i
c
a
t
i
o
n</p>
<p>u
s
e</p>
<p>c
a
s
e
Hardware verification
The goal of this use case is to verify the actual RTL for a subsystem or a system component in
the wider context of the embedded system. The SystemC models typically represent processor
components or traffic generators that provide the test vectors for the part of the system that is tested.
The execution of the subsystem or system component is done through an RTL simulator, emulator,
or FPGA board. For this use case, models from the virtual prototype for software development can
be reused.
Each of the use cases require to build a specialized model of the platform that is targeted. When
creating the models for the individual components of the platform, it is tempting to create a dedicated
model, specially crafted for the current design task. However, this should not be generalized. The speed
and accuracy requirements of the use cases drive the need for specially crafted interconnect models
SystemC Modeling Library Reference Manual
X-2025.06-SP1
87</p>
</section>
<section id="page-88">
<h2>Page 88<a class="headerlink" href="#page-88" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
and to a lesser extend the need for specialized models for memory controllers, processors, DMA, and
so on. Many initiator and target models can be developed so that the model or parts of it can be reused
between design tasks. Alternatively, a reuse-based modeling methodology also implies that the coding
style allows extending a model when reusing it for a design task where more detail is required. Or even
more: to create a model that can be configured to have more or less details depending on the design
task at hand. Overall SCML targets a modeling style that allows to configure component models to the
design task at hand or even to support runtime configurability so that the simulation can be tuned to
provide the right level of accuracy for each piece of software individually.
3.1.3. Fast Timed Modeling (FTM) Coding Style
After the use case is known, it is possible to apply FT to create a model for this use case. For maximal
efficiency, a common approach needs to be defined to apply FT to the use case. A coding style defines
a standard approach to use the mechanisms provided by the modeling libraries in such a way that the
requirements of the use case are met as efficient as possible. The IEEE Std 1666 TLM-2.0 Language
Reference Manual identifies the following coding styles:
•
L
T
d
e
s
c
r
i
p
t
i
o
n
c
o
d
i
n
g</p>
<p>s
t
y
l
e
s
L
T
Loosely Timed (LT): a coding style that aims to maximize the simulation speed of a model providing
synchronization at the level of the different embedded software threads that are being executed in a
system.
•
A
T
d
e
s
c
r
i
p
t
i
o
n
c
o
d
i
n
g</p>
<p>s
t
y
l
e
s
A
T
Approximately Timed (AT): a coding style that focuses on the timing of the data transactions
between different initiators in a system, by providing multiple timing points for each transaction.
LT and AT are described as coding styles, but obviously they also relate to different abstraction levels,
typically an LT coding style leads to a higher level of abstraction with less timing details, while the AT
coding style can be used to create very detailed and accurate models.
The FT coding style encapsulates both the LT and AT styles. It is defined so that the software
optimization and evaluation use case as well as the architecture exploration and HW-SW validation
use cases can be addressed. This coding style is based on the TLM2.0 requirement that every model
interface always has to support both the LT and AT interface styles. In essence this makes the LT and
AT coding style sub-styles of the FT modeling style. Originally in the TLM2.0 standard it is assumed that
while every component is required to support both interface styles it only code against one coding style
and therefore very likely support only one abstraction level. The FT modeling style allows both styles
to coexist next to each other for those components that are critical to the overall accuracy and speed
of the system. A component modeled in the FT modeling style in most cases is coded following the LT
coding style, when more accuracy might be needed the FT modeling style allows to extend this with an
AT style so that a single model can support all use cases.
FT further refines this with the principle of separating communication, behavior and timing to create
a coding style that supports all use cases. It also provides with modeling objects that provide TLM2.0
standard compatible extensions that support the timing accuracy requirements of the use cases while
maintaining the interoperability features of the standard.
FT adds modeling objects that provide an implementation of the key TLM2.0 semantics but also take
care of handling the speed and visibility requirements of the use case. When developing the model of a
platform component, it is important to create the model so that each of these aspects is an independent
element, or in other words: that the model is decomposed into orthogonal properties. The following
SystemC Modeling Library Reference Manual
X-2025.06-SP1
88</p>
</section>
<section id="page-89">
<h2>Page 89<a class="headerlink" href="#page-89" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
figure illustrates this coding style. Each element in the figure represents a modeling object or a piece of
user code for a target component model.
Figure 5: Coding Style
The following explains the separation of communication, behavior, and timing in detail:</p>
<ol class="arabic simple">
<li><p>Separating the interface to the interconnect model from the actual behavior of the component.
As mentioned in Use Cases, interconnect models typically target a specific use case, and come
with their own specialized refinement for the communication interfaces. However, for the actual
behavior of the component, a generic TLM2.0 memory-mapped bus interface can be used. The
standard defines a generic protocol which is independent of any actual interconnect implementation.
The standard provides an extension mechanism to define proprietary protocols based on TLM2.0.
The interface between the extended protocol and the generic TLM2.0 protocol used by the SCML
storage objects is done by a protocol adaptation layer.</p></li>
<li><p>The actual behavior of the component can be separated into a storage and synchronization layer
(the internal registers or buffers) and the pure functional behavior of the model (the algorithm or
state machine of the component). The storage and synchronization layer communicates through
the generic TLM2.0 interface to the protocol adaptation layer and provides an entry point to the
component model.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
89</p></li>
</ol>
</section>
<section id="page-90">
<h2>Page 90<a class="headerlink" href="#page-90" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
3. Finally, the different needs in timing accuracy can be addressed by separating the code that models
the timing of the component from the pure functional behavior. This can be achieved in one of the
following ways (in increasing order of effort and accuracy that can be obtained):
a. Annotating timing in the storage and synchronization layer
b. Implementing explicit timing annotation in the functional behavior based on the state component
c. Using a specialized protocol adapter layer that implements explicit timing annotation based on
the internal state of the component
FT supports this separation by providing modeling objects for each of these layers.
The FT Modeling style is based on the TLM2.0 APIs. The modeling style defines a set of model
interfaces that are compatible with the TLM2.0 Base Protocol. The standard interfaces are enhanced
by adding extensions to model HW-protocol-specific attributes and supports additional timing points
for increased temporal accuracy. The FT modeling style also defines a set of modeling rules to ensure
a consistent modeling style that provides ease of modeling and ensures a consistent, deterministic
behavior. The whole modeling style is setup such that the approach is scalable to support any number
of HW protocols without losing interoperability between components that use different protocols or are
using them at a different abstraction level (LT versus AT coding style).
A first key aspect of the FT modeling style is that it ensures a consistent and deterministic behavior.
This aspect is built on the following modeling rules which are defined for the FT modeling style:</p>
<ol class="arabic simple">
<li><p>Rule-1: All inputs (for example, events, signals or interface method calls) are annotated with the time
at which they are received:
input_received_time = sc_time_stamp() + local_time
where, local time  is the temporally decoupled time of the model (or the timing annotation of the
TLM interface calls).</p></li>
<li><p>Rule-2: Outputs (that is, events, signals and interface method calls) can be driven with any time
annotation (possibly zero) as a result of a state change.
These are the basic rules for any component, interface or modeling object of the FT Modeling style.
The second key aspect of the FT modeling style is that it maintains interoperability between
components of different abstraction level or sub-style (AT or LT coding styles) and also components
that are coded for different HW protocols. This is enabled by the fact that the FT modeling interfaces
are defined as an extension to the TLM2.0 base protocol. The reuse of the TLM2.0 standard allows
one modeling style for both the architecture exploration and software development use cases which
maximizes model reuse. It also offers high flexibility to choose trade-offs between speed and accuracy
at run-time. Most of all it reduces the need for transactors, it is always possible to fall back to the
TLM2.0 base protocol semantics and the FT modeling style objects provide with automated protocol
conversion when connecting models coded for a different HW protocol.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
90</p></li>
</ol>
</section>
<section id="page-91">
<h2>Page 91<a class="headerlink" href="#page-91" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
3.1.4. Modeling Concepts
m
o
d
e
l
i
n
g</p>
<p>o
b
j
e
c
t
s
c
o
n
c
e
p
t
s
SystemC, TLM2.0, and FT provide a wide range of APIs and modeling objects. For a detailed overview
of these libraries, see the manuals mentioned in References. To get started with SCML modeling for
virtual prototypes, it suffices to understand the following concepts that are represented by the library
elements:
m
o
d
u
l
e
s
,</p>
<p>d
e
f
i
n
i
t
i
o
n
Module
SystemC provides the sc_module  base class to enable hierarchical modeling of a
system. It represents a component of a system. When a module is defined, it can
be instantiated. A module can contain instances of other modules.
s
o
c
k
e
t
s
,</p>
<p>d
e
f
i
n
i
t
i
o
n
Sockets
TLM2.0 and FT provide socket objects to model the communication between
modules. Initiator sockets initiate communication, while target sockets receive
communication requests. In some cases, target sockets may also initiate
transactions (such as Snoop and Credits). Sockets carry a protocol, which is
a combination of payload and phases. Modules can have multiple sockets.
Connections between instances of modules are created by binding sockets.
i
n
t
e
r
f
a
c
e
s
d
e
f
i
n
i
t
i
o
n
Interface
Interfaces are the bases for TLM modeling. An interface defines the
communication API used by a socket. TLM2.0 defines two basic communication
interfaces; sockets need to provide both interfaces:
•
i
n
t
e
r
f
a
c
e
s
b
l
o
c
k
i
n
g
Blocking interface: An initiator calls this interface API and a target implements
the API. All communication is expected to happen during this single function
call. These interfaces are used in the LT coding style of TLM2.0.
•
p
h
a
s
e
s
,</p>
<p>d
e
f
i
n
i
t
i
o
n
i
n
t
e
r
f
a
c
e
s
n
o
n
b
l
o
c
k
i
n
g
Nonblocking interface: In this case, multiple function calls can be used to
model a single data exchange between initiator and target. Both initiator and
target can call this interface. Each call to a nonblocking interface has a phase
associated with it. Phases are labels for the different time points used to
model a transaction. Nonblocking interfaces are used in the AT coding style of
TLM2.0.
p
a
y
l
o
a
d
,</p>
<p>d
e
f
i
n
i
t
i
o
n
Payload
Interfaces carry a payload that contains information about the type of data
transaction, as well as the data to be communicated. TLM2.0 provides a generic
memory-mapped bus payload. When creating a payload that represents a specific
interconnect protocol, the additional information that is not represented in the
generic payload of TLM2.0 is added through payload extensions. This is an array
of additional data elements for the transaction payload.
p
i
n
s
,</p>
<p>d
e
f
i
n
i
t
i
o
n
Pin
To model simple communication, SystemC provides ports, which are typically
used to model pins. Ports are connected through channels that implement the
communication behavior. Typically signals are used which represent a vector
of data that is exchanged. In the SCML modeling style these are used to model
single-bit values, for example, for interrupts or clocks.
a
d
a
p
t
o
r
s
,</p>
<p>d
e
f
i
n
i
t
i
o
n
t
r
a
n
s
a
c
t
o
r
,</p>
<p>d
e
f
i
n
i
t
i
o
n
Transactor,
adaptor
TLM2.0 forbids the connection of sockets that carry different protocols. To make
the transition from one protocol to another, transactors are used. These are
modules that take care of the protocol conversion. An adaptor has a similar
function but it is internal to a module. In FT, transactors are automatically inserted
by protocol conversion logic, if available.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
91</p>
</section>
<section id="page-92">
<h2>Page 92<a class="headerlink" href="#page-92" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
m
e
t
h
o
d
s
,</p>
<p>d
e
f
i
n
i
t
i
o
n
t
h
r
e
a
d
s
,</p>
<p>d
e
f
i
n
i
t
i
o
n
Thread, method
To model concurrent behavior, SystemC provides a multitasking kernel with
processes. The execution model is co-operative, which means that a process
cannot be interrupted or pre-empted by another process.
• A thread is a process that runs forever and suspends itself and thus hands
control back to the multitasking kernel by calling wait() . This allows the kernel
to switch to another process. When the kernel switches back to the current
thread, it will resume with the statements after the wait()  call.
• A method is a process that executes a function only once. The kernel will
execute the method whenever the sensitivity associated with the method is
triggered. This sensitivity is defined by event objects. A method cannot be
suspended with a wait()  call.
t
i
m
e
,</p>
<p>d
e
f
i
n
i
t
i
o
n
Time
To model time advances in a system, the SystemC kernel provides a global time
parameter. Threads can be suspended for certain time; events can be triggered at
a certain (future) time point.
c
l
o
c
k
s
,</p>
<p>d
e
f
i
n
i
t
i
o
n
Clock
A clock is a SystemC object that contains an event that is triggered at a certain
specified rate. It is used to reflect the synchronous behavior of hardware elements
in a system. A clock is used to model fine-grain synchronization. SCML provides
specialized clock objects with better simulation performance.
t
e
m
p
o
r
a
l</p>
<p>d
e
c
o
u
p
l
i
n
g
d
e
f
i
n
i
t
i
o
n
Temporal
decoupling
The TLM2.0 standard provides a modeling style where different concurrent
processes in a system do not synchronize on a clock or on individual data
transactions but are running ahead of the SystemC time and keep a local time
count. In this case, processes will synchronize when a global quantum value is
reached. The quantum represents the system-level synchronization rate for the
design. Processes will also need to synchronize when they cannot process a
transaction request except if another process is run.
D
M
I
d
e
f
i
n
i
t
i
o
n
DMI
Direct Memory Interface. This is a simulation speed optimization provided
by TLM2.0. A system model can have many modules, threads, methods and
functions to model the complete path of a transaction from initiator to target. With
the DMI interface, a target can provide a pointer to its internal data storage for the
initiator to use, thus avoiding all overhead of the transaction model. DMI is to be
used with care but using it can result in a significant speed improvement.
m
e
m
o
r
y
d
e
f
i
n
i
t
i
o
n
Memory
SCML provides a memory object to model data storage in a component (for
example, memory-mapped registers), and to provide interfaces to debug and
analysis tools. The object implements the behavior as specified by the TLM2.0
generic protocol and allows overwriting - or adding - behavior through callbacks
which will be triggered on a transaction request to this memory object. A memory
object defines an array of data elements and can be further refined:
• alias: refers to a subrange in a memory object.
• reg: refers to a subrange of size 1 .
• bitfield: refers to a range of bits within a single data element.
r
o
u
t
e
r
,</p>
<p>d
e
f
i
n
i
t
i
o
n
Router
Is an object provided by the SCML library to model the behavior of caches
and memory controllers, as well as noncontiguous memory ranges. A router
represents a memory-mapped address region through which accesses are done
to data further down the transaction path. A router maps incoming addresses
to other memory objects or to initiator sockets on a module. This mapping can
change during a simulation.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
92</p>
</section>
<section id="page-93">
<h2>Page 93<a class="headerlink" href="#page-93" title="Permalink to this heading"></a></h2>
</section>
<section id="chapter-3-scml2-fast-timed-ft-modeling-p-a-y-l-o-a-d">
<h2>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
P
a
y
l
o
a
d<a class="headerlink" href="#chapter-3-scml2-fast-timed-ft-modeling-p-a-y-l-o-a-d" title="Permalink to this heading"></a></h2>
</section>
<section id="e-v-e-n-t">
<h2>e
v
e
n
t<a class="headerlink" href="#e-v-e-n-t" title="Permalink to this heading"></a></h2>
<p>q
u
e
u
e
,</p>
<p>d
e
f
i
n
i
t
i
o
n
Payload-event-q
ueue (PEQ)
Is a convenience object that allows to model a behavior where multiple
transactions are in progress at the same time, the event queue will sort the
incoming transaction timing points according to their arrival time (which can
include temporal decoupling and timing annotation effects) and provides them for
processing to the model at the appropriate moment.
l
o
g
g
i
n
g
,</p>
<p>d
e
f
i
n
i
t
i
o
n
s
t
a
t
u
s
,</p>
<p>d
e
f
i
n
i
t
i
o
n
c
o
m
m
a
n
d
s
,</p>
<p>d
e
f
i
n
i
t
i
o
n
p
r
o
p
e
r
t
i
e
s
,</p>
<p>d
e
f
i
n
i
t
i
o
n
Property,
command,
status, logging
Are objects provided by SCML that connect a simulation model to the environment
in which the simulation will be run. Properties are configurable parameters of
a component that can be set through the simulation environment. Commands
allow you to interact with the internals of a model from the simulation environment
during run time. Status and logging are modeling objects that provide a link to the
debugging and analysis environment.
m
o
d
e
l
i
n
g</p>
<p>o
b
j
e
c
t
s
c
o
m
b
i
n
i
n
g
When combining these modeling objects according to the FT modeling style, the resulting coding style
looks as shown in the following figure. Each element in the figure represents a modeling object.
Figure 6: Combining Modeling Objects, LT Case
SystemC Modeling Library Reference Manual
X-2025.06-SP1
93</p>
</section>
<section id="page-94">
<h2>Page 94<a class="headerlink" href="#page-94" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 7: Combining Modeling Objects, FT Case
3.1.5. Creating FT Models
Use the Platform Architect Studio tool for authoring TLM models using FT modeling style. The following
steps are typically needed to define and create an FT Model.</p>
<ol class="arabic simple">
<li><p>Specification Study
◦
Begin by reviewing the component’s specification, focusing on the functionality critical to your
use-case.
◦
Identify the features to be modeled and determine configuration options.
◦
For timing details, consult the hardware documentation or, if unavailable, extract information from
RTL or verification tests.</p></li>
<li><p>Interface Definition
◦
Define the model’s interfaces based on the specification.
◦
Use FT sockets ft_initiator_socket  and ft_target_socket  for memory-mapped interfaces
and SCML2 clock interfaces for clock connections. Platform Architect Studio allows creation of
these interfaces using a GUI based flow.</p></li>
<li><p>Register Interface
SystemC Modeling Library Reference Manual
X-2025.06-SP1
94</p></li>
</ol>
</section>
<section id="page-95">
<h2>Page 95<a class="headerlink" href="#page-95" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
◦
Implement the register map (if needed).
◦
If you have an IP-XACT or CSV register description, use Platform Architect Studio to import and
generate the code automatically. It assists in generating the model interface, SCML memory, and
register architecture, allowing you to focus on model behavior.
4. Adding Timing and Behavior
◦
Add timing and behavior, preferably using callback semantics available in Platform Architect
Studio.
◦
For more complex timing or synchronization, consider clocked callbacks or SystemC processes
(SC_METHODS /SC_THREADS).
◦
Validate timing against reference models (RTL) if available or characterize accuracy through
analysis results.
5. Adding Parameters
◦
Define model parameters using PA Studio to impact behavior of the model.
◦
Different types of parameters are supported (such as Integer and String, Double).
3.2. Modeling Objects
This section covers the generic FT modeling extensions to the TLM2.0 base protocol standard. The
different interface modeling APIs are introduced with a short description of their usage.
•
Payloads
•
Sockets
•
Port Adaptors
•
Protocol States
•
Alignment in FT Protocols
3.2.1. Payloads
scml2::ft_generic_payload
The FT modeling style comes with a new payload for transactions. This payload contains the same
attributes and methods as the TLM2.0 base protocol standard payload, but is extended with additional
APIs to access extensions. These APIs have been added to provide a link to the automated protocol
conversion logic.
#define ADDnSET_EXT(payload, ext_type, attr_val)
#define SET_EXT_ATTR(payload, ext_type, attr_val)
#define GET_EXT_ATTR(payload, ext_type, attr_type, attr_inst)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
95</p>
</section>
<section id="page-96">
<h2>Page 96<a class="headerlink" href="#page-96" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The APIs are encapsulated in a set of MACROs  for ease of use.
•
ADDnSET_EXT: Adds the extension to the payload and sets value.
•
SET_EXT_ATTR: Gets the extension from the payload and sets value.
•
GET_EXT_ATTR  Gets the extension value for this payload.
While these MACRO  s provide ease of use, they do not always give the best simulation performance,
for that purpose some of the underlying APIs are interesting to be used:
template &lt;typename extension_type, typename attr_type &gt;
extension_type <em>ft_generic_payload::get_extension_attr(extension_type</em>&amp; tlm2Ext,
attr_type &amp;attr_val)
•
Retrieves the extension with type extension_type  from the payload and extracts the value
attr_val .
•
This API does not do any protocol conversion. This can be used to access the protocol state since
the conversion of this extension always happens in the socket, so no additional conversion checks
are required.
•
The extension pointer (tlm2Ext) can be reused, which avoids another lookup for the extension as
would happen when using the macro’s.
template &lt;typename extension_type, typename attr_type &gt;
void ft_generic_payload::set_extension_attr(extension_type*&amp; tlm2Ext,
attr_type attr_val)
•
Updates the value of the extension with attr_val. Since the TLM2.0 base protocol non-blocking
transport APIs use the standard payload, it is required to do a conversion on the API argument.
ft_generic_payload* get_payload(tlm::tlm_generic_payload *tmp);
•
This does a safe conversion from tlm_generic_payload  to ft_generic_payload.
The TLM2.0 standard advises that transactions are pooled so that the memory management using
reference counting (acquire and release APIs) can be supported. For this purpose, the SCML2
library provides with a generic memory manager that implements the TLM2 standard memory
management interface (claim()  and free()).
scml2::mem_manager<TYPE>
The FT payload relies on a modified extension for the additional APIs listed above. As with the FT
payload, the extension modifications is limited to additional functionality so that full compatibility with the
standard TLM2.0 extensions is maintained.
template &lt;typename extension_type, typename attr_type &gt;
class base_extension: public tlm::tlm_extension&lt;extension_type&gt;
SystemC Modeling Library Reference Manual
X-2025.06-SP1
96</p>
</section>
<section id="page-97">
<h2>Page 97<a class="headerlink" href="#page-97" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The additional features for this extension base class are:
•
Support for memory management. The memory management is fully controlled using the payload so
that there is no need for additional memory management code anywhere in the models.
•
An additional access API with support for protocol conversion. This API allows to reuse an extension
pointer that was accessed using the get_extension_attr  call of the payload. The API sets the
value for the attribute and also checks if there is any protocol attribute conversion that needs to be
maintained.
template &lt;typename extension_type, typename attr_type &gt;
void base_extension::set_attribute(tlm::tlm_generic_payload *payload, attr_type
val)
The SCML2 payload extensions are used to create additional protocols and protocol attributes. They
can also be used to create custom extensions to carry additional information with a transaction, this can
be debugging and analysis information but is not limited to that.
An extension can be defined with the following macro:
DECLARE_EXTENSION(my_extension_type, unsigned int, 0);
The parameters for this extension definition are:
•
The extension type that is created.
•
The type for the attribute that is held in the extension.
•
The default for the attribute (only meaningful for types that support value assignment).
Custom extensions are used in the same way as any predefined extension:
unsigned int my_extension_value;
payload.get_extension_attr(my_extension_type, my_extension_value);
3.2.2. Sockets
Similar to the payload and the extension, also the sockets used in the FT modeling style are an
extended version of the standard TLM2.0 sockets. The following sockets are defined for FT:
scml2::ft_initiator_socket
scml2::ft_target_socket</p>
<p>scml2::simple_initiator_socket
scml2::simple_target_socket
SystemC Modeling Library Reference Manual
X-2025.06-SP1
97</p>
</section>
<section id="page-98">
<h2>Page 98<a class="headerlink" href="#page-98" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
These sockets have additional APIs:
•
set_protocol: It is required to use this API when using any of the protocol-specific extensions
defined for FT modeling. The set_protocol  API indicates the protocol extensions that is used by
this port and is used to drive the automated protocol conversion logic.
•
set_clock: This API should be called by initiators and targets at the end of elaboration to specify
the clock period at which they are operating. This enables accurate tracing by TLM2 Port Trace and
correct checking by Protocol Checker utility, see Protocol Checker.
•
◦
The scml2::ft_xxxx  sockets are similar to the sockets defined in the TLM2.0 standard.
◦
The scml2::simple_xxxx  sockets are similar to the sockets defined in the TLM2.0 utilities. They
should be used when you have multiple ports each requiring a different implementation of the
interfaces. They allow to register any member function of a component as an implementation of
the transport calls (as they have the same argument list).
Note:
•
An FT target should always register methods for both blocking and non-blocking transport calls.
Blocking to non blocking conversion or Non blocking to blocking conversion done by the simple
target socket does not take care of the mapping from GP to FT protocol.
•
Multi pass-through sockets are not supported by Virtualizer.
3.2.3. Port Adaptors
The SCML2 port adaptor objects provide a consistent interface to model device timing regardless of the
underlying bus protocol . The initiator or target object that owns the port adaptor interacts with it using a
simple API and optional callbacks that are registered for each protocol phase of interest.
Port adaptors invoke optional callbacks registered on protocol-agnostic events within the transaction life
cycle.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
98</p>
</section>
<section id="page-99">
<h2>Page 99<a class="headerlink" href="#page-99" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 8: Port Adaptor Events
Dashed transitions shown above are for payloads that have a single beat.
The event IDs map to protocol-specific states, as shown below.
Table 33: Port Adaptor Event ID Mapping Protocol States
Port Adaptor Event ID
TLM2 GP
Phase
AXI Protocol
State
AXI4Stream
Protocol
State
GFT Protocol
State
CHI
CREDIT
LCRE
DIT
BUS_GRANT
CRESP
RD_ADDR_START
BEGIN_REQ
ARVALID
RD_CMD
REQ
RD_ADDR_END
END_REQ
ARREADY
RD_CMD_ACK
RD_DATA_START
RVALID
RD_DATA
RDATA
SystemC Modeling Library Reference Manual
X-2025.06-SP1
99</p>
</section>
<section id="page-100">
<h2>Page 100<a class="headerlink" href="#page-100" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Table 33: Port Adaptor Event ID Mapping Protocol States (Continued)
Port Adaptor Event ID
TLM2 GP
Phase
AXI Protocol
State
AXI4Stream
Protocol
State
GFT Protocol
State
CHI
RD_DATA_END
RREADY
RD_DATA_ACK
RD_DATA_LAST_START
BEGIN_RESP
RVALID_LAST
RD_DATA_LAST
RDATA
RD_DATA_LAST_END
END_RESP
RREADY_LAST
RD_DATA_LAST_
ACK
WR_ADDR_START
BEGIN_REQ
AWVALID
WR_CMD
REQ
WR_ADDR_END
END_REQ
AWREADY
WR_CMD_ACK
WR_DATA_START
WVALID
TVALID
WR_DATA
WDATA
WR_DATA_END
WREADY
TREADY
WR_DATA_ACK
WR_DATA_LAST_START
WVALID_LAST
TVALID_LAST
WR_DATA_LAST
WDATA
WR_DATA_LAST_END
WREADY_LAST
TREADY_LAST
WR_DATA_LAST_
ACK
WR_RSP_START
BEGIN_RESP
BVALID
WR_RSP_END
END_RESP
BREADY
RSP_START
CRE
SP/SR
ESP
RSP_END
SNOOP_ADDR_START
SNP
SNOOP_ADDR_END
SNOOP_DATA_START
WDATA
SNOOP_DATA_END
SNOOP_DATA_LAST_START
WDATA
SNOOP_DATA_LAST_END
SNOOP_RSP_START
SRESP
SNOOP_RSP_END
SystemC Modeling Library Reference Manual
X-2025.06-SP1
100</p>
</section>
<section id="page-101">
<h2>Page 101<a class="headerlink" href="#page-101" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Table 34: Port Adaptor Event ID Mapping Protocol States (Serial Protocols)
Port Adaptor Event
ID
PCIe / CXL.io
(Initiator Socket)
PCIe / CXL.io
(Target Socket)
CXL.mem
(Initiator
Socket)
CXL.mem
(Target Socket)
WR_ADDR_START
WR_DATA_LAST_ST
ART
PCIE_RX_REQ_WITH_
DATA_TLP
PCIE_TX_REQ_WITH
<em>DATA_TLP
CXL_MEM_M2S_RE
Q_WITH_DATA
WR_DATA_LAST_END
WR_RSP_START
PCIE_RX_CPL_TLP
PCIE_TX_CPL_TLP
CXL_MEM_S2M_R
ESP
WR_RSP_END
RD_ADDR_START
PCIE_RX_REQ_TLP
PCIE_TX_REQ_TLP
CXL_MEM_M2S</em>
REQ
RD_ADDR_END
RD_DATA_START
RD_DATA_LAST_ST
ART
PCIE_RX_CPL_WITH_
DATA_TLP
PCIE_TX_CPL_WITH
<em>DATA_TLP
CXL_MEM_S2M_R
ESP_WITH_DATA
RD_DATA_LAST_END
RSP_START
CXL_MEM_S2M_R
ESP
RSP_END
CREDIT
PCIE_RX_P_CREDIT</em>
DLLP
PCIE_TX_P_CREDIT
_DLLP
PCIE_RX_NP_CREDIT
_DLLP
PCIE_TX_NP_CREDI
T_DLLP
PCIE_RX_CPL_CREDI
T_DLLP
PCIE_TX_CPL_CRED
IT_DLLP
TRANSMIT_STATUS
PCIE_RX_DLLP
PCIE_TX_DLLP
Initiators and targets are free to register as many or as few callbacks as they want. For example, a
simple AXI FT  target model could register a callback only for the ARVALID  and AWVALID  states to
implement basic timing for read  and write  access to a SCML2 memory. The port adaptor will handle all
of the AXI FT  complexity including queuing transfers, protocol state transitions and timing annotation.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
101</p>
</section>
<section id="page-102">
<h2>Page 102<a class="headerlink" href="#page-102" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
At each phase of the transaction, one of the following occurs:
•
If no callback is registered, or a callback is registered and it returns TLM_UPDATED , then the adaptor
advances the protocol state and timing annotation internally.
•
If a callback is registered and it returns TLM_ACCEPTED , owner of the callback is responsible to
explicitly advance the protocol state machine by invoking the update_transaction  API.
Port adaptors are constructed as shown below. The adaptor automatically looks up the
ft_protocol_tag  property of the socket to determine which protocol to use. If no such property exists,
the adaptor defaults to TLM2_GP .
// create port adaptor and bind to socket
scml2::ft_target_socket&lt;32&gt; my_socket(“my_socket”);
scml2::target_port_adaptor *my_adaptor =
scml2::target_port_adaptor::create(“my_adaptor”, &amp;my_socket, &amp;pClk);
Timing callbacks are then registered directly on the port adaptor, with an optional user-defined
argument.
SCML2_REGISTER_TIMING_CBK(my_adaptor, scml2::RD_ADDR_END, this, onRD_ADDR_END);
SCML2_REGISTER_TIMING_CBK_WITH_ARG(my_adaptor, scml2::RD_DATA_START, this,
onRD_DATA_START, my_param);
Note:
Channel handshake using *START  and *END  events typically takes one clock cycle. This is also
visible in TLM Port Traces. If no clock is associated with Port Adaptor, then TLM Port Traces may
show a tiny vertical line representing channel handshake.
A target port adaptor may be bound to an SCML2 memory as shown below.
// bind adaptor to memory
scml2::memory my_memory(“my_memory”, 0x100);
(*my_port_adapter)(my_memory);
In this case, timing callbacks may be registered on the memory object in a similar fashion to the normal
storage/behavior callbacks.
scml2::set_timing_callback(my_memory, scml2::WR_ADDR_START, this, &amp;onWR_ADDR_START);
Behavior callbacks may also be registered on the memory object as normal. The target port adaptor
will automatically invoke the behavior callback at the appropriate point in the transaction; BEGIN_REQ  for
TLM2_GP  protocols , and RD_ADDR_START  and WR_DATA_LAST_START  events for AXI  and GFT.
scml2::set_callback(my_memory, SCML2_CALLBACK(onRead), scml2::SELF_SYNCING);
Timing callbacks are always NEVER_SYNCING. Behavior callbacks may be AUTO_SYNCING,
SELF_SYNCING  or NEVER_SYNCING  as normal. The port adaptor will automatically convert non-blocking
transports to blocking if the SCML2 memory behavior callback is not NEVER_SYNCING.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
102</p>
</section>
<section id="page-103">
<h2>Page 103<a class="headerlink" href="#page-103" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The SCML memory bound to the port adaptor must not mix NEVER_SYNCING  behavior callbacks with
AUTO_SYNCING  and SELF_SYNCING  callbacks. For example, if there are registers accessed through the
SCML memory that use AUTO  or SELF SYNCING  behavior callbacks, the SCML memory must also use
an AUTO  or SELF SYNCING  callback.
More than one SCML memory may be bound to the target port adaptor, in which case a select callback
should be registered to determine which memory is accessed by a given payload.
Port adaptors may be configured using named attributes and the set_attribute  API. This provides
a basic level of timing configurability that may be suitable for simple devices. The timing attributes
are only used when a clock has been bound to the adaptor, and when the registered callback for the
relevant event returns tlm::TLM_UPDATED, indicating that the port adaptor should advance the protocol
state internally. If the registered callback returns tlm::TLM_ACCEPTED, the user model is responsible for
updating the timing annotation.
The table below lists the attribute names and default values for initiator port adaptors.
Table 35: Attribute Names and Default Values for Initiator Port Adaptors
Property Name
Description
Protocol
TLM2_GP
AXI
AXI4
Stream
GFT
CHI
invoke_timing_cbks
Controls whether timing
callbacks are invoked
(whether registered or not).
Possible values are:
• FT only ( -1 )
• Never ( 0 )
• LT and FT ( 1 )
-1
-1
-1
-1
read_capacity
Maximum number of
outstanding read  and
write  transactions that
may be issued on the
initiator socket(AXI  only).
Additional transactions
will be buffered by the
adaptor and sent as
soon as an outstanding
transaction completes. Set
to -1  to disable maximum
transaction limits.
read_capacity  and
write_capacity
are ignored when
total_capacity  is
non-zero.
-1
SystemC Modeling Library Reference Manual
X-2025.06-SP1
103</p>
</section>
<section id="page-104">
<h2>Page 104<a class="headerlink" href="#page-104" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Table 35: Attribute Names and Default Values for Initiator Port Adaptors (Continued)
Property Name
Description
Protocol
write_capacity
Maximum number of
outstanding read  and
write  transactions that
may be issued on the
initiator socket(AXI  only).
Additional transactions
will be buffered by the
adaptor and sent as
soon as an outstanding
transaction completes. Set
to -1  to disable maximum
transaction limits.
read_capacity  and
write_capacity
are ignored when
total_capacity  is
non-zero.
-1
-1
total_capacity
Maximum number of
outstanding read  and
write  transactions that
may be issued on the
initiator socket(AXI  only).
Additional transactions
will be buffered by the
adaptor and sent as
soon as an outstanding
transaction completes. Set
to -1  to disable maximum
transaction limits.
read_capacity  and
write_capacity
are ignored when
total_capacity  is
non-zero.
1
0
0
1
rd_data_accept_cycles
Number of clock cycles
to accept each read  data
beat.
0
0
0
wr_data_trigger_cycles
Number of clock cycles to
be inserted before each
write  data beat.
0
0
0
wr_rsp_accept_cycles
Number of clock cycles to
accept the write  response.
0
0
SystemC Modeling Library Reference Manual
X-2025.06-SP1
104</p>
</section>
<section id="page-105">
<h2>Page 105<a class="headerlink" href="#page-105" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Table 35: Attribute Names and Default Values for Initiator Port Adaptors (Continued)
Property Name
Description
Protocol
handle_tkeep
When set to a non-zero
value, the port adaptor will
automatically generate
the tkeep  array extension
based on the bus width
and transaction burst size.
When set to 0, the user
model is responsible for
setting up the tkeep  array
extension (AXI4Stream
only).
1
dba_supported
When set to 1, port adaptor
will use DBA (data beat
array) extensions if
supported by the target.
0
0
max_beats
Maximum number of
beats in a transaction
issued by the port
adaptor. Transaction that
exceed this value will be
automatically split.
256
auto_send_credits
Controls whether port
adaptor automatically
sends L-Credits to the
target as soon as they
available.
1
req_lcredits
(read-only) Number of
request L-Credits currently
available.
chi_version
Specifies the CHI version
to be used by the initiator.
B
src_id
Specifies the source id
of the initiator (Request
Node).
0
dct_int
Specifies whether Direct
Cache Transfer (DCT) is to
be used as hint by Request
Node (RN). It should be set
only when chi_version  is
E. Snoop transactions with
DCT will be processed as
normal Snoop transactions,
if set.
0
SystemC Modeling Library Reference Manual
X-2025.06-SP1
105</p>
</section>
<section id="page-106">
<h2>Page 106<a class="headerlink" href="#page-106" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Table 35: Attribute Names and Default Values for Initiator Port Adaptors (Continued)
Property Name
Description
Protocol
wdata_lcredits
(read-only) Number of write
data L-Credits currently
available.
sresp_lcredits
(read-only) Number of
snoop response L-Credits
currently available.
max_lcredits
Specifies the maximum
number of L-Credits sent at
start of simulation.
2
try_dmi_for_b_transport
Optimize b_transport()
calls by using DMI for
these calls.
Possible values are:
• Optimization Enabled (1,
Default)
• Optimization Disabled
(0)
1
1
1
1
1
write_data_interleaving
Set write data interleaving
support on AXI Initiator
Port Adaptor.
Possible values are:
• Interleaving disabled (0)
• Interleaving enabled (1)
• Legacy behavior (2,
Default)
2
The table below lists the attribute names and default values for target port adaptors.
Table 36: Attribute Names and Default Values for Target Port Adaptors
Property Name
Description
Protocol
TLM2_GP
AXI
AXI4
Stream
GFT
CHI
invoke_timing_cbks
Controls whether timing
callbacks are invoked
(whether registered or not).
Possible values are:
• FT only ( -1 )
• Never ( 0 )
• LT and FT ( 1 )
-1
-1
-1
-1
SystemC Modeling Library Reference Manual
X-2025.06-SP1
106</p>
</section>
<section id="page-107">
<h2>Page 107<a class="headerlink" href="#page-107" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Table 36: Attribute Names and Default Values for Target Port Adaptors (Continued)
Property Name
Description
Protocol
invoke_behavior_cbks
Controls whether the
behavior callback
(b_transport  on bound
mappable_if) is invoked
by the port adaptor.
1
1
1
1
read_capacity
Maximum number of
outstanding read  and
write  transactions that
will be accepted by the
target adaptor (AXI  only) .
Additional transactions
will be buffered and
not accepted until an
outstanding transaction
completes. Set to -1
to disable maximum
transaction limits.
read_capacity  and
write_capacity
are ignored when
total_capacity  is
non-zero.
-1
write_capacity
Maximum number of
outstanding read  and
write  transactions that
will be accepted by the
target adaptor (AXI  only) .
Additional transactions
will be buffered and
not accepted until an
outstanding transaction
completes. Set to -1
to disable maximum
transaction limits.
read_capacity  and
write_capacity
are ignored when
total_capacity  is
non-zero.
-1
-1
SystemC Modeling Library Reference Manual
X-2025.06-SP1
107</p>
</section>
<section id="page-108">
<h2>Page 108<a class="headerlink" href="#page-108" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Table 36: Attribute Names and Default Values for Target Port Adaptors (Continued)
Property Name
Description
Protocol
total_capacity
Maximum number of
outstanding read  and
write  transactions that
will be accepted by the
target adaptor (AXI  only) .
Additional transactions
will be buffered and
not accepted until an
outstanding transaction
completes. Set to -1
to disable maximum
transaction limits.
read_capacity  and
write_capacity
are ignored when
total_capacity  is
non-zero.
1
0
0
1
rd_cmd_accept_cycles
Number of clock cycles to
accept a read  address.
0
0
0
rd_data_trigger_cycles
Number of clock cycles to
be inserted before each
read  data beat.
0
0
wr_cmd_accept_cycles
Number of clock cycles to
accept a write  address.
0
0
0
wr_data_accept_cycles
Number of clock cycles to
accept each write  data
beat.
0
0
wr_rsp_trigger_cycles
Number of clock cycles to
be inserted before write
response.
0
0
req_accept_cycles
Number of clock cycles to
accept a bus request (GFT
only).
0
SystemC Modeling Library Reference Manual
X-2025.06-SP1
108</p>
</section>
<section id="page-109">
<h2>Page 109<a class="headerlink" href="#page-109" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Table 36: Attribute Names and Default Values for Target Port Adaptors (Continued)
Property Name
Description
Protocol
collect_databeats
When set to non-zero
value, the port adaptor
will collect the data and
byte_enables  for each
beat into a single buffer
respectively which will be
available at the start of
the last write data beat
(WR_DATA_LAST_START
event). When set to
0, only the data and
byte_enables  of the
last beat will be available
(AXI4Stream  only).
1
dba_supported
When set to 1, port adaptor
will use DBA (data beat
array) extensions if
supported by the target.
0
0
auto_behavior
Controls when the bound
mappable_if::b_transp
ort  callback is invoked.
For more details, see
description of the
target_port_adaptor
bind to mappable_if
method.
0
0
0
0
auto_send_credits
Controls whether port
adaptor automatically
sends L-Credits to the
initiator as soon as they
available.
1
snp_lcredits
(read-only) Number of
snoop L-Credits currently
available.
rdata_lcredits
(read-only) Number of read
data L-Credits currently
available.
cresp_lcredits
(read-only) Number of
CRESP  L-Credits currently
available.
chi_version
Specifies the CHI version
to be used by the target.
B
SystemC Modeling Library Reference Manual
X-2025.06-SP1
109</p>
</section>
<section id="page-110">
<h2>Page 110<a class="headerlink" href="#page-110" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Table 36: Attribute Names and Default Values for Target Port Adaptors (Continued)
Property Name
Description
Protocol
dmt_enabled
Specifies whether Direct
Memory Transfer (DMT) is
enabled at the Slave Node
(SN).
1
max_lcredits
Specifies the maximum
number of L-Credits sent at
start of simulation.
2
User models are free to use protocol-specific SCML2 transaction extensions, or custom extensions as
required. The port adaptors also make use of the following generic extensions:
Table 37: Extensions
Extension
Description
scml2::trans_id_extension
This extension should be set by the initiator model before
calling send_transaction. For protocols that supported it,
read  and write  data may be interleaved for payloads with
different trans_id  (AXI, AXI4Stream). If read  or write  data
is provided for a payload by calling update_transaction,
and another payload with the same trans_id  has already
started sending data, the new payload data will not be sent
until all of the previous payload data phases have completed.
If not unique already, CHI  initiator port adaptors will
automatically override the trans_id_extension  to a value
not already in use by other active transactions.
scml2::burst_size_extension
This extension should be set by the initiator model before
calling send_transaction. The burst size, address, and
data_length  of the payload determine the number of beats.
scml2::can_accept_data_beat_arr
ay_extension
This extension is set by the initiator or target port adaptor
during the address phase of the transaction. For protocols
that support burst timing, the extension will be set to true
by the port adaptor if the payload has more than one
beat and no RD_DATA_END  or WR_DATA_END  callback has
been registered.The user model may set the extension
manually to force use of data beat array timing, before the
WR_ADDR_START  or RD_ADDR_END  events respectively.
scml2::data_beat_avail_extens
ion
This array extension is set by sending port adaptor to indicate
the clock cycle at which each data beat begins.
scml2::data_beat_used_extension This array extension is set by the receiving port adaptor to
indicate the clock cycle at which each data beat completes.
scml2::beat_index_extension
This extension is set by the initiator or target port adaptor
before invoking a registered timing callback. The extension
value indicates the index of the current data beat.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
110</p>
</section>
<section id="page-111">
<h2>Page 111<a class="headerlink" href="#page-111" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Initiators may set the size of the burst explicitly by setting scml2::burst_size_extension  on the
payload before calling send_transaction. The burst size will not be changed by the port adaptor, but
byte_enables  may be inserted if required to comply with the alignment requirements of the underlying
protocol. If the burst_size_extension  is not set, or set to 0, the initiator port adaptor will select an
appropriate burst size based on the bus width and start address alignment.
Initiators
initiator_port_adaptor* create(const std::string&amp; name, socket_type* socket,
sc_in<bool>* clk=NULL)
initiator_port_adaptor* create(socket_type* socket, sc_in<bool>* clk=NULL)
This static member function creates a new initiator port adaptor and binds it to the socket. You
may supply a name for the new port adaptor object explicitly using the name  argument or have
the port adapter named automatically. The protocol for the adaptor is selected using the socket
ft_protocol_tag  property, or TLM2_GP, if the property does not exist. If you specify a clock
pointer using the optional clk  argument, the clock port will be bound to the adaptor at the end
of elaboration. The supported protocols are TLM2_GP, AXI, GFT, AXI4Stream, and CHI .
void operator()(scml_clock_if* clk)
Binds a clock interface to the adaptor at end_of_elaboration . This is required to make use of
the timing attributes, and will allow the adaptor to handle dynamic clock period changes.
template &lt;class ObjT, typename FuncT&gt;
void set_clock_changed_callback(ObjT* obj, FuncT func)
Sets callback to be invoked, if the clock period of the clock bound to the port adaptor changes.
sc_time clock_cycles_to_time(unsigned int cycles)
Convenience API to convert the given number of clock cycles to sc_time  using the bound clock
interface.
std::string get_protocol()
Gets the protocol in use by the adaptor.
void set_attribute(const std::string&amp; name, int value)
Sets a name-value  attribute on the port adaptor. This is used to set protocol-specific
parameters on the port adaptor.
int get_attribute(const std::string&amp; name)
Gets the value of the named attribute.
void set_timing_callback(callback_event_enum event_id, timing_callback_base* cb)
Registers a callback function for a particular phase in the transaction life cycle. The callback
function object can be created using scml2::create_timing_callback  API. A convenient
macro is also provided to simplify the syntax:
SCML2_REGISTER_TIMING_CBK(adaptor, event_id, obj, func)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
111</p>
</section>
<section id="page-112">
<h2>Page 112<a class="headerlink" href="#page-112" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The callback function should return tlm::TLM_UPDATED  to indicate that the port adaptor
should advance the protocol state internally, or tlm::TLM_ACCEPTED  to stall the transfer until
update_transaction  is invoked with updated timing annotation and protocol state.
scml2::callback_event_enum get_event_id(unsigned int protocol_state)
Lookup callback event ID from protocol-specific state.
bool has_callback(scml2::callback_event_enum state_id)
Convenience API to check if there is any callback registered for a particular protocol phase.
unsigned int get_bus_width()
Gets the width of the bus in bytes .
unsigned int get_unique_trans_id()
Returns the smallest transaction ID that is not already in use by an outstanding transaction.
void enable_dmi()
Enables DMI for LT transfers. The port adaptor uses LT ( b_transport )
or FT ( nb_transport_fw ) depending on the value of the
scml2::timing_abstraction_level_switch .
void disable_dmi()
Disables DMI for LT transfers. The port adaptor uses LT ( b_transport )
or FT ( nb_transport_fw ) depending on the value of the
scml2::timing_abstraction_level_switch .
bool is_dmi_enabled()
Returns true  if DMI is enabled. DMI is enabled by default.
tlm::tlm_generic_payload&amp; alloc_and_init_trans(tlm::tlm_command cmd)
Allocates a new transaction and initializes some of the common fields. The caller
is responsible for setting relevant fields such as data lengthand data pointerbefore
invoking send_transaction  or b_transport . Only transactions created using the
alloc_and_init_trans  API should be used with the port adaptor.
bool read(unsigned long long address, DT&amp; data)
bool read(unsigned long long address, DT&amp; data, sc_core::sc_time&amp; t)
bool read(unsigned long long address, DT* data, unsigned int count)
bool read(unsigned long long address, DT* data, unsigned int count,
sc_core::sc_time&amp; t)
bool read(unsigned long long address, unsigned char* data, unsigned int count,
sc_time&amp;
t)
Issues a read  transaction and blocks until the transaction is complete. Returns true  if the
transaction response was successful. The type of transaction issued on the socket (blocking or
non-blocking) depends on the scml2::timing_abstraction_level  switch.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
112</p>
</section>
<section id="page-113">
<h2>Page 113<a class="headerlink" href="#page-113" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
bool write(unsigned long long address, const DT&amp; data)
bool write(unsigned long long address, const DT&amp; data, sc_core::sc_time&amp; t)
bool write(unsigned long long address, const DT* data, unsigned int count)
bool write(unsigned long long address, const DT* data, unsigned int count,<br />
sc_core::sc_time&amp; t)
bool write(unsigned long long address, const unsigned char* data, unsigned int
count,<br />
sc_time&amp; t)
Issues a write  transaction and blocks until the transaction is complete. Returns true  if the
transaction response was successful. The type of transaction issued on the socket (blocking or
non-blocking) depends on the scml2::timing_abstraction_level  switch.
unsigned int read_debug(unsigned long long address, DT&amp; data)
unsigned int read_debug(unsigned long long address, DT* data, unsigned int count)
unsigned int read_debug(unsigned long long address, unsigned char* data, unsigned
int<br />
count)
Reads data using the socket dbg_transport  interface. Returns the number of bytes read.
unsigned int write_debug(unsigned long long address, const DT&amp; data)
unsigned int write_debug(unsigned long long address, const DT* data, unsigned int
count)
unsigned int write_debug(unsigned long long address, const unsigned char* data,
unsigned int count)
Writes data using the socket dbg_transport  interface. Returns the number of bytes written.
bool send_transaction(tlm::tlm_generic_payload&amp; trans)
bool send_transaction(tlm::tlml_generic_payload&amp; trans, const sc_time&amp; delay)
Issues a non-blocking transaction at sc_current_time  ( + delay ) if possible, or queues it
for sending if another transaction is currently in progress. Returns true  unconditionally. Any
number of transactions may be sent, and the port adaptor will forward them onto the socket one
by one. This method may be called from within a timing callback function.
bool update_transaction(tlm::generic_payload&amp; trans, sc_time&amp; delay,
scml2::callback_event_enum event_id)
bool update_transaction(tlm::tlm_generic_payload&amp; trans, sc_time&amp; delay);
Attempts to advance the transaction state to the state event_id  that is provided as method
argument. If you skip the event_id  argument you have to set the desired protocol state of
the transaction payload explicitly before calling update_transaction . The port adaptor first
verifies that the transition is valid, then advances the transaction state. Returns true  if the
transaction state was advanced successfully. This method may be called from within a timing
callback function.
Note:
The delay  argument may be modified by the port adaptor, so should be set explicitly before calling
update_transaction  again.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
113</p>
</section>
<section id="page-114">
<h2>Page 114<a class="headerlink" href="#page-114" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Targets
target_port_adaptor* create(const std::string&amp; name, socket_type* socket,
sc_in<bool>* clk=NULL)
target_port_adaptor* create(socket_type* socket, sc_in<bool>* clk=NULL)
This static member function creates a new target port adaptor and binds it to the socket. You
may supply a name for the new port adaptor object explicitly using the name  argument or have
the port adapter named automatically. The protocol for the adaptor is selected using the socket
ft_protocol_tag  property, or TLM2_GP, if the property does not exist. If you specify a clock
pointer using the optional clk  argument, the clock port will be bound to the adaptor at the end
of elaboration. The supported protocols are TLM2_GP, AXI, GFT, AXI4Stream, and CHI .
void operator()(scml_clock_if* clk)
Binds a clock interface to the adaptor at end_of_elaboration . This is required to make use of
the timing attributes, and will allow the adaptor to handle dynamic clock period changes.
template &lt;class ObjT, typename FuncT&gt;
void set_clock_changed_callback(ObjT* obj, FuncT func)
Sets callback to be invoked, if the clock period of the clock bound to the port adaptor changes.
sc_time clock_cycles_to_time(unsigned int cycles)
Convenience API to convert the given number of clock cycles to sc_time  using the bound clock
interface.
std::string get_protocol()
Gets the protocol in use by the adaptor.
void set_attribute(const std::string&amp; name, int value)
Sets a name-value  attribute on the port adaptor. This is used to set protocol-specific
parameters on the port adaptor.
int get_attribute(const std::string&amp; name)
Gets the value of the named attribute.
void set_timing_callback(callback_event_enum event_id, timing_callback_base* cb)
Registers a callback function for a particular phase in the transaction life cycle. The callback
function object can be created using scml2::create_timing_callback  API. A convenient
macro is also provided to simplify the syntax:
SCML2_REGISTER_TIMING_CBK(adaptor, event_id, obj, func)
The callback function should return tlm::TLM_UPDATED  to indicate that the port adaptor
should advance the protocol state internally, or tlm::TLM_ACCEPTED  to stall the transfer until
update_transaction  is invoked with updated timing annotation and protocol state.
scml2::callback_event_enum get_event_id(unsigned int protocol_state)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
114</p>
</section>
<section id="page-115">
<h2>Page 115<a class="headerlink" href="#page-115" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Lookup callback event ID from protocol specific state.
bool has_callback(scml2::callback_event_enum state_id)
Convenience API to check if there is any callback registered for a particular protocol phase.
unsigned int get_bus_width()
Gets the width of the bus in bytes .
void operator()(mappable_if&amp; dest)
Binds a scml2::mappable_if  (usually an SCML2 memory) to the port adaptor. The port
adaptor will invoke the b_transport  API of the object at the appropriate phase in the
transaction cycle. More than one mappable_if  object may be bound to the port adaptor,
in which case, a select callback should be registered to route incoming transactions to the
appropriate object.
The auto_behavior  attribute controls how the port adaptor and timing callbacks interact with
the bound mappable_if.
When auto_behavior = 0: If a RD_ADDR_START  or WR_DATA_LAST_START  timing callback
is registered, the target model is responsible for invoking mappable_if::b_transport  and
advancing the protocol state to RD_DATA_LAST_START  or WR_RSP_START  respectively. Returning
TLM_UPDATED  from the timing callback will only advance the protocol state to RD_ADDR_END  or
WR_DATA_LAST_END . If no such timing callback is registered, the port adaptor will automatically
call the bound mappable_if::b_transport  and advance the protocol state.
When auto_behavior = 1: The port adaptor will always invoke the bound
mappable_if::b_transport  automatically after RD_ADDR_END / WR_DATA_LAST_END  state.
This is the preferred modeling methodology. Returning TLM_UPDATED  from the RD_ADDR_START /
WR_DATA_LAST_START  timing callback will advance the state to RD_DATA_LAST_START /
WR_RSP_START, allowing the transaction to complete without further updates from the user
model if required.
void set_select_callback(memory_select_callback_base* cb)
Sets a callback to be invoked if there is more than one mappable_if  bound to this port adaptor. The
callback is invoked to determine which mappable_if  should process an incoming transaction.
If a callback is registered for a particular event, the port adaptor ensures that it will be invoked, even if
the target or initiator had skipped that phase. For example, an initiator bound to an AXI FT  port adaptor
has callbacks registered for ARREADY, RREADY, and RREADY_LAST.
•
Initiator invokes send_transaction()  for a four-beat burst transfer.
•
Target returns ARREADY, initiator ARREADY  callback is invoked.
•
Target returns RREADY_LAST, port adaptor invokes RREADY  callbacks for three phases, then
RREADY_LAST  for final phase.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
115</p>
</section>
<section id="page-116">
<h2>Page 116<a class="headerlink" href="#page-116" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
AXI4 Stream Protocol
AXI4 Streaming initiators and targets have some additional complexity because of the streaming
protocol semantics. User models that want to take advantage of AXI4Stream-specific features such as
tkeep  and undefined length bursts should take a note of the following:
•
The AXI4Stream  initiator port adaptor will generate an error and exit the simulation if the user model
attempts to send a read transaction.
•
An AXI4Stream  initiator does not need to know the complete burst size in advance. To support
this use case, the initiator sets up the payload for the first beat, but sets data_length  to 0  before
invoking send_transaction . The initiator must register a TREADY  timing callback to update the
data_ptr  contents for each beat before returning TLM_UPDATED , or invoking update_transaction
with event WR_DATA_START . On the final beat, the initiator must call update_transaction  with
event WR_DATA_LAST_START .
•
If the initiator knows the complete burst size in advance, it should set the payload data_ptr  and
data_length  to the complete size before calling send_transaction . The port adaptor will take
care of streaming the data correctly.
•
In the same way as for other FT protocols, the AXI4Stream  initiator can set the
scml2::burst_size_extension  before calling send_transaction  to specify the burst size. If not
set, the burst size defaults to the data bus width.
•
By default, the port adaptor will setup the tkeep  array extension, taking into account the burst size
and bus width. To override this behavior and take control of the tkeep  array for each beat, the
initiator should call set_attribute(“handle_tkeep”, 0)  before calling send_transaction .
•
AXI4Stream  target port adaptors can optionally collect all of the data and byte_enables  for each
beat into single buffers suitable for a standard SCML memory access on TVALID_LAST . This default
behavior can be disabled by calling set_attribute(“collect_databeats”, 0)  on the target port
adaptor.
CHI
CHI is a credit-based protocol, where transfers may only be sent if the transmitter has received the
appropriate L-Credit from the receiver. Port adaptors always track the number of L-Credits available
for each channel at both the initiator and target. By default, port adaptors will send L-Credits to the
transmitter as soon as they are available. This means at simulation start, two credits for each channel
will be sent automatically. And, when an L-credit is consumed (for example, an CHI_REQ  received by
the target), the port adaptor will automatically send it back to the transmitter on the following cycle. The
number of credits of each type is available by calling get_attribute().
The model may take control of issuing L-Credits instead by setting the auto_send_credits  attribute
on the port adaptor to 0. In this mode, the port adaptor will not send any L-Credits, but will still track
the number of credits available at each channel and will not send a CHI_REQ  for example until a REQ  L-
Credit is available. The model may issue an L-Credit by allocating a payload, setting the protocol state
and opcode extensions, and calling send_transaction.
A model can register a timing callback for the scml2::CREDIT  event to be notified of new credit and
credit returns. This is an advanced use-case and it is expected that most models will not need to
SystemC Modeling Library Reference Manual
X-2025.06-SP1
116</p>
</section>
<section id="page-117">
<h2>Page 117<a class="headerlink" href="#page-117" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
register the callback or manually send L-Credits. Since the same timing callback is used on both
receiver and transmitter side, the model must examine the protocol_state  to determine (a) the type of
L-Credit, and (b) whether it is a credit or a return. For an initiator for example, REQ, RDATA  and SRESP  are
credits, but CRESP, WDATA, SNP  are credit-returns.
SCML2_SET_TIMING_CBK(adaptor, scml2::CREDIT, this, &amp; MyObject::HandleLCredit); …
tlm::tlm_sync_enum MyObject::HandleLCredit(tlm::tlm_generic_payload&amp; trans,
sc_time&amp; t) { // get protocol state for custom handling GET_EXT_ATTR((&amp;trans),
scml2::chi_rnf_protocol_state_extension, scml2::protocol_state_enum,
protocol_state); // handle credit switch (protocol_state) { … } return
tlm::TLM_ACCEPTED; }
FT CHI  protocol uses a single socket for both incoming and outgoing transactions. To support this,
the alloc_and_init()  and send_transaction()  APIs are available for CHI target port adaptors
to initiate L-Credit and Snoop transfers. The timing abstraction level switch is ignored for target
send_transaction, and target initiated transactions are always sent using nb_transport_bw .
Because CHI supports so many different transaction types, a CHI-aware model must check the opcode
extension inside the timing callback to determine the appropriate behavior.
•
Initiator model is responsible for returning CompAck  response (if it has set ExpCompAck ) by calling
update_transaction  RSP_START .
•
Initiator model may call update_transaction  RSP_START  to send the CompAck  from inside
RD_ADDR_END  callback. In this case, the port adaptor will not send the CompAck  until Comp is
received from target.
•
If the initiator model calls update_transaction  with WR_DATA_START , but the DBID response has
not yet been received, the port adaptor will delay sending the write data until DBID has received
from the target.
•
If no BUS_GRANT  timing callback has been registered by the initiator model, the port adaptor will
keep track of any RetryAck  ’d transactions, and will automatically retry the oldest one when the
PCrdGrant  is received.
•
If the initiator model has registered a BUS_GRANT  timing callback, the port adaptor will not track
RetryAck  ’d transactions, and it is up to the model to retry the transaction or return the P-Credit.
Figure 9: Credit Send and Return Flow
SystemC Modeling Library Reference Manual
X-2025.06-SP1
117</p>
</section>
<section id="page-118">
<h2>Page 118<a class="headerlink" href="#page-118" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 10: Read Transaction Flow with no CompData
SystemC Modeling Library Reference Manual
X-2025.06-SP1
118</p>
</section>
<section id="page-119">
<h2>Page 119<a class="headerlink" href="#page-119" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 11: Read Transaction Flow with CompData and Optional ReadReceipt
SystemC Modeling Library Reference Manual
X-2025.06-SP1
119</p>
</section>
<section id="page-120">
<h2>Page 120<a class="headerlink" href="#page-120" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 12: Read Transaction Flow with Retry and Credit Return
SystemC Modeling Library Reference Manual
X-2025.06-SP1
120</p>
</section>
<section id="page-121">
<h2>Page 121<a class="headerlink" href="#page-121" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 13: Write Transaction Flow with Combined and Separate Comp and DBId Response
SystemC Modeling Library Reference Manual
X-2025.06-SP1
121</p>
</section>
<section id="page-122">
<h2>Page 122<a class="headerlink" href="#page-122" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 14: Snoop Transaction Flow between Interconnect and Snooped Initiator
SystemC Modeling Library Reference Manual
X-2025.06-SP1
122</p>
</section>
<section id="page-123">
<h2>Page 123<a class="headerlink" href="#page-123" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 15: Snoop Transaction Flow between Interconnect, Snooped Initiator and Requesting Initiator
Figure 16: Prefetch Transaction Flow
SystemC Modeling Library Reference Manual
X-2025.06-SP1
123</p>
</section>
<section id="page-124">
<h2>Page 124<a class="headerlink" href="#page-124" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The following figures shows the transaction flows for some basic transaction types:
3.2.4. Protocol States
In the FT modeling API, the phases as found on the nb_transport  calls for the TLM2.0 base protocol
are implemented in a protocol-specific extension. This enables compatibility with the TLM2.0 base
protocol. These phases are implemented as a protocol state extension, which has the same meaning as
the TLM2.0 phases: they indicate timing points, represents the states in the protocol state machine and
determine what attributes can be accessed or modified.
Phases typically come in pairs:
TLM2-BP
BEGIN_x
END_x
AXI
xVALID
xREADY
AXI4Stream
xVALID
xREADY
GFT
x
x_ACK
Phase pairs represent a ‘transfer’; a basic information exchange between target and initiator. A transfer
is initiated either by the initiator or by the target phase by using the first protocol state. The second is
used by the receiving component to indicate the completion of the information exchange.
The timing of a transfer is important to consider; it defines the basic rules for delay modeling with
phases.
FT API timing:
•
The provider of information should implement the basic delay to make the data available.
•
The receiver of information should implement the additional delay to accept the data
•
For example in AXI:
◦
Initiator can provide write data beat on every cycle, so minimal one cycle delay between
consecutive transport calls to send WVALID.
◦
Target can accept data immediately: 0 additional delay on return of the call.
Timing can be implemented in the following ways:
•
Timing annotation:
Initiate multiple transport calls from the same SystemC context, add initiation delay for each call.
•
Explicit Synchronization:
Use SCML2 FT  modeling objects or SystemC synchronization mechanisms to initiate transport calls.
Timing annotation is the preferred approach to maximize model performance. Obviously, it is not always
possible to use timing annotation. For example if a delay is dependent on multiple inputs, a model first
SystemC Modeling Library Reference Manual
X-2025.06-SP1
124</p>
</section>
<section id="page-125">
<h2>Page 125<a class="headerlink" href="#page-125" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
will need to synchronize to make sure it can evaluate all inputs that might have come in at a certain
time.
Note:
FT Initiators and FT Targets should always send TLM_ACCEPTED  or TLM_UPDATED, as early
transaction termination is not supported in FT modeling.
The TLM2.0 payload provides with a set of attributes that are common to most if not all memory
mapped protocol interfaces. When creating a protocol definition for a real hardware protocol, these
payload  attributes are reused as much as possible, when protocol features match what is available in
the TLM2.0 protocol then that attribute should be reused.
There are also a set of very commonly-used attributes which can be used for a large set of hardware
protocols. A generic FT extension is provided for these attributes. This avoids the need to provide with
protocol conversion functions for these attributes.
The set of common extensions defined in the FT modeling style are available in the scml2  namespace
and are defined as follows:
•
Transaction ID:
DECLARE_EXTENSION(trans_id_extension, unsigned int, 0);
This provides a transaction ID, which should be set by the initiator. The exact semantics and use of
the ID is protocol specific.
Note:
The transaction_id_extension  shall be set by the initiator, but may be overwritten by one or
more interconnect components. This may be necessary, if the interconnect component wants to
ensure that each initiator presents a unique transaction_id  to the downstream components,
for example as done in the AXI protocol. Once the transaction_id  is overwritten in this way,
the old value is lost (unless it was explicitly saved somewhere).
•
Burst size :
DECLARE_EXTENSION(burst_size_extension, unsigned int, 0);
The burst size extension allows initiators to float narrow burst transfers. Default value 0  implies that
burst size is equal to bus width.
•
Wrap address
DECLARE_EXTENSION(wrap_addr_extension, unsigned long long, 0);
Indicates the start address for wrapping bursts, this is the address that will be issued first for the
burst access. The address in the payload itself should refer to the begin address for the whole data
array to remain consistent with TLM2.0 base protocol.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
125</p>
</section>
<section id="page-126">
<h2>Page 126<a class="headerlink" href="#page-126" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
•
Wrap Data
DECLARE_EXTENSION(wrap_data_extension, bool, false);
Is a flag for the target to indicate whether the wrap data is used.
3.2.5. Alignment in FT Protocols
FT protocols retain normal TLM2 semantics even for unaligned accesses; that is, the transaction
address  specifies the address of the first byte to be transferred, and data_length  always denotes the
total number of bytes to be transferred.
The number of data phases to transfer the payload is a function of address, data_length  and
burst_size_extension, and will be protocol dependent. For example, AXI FT requires beats to be
aligned to a beat boundary which can require an additional beat for unaligned accesses, as shown
below.
num_beats = (trans.get_data_length() + burst_size - 1) / burst_size;
if ((trans.get_address() % burst_size) != 0)
num_beats++;
The following examples show the bytes transferred during an unaligned access. The shaded cells
indicate bytes that are not transferred, but there is no need to use byte_enables  to align the start or
end of the payload to a particular address boundary in FT.
Figure 17: Examples of Unaligned Accesses on 32-bit AXI FT Bus
SystemC Modeling Library Reference Manual
X-2025.06-SP1
126</p>
</section>
<section id="page-127">
<h2>Page 127<a class="headerlink" href="#page-127" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 18: Examples of Unaligned Accesses on 64-bit AXI FT Bus
3.3. Protocol Definitions
•
FT GFT Protocol Definition
•
FT AXI Protocol Definition
•
FT ACE Protocol Definition
•
FT AXI4 Stream Protocol Definition
•
FT CHI Protocol Definition
•
FT PCIe Protocol Definition
•
FT CXL Protocol Definition
3.3.1. FT GFT Protocol Definition
SCML2 comes with a number of predefined protocol definitions. The Generic Fast Timed (GFT) protocol
definition is created as an extended version of the TLM2 Base Protocol. It is a generic protocol in the
sense that it is not created as an implementation of a specific hardware protocol, but rather as a set of
protocol states and attributes that allow different implementations for an interconnect which therefore
can mimic different protocol properties. The protocol definition of GFT in that sense is more an extended
set of basic protocol features as they can be found in real world hardware protocols. The GFT protocol
has the following additional features on top of the TLM2 base protocol.
•
support for burst data beat timing
•
single channel transaction initiation
The GFT protocol definition is created based on the FT Modeling interfaces and adds a set of specific
extensions for this protocol.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
127</p>
</section>
<section id="page-128">
<h2>Page 128<a class="headerlink" href="#page-128" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The GFT protocol defines the following different transfers which can be grouped in four types of
transfers:
•
Request transfer: Indicates the start of a transaction. With the request transfer, the initiator
requests access to the bus. It is not necessary for pure point-to-point connections. Even when
interacting with the bus, it is not required to start a transaction with the request transfer. It is not
required to have any other attributes of the transaction set when starting the request transfer. A
target or interconnect component should not look at any attributes at this point (also the address is
not required to be set).
Figure 19: Request Transfer
•
Command transfers: These are an alternative starting point for a transaction. It is used by an
initiator to setup transaction attributes. The address attribute should be available and all address
decoding related attributes ( burst_type, lock_type, access_mode  and access_type  and the
TLM2 base protocol attributes: tlm_command  and data_length), it is not required to have the data
array set. It is allowed to skip the request transfer and start the transaction with a command transfer.
Figure 20: Command Transfer
•
Write data transfers: The write data transfers are used by the initiator to setup the write data
beats. The target sets the response extension on the last transfer. It is possible to start the write data
in parallel to the write command, but not earlier. When a set of write data transfers are started it is
not allowed to interrupt them with write data transfers from another transaction. The number of write
data transfers is determined by the TLM2.0 base protocol data_length  attribute which indicates
the burst size. It is required that the last transfer is using the WR_DATA_LAST  and WR_DATA_LAST_ACK
protocol state values. It is always required to complete the full set of beats of a burst, even if a
decode error was issued by the interconnect.
Figure 21: Write Data Transfer
•
Read data transfers: These transfers are initiated by the target to setup the read data values
and read response extension. The read data transfers should always follow the read command and
cannot be started in parallel to the command, although the first read data beat can come along with
the command acknowledge. The response extension can be send along with any of the read data
transfers, but it is required to complete all data beats of the transaction independent of the response
SystemC Modeling Library Reference Manual
X-2025.06-SP1
128</p>
</section>
<section id="page-129">
<h2>Page 129<a class="headerlink" href="#page-129" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
status. The number of read data transfers is determined by the TLM2.0 base protocol data_length
attribute which indicates the burst size. It is required that the last transfer is using the RD_DATA_LAST
and RD_DATA_LAST_ACK  protocol state values.
Figure 22: Read Data Transfer
The GFT protocol state machine uses the protocol states above to model all timing points of a
generic protocol.
Figure 23: GFT Protocol State Machine for Write Access
The protocol state machine for a write access looks as in the figure above. The figure shows the
different protocol states that are used during a write  transfer with all protocol states that are defined
by the initiator on the left and all protocol states defined by the target on the right. The arrows give all
permitted state transitions between the different protocol states. The dotted protocol states and arrow
indicate the optional request transfer.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
129</p>
</section>
<section id="page-130">
<h2>Page 130<a class="headerlink" href="#page-130" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Notes on the protocol state machine:
•
It is not required to implement the request phase. A target should implement a grant return on a
request, but can simply return the grant protocol state if it is not interested in this transfer, as typically
it will not be forwarded by the bus to the target.
•
An initiator can send a CMD, after receiving the GRANT  for the REQ  if the transaction was started
through the request phase. The CMD phase can only be send if the CMD channel is free, that is, if
the previous CMD is acknowledged by the target.
•
It is not allowed to send a WR_DATA  phase in parallel with a WR_CMD, the WR_DATA  can only be sent
after the WR_CMD_ACK  is received.
•
It is allowed for an initiator to skip the WR_DATA  transfer in case the burstlength  smaller than
or equal to the data width of the socket. It is also allowed to skip WR_DATA  transfers and to jump
immediately to the WR_DATA_LAST. The initiator should ensure that all write data is available in this
case and that the timing annotation comprises of all setup delay for all data beats. In this case, the
initiator assumes that target and interconnect can calculate the timing delay for the full transaction,
and do not need additional SystemC synchronization to achieve this.
•
Similarly, the initiator can skip certain write data transfers during the transaction, but it can only jump
forward to the last transfer.
•
It is required to issue WR_DATA_LAST.
An example of an implementation of the GFT write data transaction is shown below through a message
sequence chart. It shows the initiator, bus and target and the different TLM2.0 interface method calls as
they are done by these components. The clock boundaries show the required timing synchronization
(dark green line) and timing annotation (red lines) for the transaction.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
130</p>
</section>
<section id="page-131">
<h2>Page 131<a class="headerlink" href="#page-131" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 24: GFT Write Data Transaction
The transaction starts with the initiator issuing a GFT_REQ  on the forward non-blocking transport API.
The bus requires a synchronization with SystemC to implement the bus arbitration (it needs to make
sure it sees all incoming transactions that happen at the same time). The bus will send the GFT_GRANT
over the backward transport path once the arbitration is completed (minimum one cycle delay). The
initiator can respond with a WR_CMD  that it sends in the return path of the nb_transport_bw  call from the
bus. The bus forwards this call to the target over the forward non-blocking interface path. If the target
can handle the transaction immediately, it can complete the command transfer on the return path to
the bus. At that point, the bus will call the initiator with the information from the target. In the end, the
bus is forwarding information from initiator to target and vice versa and all calls are happening without
synchronization with SystemC. Timing annotation is used everywhere, except for the arbitration. In the
above example, the transaction is one word long or the initiator is skipping all intermediate write data
transfers.
An important aspect of the protocol definition is to apply the FT modeling timing annotation rules to the
protocol, to ensure that it is clear which component should take care of the transfer timing. The following
table gives the overview of the timing annotation requirements for all protocol state transitions.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
131</p>
</section>
<section id="page-132">
<h2>Page 132<a class="headerlink" href="#page-132" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Table 38: Timing Annotation Requirements
Start
End
Who
Delay to be implemented
Mini
mum
GFT_REQ
GFT_GRANT
Bus
Arbitration delay.
1  clock
cycle in
case of
bus, 0
otherw
ise
GFT_GRANT
WR_CMD
Initiator
Command setup time.
0
WR_CMD
WR_CMD_ACK
Target
Command accept time including
address decoding.
0
WR_CMD_ACK
WR_DATA
Initiator
First beat data ready delay:
delay between command
accept return and fist write data
beat.
1
WR_CMD_ACK
WR_DATA_LAST
Initiator
Write data ready delay: delay
between command acceptance
and all data available, in case of
burstlength  is greater than 1,
no assumption can be made on
the timing of the other beats.
1  clock
WR_DATA
WR_DATA_ACK
Target
Write data beat accept delay,
time to accept data coming from
the initiator.
0
WR_DATA_ACK
WR_DATA
Initiator
Inter beat delay, time for the
initiator to setup next beat of
data.
1  clock
cycle
WR_DATA_ACK
WR_DATA_LAST
Initiator
Final interbeat delay, time
for the initiator to setup the
remainder of the data.
1  clock
cycle
WR_DATA_LAST
WR_DATA_LAST_ACK
Target
Final write data accept delay,
time to accept data coming from
initiator, includes time to setup
response
0
In case of a read transaction, the protocol state machine looks as shown below. The figure shows the
different protocol states that are used during a read transfer with all protocol states that are defined by
the initiator on the left and all protocol states defined by the target on the right.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
132</p>
</section>
<section id="page-133">
<h2>Page 133<a class="headerlink" href="#page-133" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 25: Protocol States During Read Transaction
The arrows give all permitted state transitions between the different protocol states. The dotted protocol
states and arrow indicate the optional request transfer.
Notes on the protocol state machine:</p>
<ol class="arabic simple">
<li><p>It is not required to implement the request phase. A target should implement a grant return on a
request, but can simply return the grant protocol state if it is not interested in this transfer, as typically
it will not be forwarded by the bus to the target.</p></li>
<li><p>An Initiator can send a CMD, after receiving the GRANT  for the REQ  if the transaction was started
through the request phase. The CMD phase can only be send if the CMD channel is free, that is, if
the previous CMD is acknowledged by the target.</p></li>
<li><p>A target is allowed to skip the RD_CMD_ACK  protocol state and respond to a RD_CMD  with a RD_DATA
protocol state in case it can start the read data transfers at the same time as the read command
acknowledge. In this case, the end of the command transfer is implied, the initiator should assume
that the read  command transfer is completed and is allowed to start another one.</p></li>
<li><p>The same applies for RD_DATA_LAST  in case the burstlength  equals one word.</p></li>
<li><p>When a target returns a RD_CMD_ACK  state to complete the read  command transfer it is required
to start the next transfer (RD_DATA) from a different SystemC context. This is a TLM2.0 standard
requirement. The new transfer should be started on the backward path and it is not allowed to call
the TLM interfaces from each others context.</p></li>
<li><p>Same applies for RD_DATA_LAST  in case burstlength  equals one word.</p></li>
<li><p>It is allowed to skip read data transfers and jump forward to the last data beat of the transaction.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
133</p></li>
</ol>
</section>
<section id="page-134">
<h2>Page 134<a class="headerlink" href="#page-134" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Note:
For read transactions there is the common beat_timing_request_extension  which is used
by the initiator to indicate whether it is interested to receive beat timing. A target is not obliged to
honor the request.
8. It is always required to use the RD_DATA_LAST  transfer.
An example of an implementation of the GFT read data transaction is shown below through a message
sequence chart. It shows the initiator, bus and target and the different TLM2.0 interface method calls as
they are done by these components. The clock boundaries show the required timing synchronization
(dark line) and timing annotation (lighter lines) for the transaction.
Figure 26: GFT Read Data Transaction
As with the write transaction the initiator starts the transaction with a call on the forward non-blocking
API. The bus needs a one cycle delay at least to implement the arbitration synchronization, but then
calls the initiator on the backward path with a GFT_GRANT  protocol state. Hereafter, the initiator can
continue with the read  command that the bus simply forwards to the target. The target skips the
acknowledge on the read  command and jumps forward to start the read data transfers. Each read data
transfer adds at least one clock cycle to the transaction timing. All further calls are done with timing
annotation and again the bus ensures that all transaction calls are routed correctly between initiators
and targets. The same transaction could be initiated with a read  command immediately in which case
the bus is required to forward the read  command to the target after the arbitration delay, the target can
add further delay before sending the command acknowledge back to the initiator.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
134</p>
</section>
<section id="page-135">
<h2>Page 135<a class="headerlink" href="#page-135" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The timing modeling rules for all possible protocol state transitions of a read transaction are listed in the
table below:
Table 39: Timing Modeling Rules
Start
End
Who
Delay to be Implemented
Minimum
GFT_REQ
GFT_GRANT
Bus
Arbitration delay
1  clock cycle
in case
of bus, 0
otherwise
GFT_GRANT
RD_CMD
Initiator
Command setup time
0
RD_CMD
RD_CMD_ACK
Target
Command accept time
including address decoding.
0
RD_CMD
RD_DATA
Target
First beat data ready delay
when command accept is zero.
1  clock cycle
RD_CMD
RD_DATA_LAST
Target
Transaction delay; total delay
to handle the transaction after
receiving a command in case
no beat timing is available; no
assumptions can be made for
the other timing points.
1  clock cycle
RD_CMD_ACK
RD_DATA
Target
First beat data ready delay;
delay between command
accept return and first read
data available.
1  clock cycle
RD_CMD_ACK
RD_DATA_LAST
Target
Data ready delay; total delay
to provide with all data after
returning command accept;
no assumptions can be made
about the other timing points.
1  clock cycle
RD_DATA
RD_DATA_ACK
Initiator
Read data accept delay; delay
for the initiator to accept the
incoming data.
0
RD_DATA_ACK
RD_DATA
Target
Inter beat delay; time for the
target to setup the next data
beat
1  clock cycle
RD_DATA_ACK
RD_DATA_LAST
Target
Final inter beat delay; time
for the target to setup the
remainder of the data.
1  clock cycle
RD_DATA_LAST
RD_DATA_LAST_ACK
Initiator
Final read data accept delay;
delay for the initiator to accept
the remaining incoming data.
0
SystemC Modeling Library Reference Manual
X-2025.06-SP1
135</p>
</section>
<section id="page-136">
<h2>Page 136<a class="headerlink" href="#page-136" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The final set of rules of the GFT protocol definition relate to state transitions between different
transactions. These rules define when an initiator is allowed to start a new transaction.
The GFT protocol can be used by an initiator and interconnect to model a shared bus communication.
An initiator should wait until the request transfer is completed before initiating a new request. The
interconnect or bus should enforce that only a single transaction is active at any time, the initiator can
still start a new request transfer, but the interconnect will only complete the transfer once the previous
transaction is completed. As such the bus is in control of the communication parallelism that is available
in the system by controlling the timing points to complete the request transfer or the command transfer.
Figure 27: GFT Protocol Used to Model Shared Bus Communication
3.3.2. FT AXI Protocol Definition
One of the most common protocols that are used in embedded SoC systems is the AXI protocol, as
defined by Arm ®  in the AMBA ®  specification. Therefore, SCML2 also contains a protocol definition
for this hardware protocol. The AXI protocol is a specific hardware protocol. Therefore, the goal of the
protocol definition is to provide with an accurate representation of the AXI features, both in functionality
and timing. The AXI protocol extensions are defined to enable to create accurate AXI interfaces
that support all AXI features. At the same time the AXI protocol also serves as the typical or generic
interface to use when modeling communication where concurrent read and writes are used and where
multiple transaction can be outstanding.
The FT AXI Modeling protocol definition is obviously closely related to the actual hardware protocol
definition. As with the attribute definitions, the protocol state  attribute is defined to match the
AXI protocol timing points. The FT AXI protocol definition defines protocol states according to seven
SystemC Modeling Library Reference Manual
X-2025.06-SP1
136</p>
</section>
<section id="page-137">
<h2>Page 137<a class="headerlink" href="#page-137" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
transfers, which represent the five hardware AXI protocol channels (two extra to indicate the last data
transfer). They can be grouped into the following sets:
•
Address transfers:
These represent the write address channel and read address channel of AXI, and correspond to
the AWVALID, AWREADY  and ARVALID, and ARREADY  signals. For simplicity, the protocol states get the
same name.
Figure 28: Address Transfer
•
Data transfers:
These represent the write data and read data channels. Again, the protocol states have the same
names as the AXI signals, except that the WLAST  and RLAST  signals are not represented by a
protocol state, but the combination of an RVALID  with RLAST  and WVALID  with WLAST  is represented
by the RVALID_LAST  and WVALID_LAST  protocol states, which are accompanied with RREADY_LAST
and WREADY_LAST  to define a separate transfer.
Figure 29: Data Transfer
•
Write response transfers:
Represents the BVALID, BREADY  signals used by the target to setup the response data.
Figure 30: Write Response Transfer
The AXI protocol state definition supports the hardware AXI protocol state machine, but since this is
a modeling paradigm, there is additional flexibility in the protocol state changes to support accuracy
for speed trade-offs or to allow to take short cuts in the protocol state machine for cases where the
SystemC Modeling Library Reference Manual
X-2025.06-SP1
137</p>
</section>
<section id="page-138">
<h2>Page 138<a class="headerlink" href="#page-138" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
timing is very predictable and there is no need to go through every single state change as is required
in hardware.
The protocol state machine for a write access looks as shown below.
Figure 31: Protocol State Machine for Write Access
The above figure shows the different protocol states that are used during a write transfer with all
protocol states that are defined by the initiator on the left and all protocol states defined by the target on
the right. The arrows give all permitted state transitions between the different protocol states.
Notes on the protocol state machine:</p>
<ol class="arabic simple">
<li><p>An initiator should always start data transfer after the address phase is complete. Starting data
transfer before starting address transfer is not allowed in FT semantics, as is theoretically possible
in the hardware AXI protocol definition. However, the data transfer can start at the same simulation
time as address transfer, provided the address transfer is already finished.</p></li>
<li><p>It is allowed to jump to WVALID_LAST  after completing the address transfer in case the length of the
transaction is one word or in case there is no beat timing available or necessary (that is, the initiator
sends the full data transaction at once and will account for the total delay of the write data setup).</p></li>
<li><p>The state transition from WREADY  to WVALID_LAST  is necessary in case of the last data beat, but can
also be used by the initiator to jump forward to the last beat. In this case, it should take into account
the data setup time for the remaining data beats.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
138</p></li>
</ol>
</section>
<section id="page-139">
<h2>Page 139<a class="headerlink" href="#page-139" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
4. It is always required to use WVALID_LAST.
5. When a target issues WREADY_LAST  on the last data beat, it will need to switch SystemC context to
initiate the BVALID  protocol state since it is not allowed in TLM2.0 to call a backward non-blocking
API call in the context from the forward API calls and vice versa.
6. It is allowed to skip the WREADY_LAST  protocol state for a target, in case the WREADY_LAST  and
BVALID  protocol states happen at the same time point. This will avoid the context switch described
above.
An example of an implementation of the AXI write data transaction is shown below through a message
sequence chart.
Figure 32: AXI Write Data Transaction
It shows the initiator and target plus the different TLM2.0 interface method calls as they are done by
these components. The clock boundaries show the required timing synchronization which can be
implemented as explicit SystemC timing synchronization or simply through an increment of the timing
annotation on the transport API calls.
The transaction starts with a call on the forward non-blocking interface by the initiator with the protocol
state set to AWVALID, the target can complete the address transfer on the return of this call by updating
the protocol state to AWREADY. The target only needs to add any additional timing it would need for
address decoding, the immediate return results in a one cycle address transfer since the initiator can
only start a new transaction on the next clock cycle. When the address transfer is completed the initiator
should initiate another call on the forward non blocking interface to start the first write data transfer. It
can choose to do this in the same cycle, this implements a case where address and data are made
SystemC Modeling Library Reference Manual
X-2025.06-SP1
139</p>
</section>
<section id="page-140">
<h2>Page 140<a class="headerlink" href="#page-140" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
available in the same clock cycle by the initiator. Again, the target can respond with WREADY  on the
return of the transport API call. The next data beat can only be initiated in the next clock cycle, but it is
possible to continue to use timing annotation on the transport APIs to model this. In this example, the
target skips the WREADY_LAST  protocol state and returns with the protocol state set to BVALID  indicating
that WREADY_LAST  and BVALID  happened at the same timing point. The initiator then completes the
transaction by sending a BREADY, the target should not update the protocol state in this case.
An important aspect of the protocol definition is to apply the FT modeling timing annotation rules to the
protocol, to ensure that it is clear which component should take care of the transfer timing. The following
table gives the overview of the timing annotation requirements for all protocol state transitions.
Table 40: Timing Annotation Requirements
Start
End
Who
Delay to be
implemented
Minimum
AWVALID
AWREADY
target
Address response
delay.
Can be 0  in case of
pre-asserted address
ready.
AWVALID
WVALID
initiator
First beat ready
delay; delay to setup
data independent of
address return.
Is 0  if address and
data are sent in the
same cycle.
AWVALID
WVALID_LAST
initiator
data_ready  delay:
delay to setup all
data independent
of address return in
case of first and only
beat or when jumping
forward to last beat.
One clock cycle,
can be 0  in case
burstlength equals 1.
AWREADY
WVALID
initiator
First beat ready
delay; delay between
address acceptance
and first write data
beat.
0
AWREADY
WVALID_LAST
initiator
data_ready  delay:
delay between
address acceptance
and all data
available, in case
of burstlength
greater than 1, no
assumptions on
timing of other beats.
One clock cycle,
can be 0  in case
burstlength equals 1.
WVALID
WREADY
target
Write data beat
accept delay, time to
accept data coming
from initiator.
0
SystemC Modeling Library Reference Manual
X-2025.06-SP1
140</p>
</section>
<section id="page-141">
<h2>Page 141<a class="headerlink" href="#page-141" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Table 40: Timing Annotation Requirements (Continued)
Start
End
Who
Delay to be
implemented
Minimum
WREADY
WVALID
initiator
Inter beat delay, time
for initiator to setup
next data beat.
One clock cycle
WREADY
WVALID_LAST
initiator
Final inter beat delay,
time for initiator to
setup remainder of
the data.
One clock cycle
WVALID_LAST
WREADY_LAST
target
Write data accept
delay: time to accept
remaining data
coming from initiator.
0
WVALID_LAST
BVALID
target
Write data accept
delay plus response
setup time, in case
response setup time
== 0.
0
WREADY_LAST
BVALID
target
Response setup
time: delay for
target to setup write
response.
0
BVALID
BREADY
initiator
Response accept
time: delay for
initiator to accept
write response.
0
In case of a read transaction, the protocol state machine looks as shown below.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
141</p>
</section>
<section id="page-142">
<h2>Page 142<a class="headerlink" href="#page-142" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 33: Protocol State Machine for Read Transaction
The above figure shows the different protocol states that are used during a read transfer with all
protocol states that are defined by the initiator on the left and all protocol states defined by the target on
the right. The arrows give all permitted state transitions between the different protocol states.
Notes on the protocol state machine:</p>
<ol class="arabic simple">
<li><p>A target is allowed to advance the protocol state machine to RVALID  and skip ARREADY. In this case,
the end of the read address transfer is implied, the initiator should assume that the read command
transfer is completed and is allowed to start another one in the same cycle as the RVALID. This
avoids additional transport API calls and a SystemC context switch.</p></li>
<li><p>The same holds for RVALID_LAST, in case the burst length of the transaction equals one word or
when there are no intermediate timing points available from the target, or when the initiator is not
requesting them ( request_beat_timing_extension).</p></li>
<li><p>The target is allowed to jump forward to RVALID_LAST  for the last data beat and it can skip data
beats to get there. It is required to make sure that all read data is available in the data pointer.
Note:
For read transactions, there is the common beat_timing_request_extension  which is used
by the initiator to indicate whether it is interested to receive beat timing. A target is not obliged to
honor the request.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
142</p></li>
</ol>
</section>
<section id="page-143">
<h2>Page 143<a class="headerlink" href="#page-143" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
4. When a target issues a ARREADY  to complete the read address transfer it is required to start the next
transfer (RVALID  or RVALID_LAST) from a different SystemC context. This is a TLM2.0 standard
requirement. The new transfer should be started on the backward path and it is not allowed to call
the TLM interfaces from each others context.
An example of an implementation of the AXI read data transaction is shown below through a message
sequence chart.
Figure 34: AXI Read Data Transaction Implementation
It shows the initiator and target plus the different TLM2.0 interface method calls as they are done by
these components. The clock boundaries show the required timing synchronization which can be
implemented as explicit SystemC timing synchronization or simply through an increment of the timing
annotation on the transport API calls.
The initiator starts the transaction with the read address transfer start protocol state ARVALID. The
target skips the ARREADY  and returns with an RVALID  on forward call that the initiator used to start the
transaction. The target adds one cycle timing annotation to the call. This implies that the initiator can
start the next transaction in the same cycle as the RVALID, but cannot assume anything about the actual
arrival time of the ARREADY. If the timing annotation would be larger than one clock cycle, the initiator
still cannot start a new transaction earlier than the RVALID. Obviously, the target should ensure that the
read data is available with the RVALID  protocol state, the data for the later data beats can be added
immediately or only with the individual data transfers.
The initiator completes the read data transfer by updating the protocol state to RREADY  and sending it
over a new forward transport call, it is allowed to do this from the same SystemC context and without
SystemC Modeling Library Reference Manual
X-2025.06-SP1
143</p>
</section>
<section id="page-144">
<h2>Page 144<a class="headerlink" href="#page-144" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
timing annotation. The target again can use the return path of the call by the initiator to update the
protocol state to start the next data transfer. This continues until all data beats are completed.
The timing modeling rules for all possible protocol state transitions of a read transaction are listed in the
table below:
Table 41: Timing Modeling Rules
Start
End
Who
Delay to be Implemented
Minimum
ARVALID
ARREADY
Target
Address response delay.
Can be 0  in case of
pre-asserted address
ready.
ARVALID
RVALID
Target
First beat ready delay; delay
to send RVALID  in case
address response delay is 0
(pre-asserted ARREADY).
One clock cycle.
ARVALID
RVALID_LAST
Target
data_ready  delay: delay
to send RVALID_LAST,
total delay for transaction
in case no beat timing is
available no assumptions
can be made for the other
timing points (for example,
ARREADY).
One clock cycle.
ARREADY
RVALID
Target
First beat ready delay: delay
between accepting address
and first data beat available.
One clock cycle.
ARREADY
RVALID_LAST
Target
First beat ready delay: in
case of single beat transfer.
One clock cycle.
RVALID
RREADY
Initiator Read data beat accept
delay, time to accept data
coming from target.
0
RREADY
RVALID
Target
Inter beat delay, time for the
target to setup next data
beat.
One clock cycle.
RREADY
RVALID_LAST
Target
Final inter beat delay,
time for the target to setup
remainder of the data.
One clock cycle.
RVALID_LAST
RREADY_LAST
Initiator Final read data accept delay,
time for the initiator to accept
data coming from target.
0
The final set of rules of the AXI protocol definition relate to state transitions between different
transactions. These rules define when an initiator is allowed to start a new transaction. The rules for the
FT AXI protocol definition are the same as for the hardware AXI protocol definition.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
144</p>
</section>
<section id="page-145">
<h2>Page 145<a class="headerlink" href="#page-145" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 35: AXI Protocol Definition Rules
An initiator is allowed to start read and write transactions concurrently using the address transfers.
There is no dependency between the two.
•
A new transaction can be started as soon as the corresponding address transfer is completed. This
means as soon as AWREADY  is received or as soon as ARREADY  is received or implied by RVALID  or
RVALID_LAST.
•
It is possible to have multiple transactions in flight and a bus and target can control the number of
read or write transactions that are outstanding using the address READY  timing points effectively
preventing an initiator from starting more transactions.
•
There is a minimum of one clock cycle delay required for an initiator to start a new transaction of the
same type.
•
A new transaction should always be started on the forward transport API.
Note:
The target response does not necessarily come on the return path, but may be delayed and
come using the backward path.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
145</p>
</section>
<section id="page-146">
<h2>Page 146<a class="headerlink" href="#page-146" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Since new transactions can be issues after AWREADY  or ARREADY  is received it is possible to have
multiple read/write requests outstanding. The order in which these transactions are completed should
follow AXI rules. In AXI ordering is governed by the transaction ID:
•
Transactions with different ID have no ordering restrictions.
•
Read or Write transactions with the same ID should complete in order.
•
No ordering restrictions between reads and writes.
Another AXI feature is Write Data interleaving, which allows a target interface to accept partial data
transfers for transactions coming with different IDs. This means that a target is not required to complete
the full data burst transfer for writes and that it can receive data transfers from other initiators intermixed
with an already started transaction. This feature is fully under control of the target and does not imply
any additional support from the initiator.
3.3.3. FT ACE Protocol Definition
Arm has defined ACE protocol to achieve the Cache Coherency in modern day’s complex designs. The
ACE protocol extends the AXI/AXI4 protocol and provides support for hardware coherent caches.
SCML2 also contains a protocol definition for this hardware protocol. The goal of the protocol definition
is to provide with an accurate representation of the ACE features, both in functionality and timing. The
ACE protocol extensions are defined to enable users to create accurate ACE interfaces that support
all ACE protocol features. At the same time, the ACE protocol also serves as the typical or generic
interface to use while modeling systems with Cache Coherency requirements.
The FT ACE protocol definition is closely related to the actual hardware protocol definition. ACE
protocol has eight different channels out of which five channels are the same as in AXI protocol. There
are three additional channels to allow an initiator in the system to snoop into the caches of the other
initiators.
FT ACE protocol definition is also based on FT AXI protocol definition with additional semantics to
model the ACE protocol.
FT ACE interface between initiator and target is a combination of two FT AXI sockets, as shown in the
figure below. Outgoing socket from the initiator (or incoming socket on the target) is same as the FT
AXI socket. In addition, there is an incoming socket on the initiator (or outgoing socket on the target) to
model snoop channels/requests. The additional socket is also using FT AXI protocol.
Figure 36: FT ACE Interface Between Initiator and Target
SystemC Modeling Library Reference Manual
X-2025.06-SP1
146</p>
</section>
<section id="page-147">
<h2>Page 147<a class="headerlink" href="#page-147" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Additional socket for the FT ACE protocol models Snoop Address (AC), Snoop Response (CR) and
Snoop Data (CD) channels. As these channels are modeled using FT AXI, following is the mapping for
the incoming interface on the initiator.
Table 42: Mapping ACE Channels to FT AXI Channels
ACE Channel
Mapping to FT AXI Channel
AC
AR
CD
R
CR
R
This results in defining few new transfers in addition to the seven FT AXI transfers, as described in FT
ACE API Definition.
•
Snoop Address Transfers
These represent the Snoop Address channel of ACE, and correspond to the ACVALID  and ACREADY
signals. For simplicity, these are given the names as ARVALID  and ARREADY  protocol states.
Figure 37: Snoop Address Transfers
•
Snoop Data and Snoop Response Transfers
These represent the Snoop channel. Again, the protocol states have the names as RVALID  and
RREADY. Snoop Response channel is merged with the Snoop Data channel by passing CRRESP
through RRESP.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
147</p>
</section>
<section id="page-148">
<h2>Page 148<a class="headerlink" href="#page-148" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 38: Snoop Data Transfers
The protocol state machine for Snoop Access looks as shown below:
Figure 39: Protocol State Machine for Snoop Access
The above figure shows the different protocol states that are used during a snoop transfer with all
protocol states that are defined by the initiator on the left and all protocol states defined by the target on
the right.
The arrows give all permitted state transitions between the different protocol states.
Some important points to note about the protocol state machine are:</p>
<ol class="arabic simple">
<li><p>An initiator is allowed to advance the protocol state machine to RVALID  and skip ARREADY. In this
case, the end of the snoop address transfer is implied, the target should assume that the snoop
command transfer is completed and is allowed to start another one in the same cycle as the RVALID.
This avoids additional transport API calls and a SystemC context switch.</p></li>
<li><p>The same holds for RVALID_LAST, in case the burst length of the transaction equals one word or
when there are no intermediate timing points available from the target, or when the initiator is not
requesting them.</p></li>
<li><p>The initiator is allowed to jump forward to RVALID_LAST  for the last data beat and it can skip data
beats to get there. It is required to make sure that all read data is available in the data pointer.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
148</p></li>
</ol>
</section>
<section id="page-149">
<h2>Page 149<a class="headerlink" href="#page-149" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
4. When an initiator issues a ARREADY  to complete the snoop address transfer, it is required to start the
next transfer (RVALID  or RVALID_LAST) from a different SystemC context. This is a TLM2.0 standard.
requirement. The new transfer should be started on the backward path and it is not allowed to call
the TLM interfaces from each other’s context.
5. As all Snoop transactions do not require data to be transferred, initiator should jump to RVALID_LAST
with ace_rsp_pass_data_extension  set to false.
ACE protocol has support for two additional acknowledge signals. These signals are used to indicate
that an initiator has completed a read  or write  transaction. In case of FT AXI protocol, these signals
are modeled implicitly. RACK  signal is considered to be received when RREADY_LAST  is received by the
target. Also, WACK  signal is considered to be received when BREADY  is received by the target.
3.3.4. FT AXI4 Stream Protocol Definition
The AXI4 Stream protocol is used as a standard interface to connect components that want to
exchange data. The interface can be used to connect a single initiator, that generates data to a single
target that receives data. The protocol can also be used when connecting larger numbers of initiator
and target components.
This hardware protocol uses the Fast Timed (FT) methodology. SCML2 also contains a protocol
definition for this hardware protocol. The goal of the protocol definition is to provide with an accurate
representation of the AXI4 Stream features, both in functionality and timing. The AXI4 Stream protocol
extensions are defined to enable users to create accurate AXI4 Stream interfaces that support all AXI4
Stream protocol features.
•
Initiator starts a new data transfer by setting protocol state as TVALID  for a multi beat transfer and to
TVALID_LAST  for a single beat transfer.
•
Target on receiving the transfer, acknowledges with TREADY  protocol state.
◦
To mimic pre-asserted TREADY, target can send TREADY  with zero cycle delay.
◦
To mimic post-asserted TREADY, target can send TREADY  with delay of one or more cycles.
•
Last transfer of the packet is indicated by the TVALID_LAST  protocol state.
•
For a single transfer packet/burst, TVALID_LAST  is set as protocol state and is acknowledged by
TREADY_LAST.
•
Initiator can send next TVALID/TVALID_LAST  only one cycle after the TVALID/TREADY  handshake is
over.
◦
TREADY  with t=0  means handshake over in the same cycle.
◦
TREADY  with t&gt;0  means handshake over at simulation time sc_time_stamp(t=0).
•
The initiator should set appropriate extensions indicating values for TID, TDEST  and TUSER.
•
The byte enable length and byte enable pointer follows the same rules, as specified in the TLM2
Reference manual.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
149</p>
</section>
<section id="page-150">
<h2>Page 150<a class="headerlink" href="#page-150" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
•
The array extension axi4_stream_tkeep_extension  should be set if any of the bytes in the data
stream are NULL  bytes. It is not required to be set, if none of the NULL  bytes exists in the payload.
In this case, the value of the array is assumed to be 0xFF  for all bytes. This extension should be set
and get using the above defined macros and their memory management is done by the extension
infrastructure.
•
State Skipping is allowed, that is, initiator can send TVALID_LAST  directly as first protocol state, after
setting the complete data in the data pointer. In doing so, it should maintain an appropriate inter beat
timing delay.
•
When AXI4 Stream initiator is mapped to GP target, mapper acknowledges all TVALIDs  with
TREADY’s. TVALID_LAST  is mapped to BEGIN_REQ  phase on TLM2_GP. BEGIN_RESP  from GP is
mapped to TREADY_LAST  and send back to initiator.
•
An AXI4 Stream initiator is not expected to know the number of beats in the complete burst in
advance. Therefore, an AXI4 Stream initiator should always set the data length of the payload as the
BUS WIDTH  which is also the size of each beat of AXI4 Stream packet.
•
An AXI4 Stream initiator should also allocate number of bytes equal to BUS WIDTH  for its data
pointer, byte enable pointer and TKEEP  extension pointer. It is expected that an AXI4 Stream initiator
will use the same data buffer for each subsequent beat.
•
For sending narrow burst and AXI4 Stream, initiator would set the corresponding bytes in TKEEP
extension array to be NULL.
Note:
Mapping from AXI to AXI4 Stream is not supported.
•
When GP initiator is connected to AXI4 Stream target - BEGIN_REQ  for WRITE  request is mapped to
TVALID_LAST  on AXI4 Stream target. And TREADY_LAST  is mapped to BEGIN_RESP  on GP side.
•
Appropriate channel timings would be maintained by the mapper.
•
When GP initiator is connected to AXI4 Stream target- BEGIN_REQ  for READ  is responded by
BEGIN_RESP  from the mapper, with tlm_response  set to TLM_COMMAND_ERROR_RESPONSE.
•
When AXI4 Stream initiator is connected to GP or AXI target, each beat from initiator is mapped to
single transaction on target. The mapper will convert the BUS WIDTH  on initiator side to data length
and burst size attribute of the transaction on target side.
Figure 40: Protocol State Machine for AXI4 Stream Protocol
SystemC Modeling Library Reference Manual
X-2025.06-SP1
150</p>
</section>
<section id="page-151">
<h2>Page 151<a class="headerlink" href="#page-151" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The following table lists the timing requirement for the protocol.
Table 43: Timing Rules
Start State
End State
Who
Delay to be Implemented Minimum Delay
TVALID
TREADY
Target
Data Accept Delay
0  for pre-asserted Ready
TREADY
TVALID
Initiator
Interbeat Delay
1  cycle
TREADY
TVALID_LAST
Initiator
Interbeat Delay
1  cycle
TVALID_LAST
TREADY_LAST
Target
Data Accept Delay
0  cycle (pre-asserted)
TREADY_LAST
TVALID
Initiator
Inter Packet Delay
1  cycle
The following Message Sequence chart shows the flow for AXI4 Stream Initiator and Target when
Target is giving pre-asserted TREADY.
Figure 41: Pre Asserted TREADY
Note:
The red dotted line in the image indicates CLK  cycle delay.
The following Message Sequence chart shows the flow for AXI4 Stream Initiator and Target when
Target is giving post-asserted TREADY.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
151</p>
</section>
<section id="page-152">
<h2>Page 152<a class="headerlink" href="#page-152" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 42: Post Asserted TREADY
Note:
•
The red dotted line in the image indicates CLK  cycle delay.
•
The clk  is only time and can be annotation, not necessarily an increase in simulation time.
•
The number of clock cycles can be one or more.
3.3.5. FT CHI Protocol Definition
Arm has defined the CHI protocol to achieve Cache Coherency in modern day’s complex designs. This
is done keeping in mind, the ever increasing number of coherent initiators. CHI stands for Coherent Hub
Interface; and targets the interface to the coherent hub, that is found in many SoCs.
SCML2 contains a protocol definition for this protocol. The goal of the protocol definition is to provide an
accurate representation of the CHI features, both in functionality and timing.
The FT CHI protocol definition is closely related to the actual hardware protocol definition. FT CHI
defines six different channels.
Table 44: FT CHI Channel Mapping
RN-F
RN-D
RN-I
SN-F / SN-I
FT CHI
Description
TXREQ
TXREQ
TXREQ
ChiTxReq
Outbound Request
RXSNP
RXSNP(DVM)
RXREQ
ChiRxReq
Inbound Request
TXDAT
TXDAT
TXDAT
TXDAT
ChiTxData
Outbound Data
RXDAT
RXDAT
RXDAT
RXDAT
ChiRxData
Inbound Data
TXRSP
TXRSP
TXRSP
TXRSP
ChiTxResp
Outbound Response
RXRSP
RXRSP
RXRSP
ChiRxResp
Inbound Response
SystemC Modeling Library Reference Manual
X-2025.06-SP1
152</p>
</section>
<section id="page-153">
<h2>Page 153<a class="headerlink" href="#page-153" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Unlike FT ACE, FT CHI interface between two nodes is represented using a single socket. This single
socket, is used for both inbound and outbound requests. As such, LT mode using TLM blocking
transport interface is not supported.
FT CHI protocol definition defines the protocol states for six different transfers, which represent the six
hardware CHI protocol channels. They can be grouped into the following sets:
•
Address transfers
These represent read and write address transfers on ChiTxReq  and ChiRxReq  channels.
•
Data transfers
These represent read, write and snoop data transfer on ChiTxData  and ChiRxData  channels.
•
Response transfers
These represent read, write and snoop response transfers on ChiTxResp  and ChiRxResp  channels.
Protocol state machine for some basic transactions is illustrated below. These figures show different
protocol states that are used during a transaction between two nodes. The arrows give all permitted
state transitions between the different protocol states.
Figure 43: Protocol State Machine for Read Transaction
SystemC Modeling Library Reference Manual
X-2025.06-SP1
153</p>
</section>
<section id="page-154">
<h2>Page 154<a class="headerlink" href="#page-154" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 44: Protocol State Machine for Write Transaction
Figure 45: Protocol State Machine for Snoop Transaction
3.3.6. FT PCIe Protocol Definition
PCI Express (Peripheral Component Interconnect Express) is a high-speed serial computer expansion
bus standard. It is the common motherboard interface for personal computers’ graphics cards, hard disk
drive host adapters, SSDs, Wi-Fi and Ethernet hardware connections.
PCIe has numerous improvements over the older standards, including higher maximum system bus
throughput, lower Input/Output pin count and smaller physical footprint, better performance scaling for
bus devices, and so on.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
154</p>
</section>
<section id="page-155">
<h2>Page 155<a class="headerlink" href="#page-155" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
SCML2 contains a protocol definition for this protocol. The goal of the protocol definition is to provide an
accurate representation of the PCIe features that can be used for performance studies and architectural
exploration. All the three PCIe protocol stack layers (Transaction Layer, Data Link Layer and Physical
Layer) are implemented in Port Adaptors.
Both the PCIe Tx and Rx interfaces are supported using a single socket pair that is, both the PCIe
sockets as well as port adaptors support bidirectional operation
Note:
Tx and Rx are always from Initiator socket perspective. For example, a Tx packet always means an
outgoing packet from Initiator socket and an Rx packet always means an incoming packet at Initiator
socket. In other words, a Tx packet always means an incoming packet at Target socket and an Rx
packet always means an outgoing packet from Target socket.
Figure 46: Protocol State Machine for Memory Read Transaction from Initiator Socket (Root Complex)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
155</p>
</section>
<section id="page-156">
<h2>Page 156<a class="headerlink" href="#page-156" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 47: Protocol State Machine for Memory Read Transaction from Target Socket (End Point)
Figure 48: Protocol State Machine for Memory Write Transaction from Initiator Socket (Root Complex)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
156</p>
</section>
<section id="page-157">
<h2>Page 157<a class="headerlink" href="#page-157" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 49: Protocol State Machine for IO Write Transaction (Non Posted) from Initiator Socket (Root Complex)
3.3.7. FT CXL Protocol Definition
Compute Express Link (CXL) is an open standard for high-speed CPU-to-device and CPU-to-memory
connections, designed for high performance data centre computers.
CXL is built on the PCIe physical and electrical interface and includes PCIe-based block input/output
protocol (CXL.io) and new cache-coherent protocols for accessing system memory (CXL.cache) and
device memory (CXL.mem).
SCML2 contains a protocol definition for this protocol. The goal of the protocol definition is to provide an
accurate representation of the CXL features that can be used for performance studies and architectural
exploration. All the three CXL protocol stack layers (Transaction Layer, Data Link Layer and Physical
Layer) are implemented in Port Adaptors.
Both the CXL Tx and CXL Rx interfaces are supported using a single socket pair, that is, both the CXL
sockets as well as port adaptors support bidirectional operation.
Note:
Tx and Rx are always from Initiator socket perspective. For example, a Tx packet refers to an
outgoing packet from the Initiator socket, and an Rx packet refers to an incoming packet at the
SystemC Modeling Library Reference Manual
X-2025.06-SP1
157</p>
</section>
<section id="page-158">
<h2>Page 158<a class="headerlink" href="#page-158" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Initiator socket. In other words, a Tx packet refers to an incoming packet at the Target socket and an
Rx packet refers to an outgoing packet from the Target socket.
Figure 50: Protocol State Machine for Memory Read Transaction (Type3) from Initiator Socket (Host)
Figure 51: Protocol State Machine for Memory Read Transaction (Type2) from Initiator Socket (Host)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
158</p>
</section>
<section id="page-159">
<h2>Page 159<a class="headerlink" href="#page-159" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 52: Protocol State Machine for Memory Write Transaction from Initiator Socket (Host)
Figure 53: Protocol State Machine for CXL.cache Read Transaction to Host Memory (Type1/Type2) from Target
Socket (Device)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
159</p>
</section>
<section id="page-160">
<h2>Page 160<a class="headerlink" href="#page-160" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 54: Protocol State Machine for CXL.cache Write Transaction to Host Memory (Type1/Type2) from Target
Socket (Device)
Figure 55: Protocol State Machine for CXL.cache Write Transaction with ExtCmp to Host Memory (Type1/Type2)
from Target Socket (Device)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
160</p>
</section>
<section id="page-161">
<h2>Page 161<a class="headerlink" href="#page-161" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 56: Protocol State Machine for CXL.cache Snoop Transaction (Type1/Type2) from Initiator Socket (Host)
Figure 57: Protocol State Machine for CXL.cache Read Transaction to Device Memory in Host Bias (Type2) from
Target Socket (Device)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
161</p>
</section>
<section id="page-162">
<h2>Page 162<a class="headerlink" href="#page-162" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 58: Protocol State Machine for CXL.cache Write Transaction to Device Memory in Host Bias (Type2) from
Target Socket (Device)
3.4. API Definitions
•
FT GFT API Definition
•
FT AXI API Definition
•
FT ACE API Definition
•
FT AXI4 Stream API Definition
•
FT CHI API Definition
•
FT PCIe API Definition
•
FT CXL API Definition
3.4.1. FT GFT API Definition
The basics of the FT GFT API are described in SCML2 FT Modeling Interfaces. The attributes that do
not fit with the TLM2 base protocol need to be added as ignorable extensions as well as the protocol
timing points. GFT extends the common FT interfaces with the following extensions:
•
scml2::gft_protocol_state_extension:
This is the payload extension that holds the protocol timing points for the GFT protocol it is used as
follows:
scml2::gft_protocol_state_enum protocol_state;
scml2::gft_protocol_state_extension *gft_state;
transaction.get_extension_attr(gft_state, protocol_state);
SystemC Modeling Library Reference Manual
X-2025.06-SP1
162</p>
</section>
<section id="page-163">
<h2>Page 163<a class="headerlink" href="#page-163" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
As socket that intends to communicate using the GFT protocol should indicate this using the
set_protocol  API:
P_socket.set_protocol&lt;scml2::gft_protocol_state_extension &gt;(“GFT”);
The GFT protocol defines the following protocol states, each referring to a protocol timing point.
They are represented in pairs to indicate the transfers that they represent.
Figure 59: GFT FT API
•
scml2::gft_response_extension:
The GFT protocol definition has an extended set of transaction responses, for example, to fit better
with the features of protocols like AXI. Therefore, an extended response is provided. This implies
that when using the GFT protocol definition, it is required to ignore the TLM2 base protocol response
definition.
typedef enum { gftOK, gftEX_OK, gftSLV_ERR, gftDEC_ERR, gftSplit, gftRetry}
gft_rsp_enum;</p>
<p>scml2::gft_rsp_enum response;
scml2::gft_response_extension*rsp_ext;
transaction.get_extension_attr(rsp_ext, response);
◦
gftOK: Indicates normal access has been successful, can indicate failure of an exclusive access.
This is the default for the extension.
◦
gftEX_OK: Indicates an exclusive access has been successful.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
163</p>
</section>
<section id="page-164">
<h2>Page 164<a class="headerlink" href="#page-164" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
◦
gftSLV_ERR: Is used to indicate a target error, which means the transaction reached the target,
but the target wishes to return an error condition to the initiator
◦
gftDEC_ERR: Indicates a decode error by an interconnect component, when there is no target at
the transaction address.
◦
gftSplit: Indicates a split response by the target for the given transaction, that is, that it will
take a while for this transaction to complete and that other initiators should be given priority. This
implies that other transactions may come in on the same target while the current transaction is
being processed.
◦
gftRetry: Indicates a retry response by the target, which is similar to a split but here the
preference is that only initiators with higher priority can come in on the same target while the
current transaction is being processed.
•
scml2::gft_burst_type_extension:
The GFT protocol definition supports an additional burst type on top of what is available in TLM2
base protocol, this is a wrapping burst. For which the common wrap address and wrap data
extensions can be used.
Note:
The TLM2.0 base protocol supports burst accesses, but does not really have a burst type
definition.
The GFT protocol does not violate the TLM2.0 base protocol data organization rules. This means
that functionally there is no difference between GFT and TLM2.0 base protocol concerning burst
transactions. The gft_burst_type_extension  is important to correctly model burst beat timing.
The difference relates to the first data element that is returned for a wrapping burst versus an
incremental burst.
typedef enum { gftFIXED, gftINCR, gftWRAP} gft_burst_type_enum;</p>
<p>scml2::gft_burst_type_enum burst_type;
scml2::gft_burst_type_extension*burst_ext;
transaction.get_extension_attr(burst_ext, burst_type);
◦
gftFIXED: Indicates burst with fixed address.
◦
gftINCR: Indicates incremental burst. This is the default for the extension.
◦
gftWRAP: Is to be used for wrapping bursts.
•
scml2::gft_lock_type_extension:
This GFT attribute indicates whether the transaction is a locking or exclusive access.
typedef enum { gftNORMAL, gftEXCL, gftLOCK} gft_lock_type_enum;</p>
<p>scml2::gft_lock_type_enum lock_type;
SystemC Modeling Library Reference Manual
X-2025.06-SP1
164</p>
</section>
<section id="page-165">
<h2>Page 165<a class="headerlink" href="#page-165" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
scml2::gft_lock_type_extension *lock_type_ext;
transaction.get_extension_attr(lock_type_ext, lock_type);
◦
gftNORMAL: indicates a normal transaction as defined in the TLM2.0 base protocol. This is the
default for this extension.
◦
gftEXCL: indicates an exclusive read access, which means that the target cannot accept any
transactions by another initiator until the initiator has done a write to this address.
◦
gftLOCK: indicates a locked access is initiated by the initiator which implies the interconnect
bus ensure that only that initiator is has access to the target until the initiator unlocks the access
through a second access to the same location.
•
scml2::gft_access_mode_extension:
Is the GFT extension that indicates what the security attributes of the transaction are.
typedef enum { gftNORM, gftPRIV, gftNORM_NON_SECURE, gftPRIV_NON_SECURE}
gft_access_mode_enum;</p>
<p>scml2::gft_access_mode_enum access_mode;
scml2::gft_access_mode_extension *access_mode_ext;
transaction.get_extension_attr(access_mode_ext, access_mode);
◦
gftNORM: Indicates a normal TLM2.0 base protocol transaction. This is the default of the
extension.
◦
gftPRIV: Indicates a privileged access, which can be used to indicate the processing mode that
issued the transaction, can be used to restrict access to certain parts of the system.
◦
gftNORM_NON_SECURE: Indicates normal non-secure  access. The effect of this on the handling
of the transaction is system specific.
◦
gftPRIV_NON_SECURE: Indicates a priviliged non-secure  access. The effect of this on the
handling of the transaction is system specific.
•
scml2::gft_access_type_extension:
Is the GFT extension that indicates whether the access is a data or instruction access. The default is
gftDATA_ACCESS.
typedef enum { gftDATA_ACCESS, gftINST_ACCESS} gft_access_type_enum;</p>
<p>scml2::gft_access_type_enum access_type;
scml2::gft_access_type_extension *access_type_ext;
transaction.get_extension_attr(access_type_ext, access_type);
The GFT protocol definition is built according to the FT Modeling approach, so this means that the
extensions defined for the GFT protocol are not ignorable within the component. The GFT protocol
definition is built on top of the TLM2.0 base protocol so the TLM2.0 base protocol attributes are
always available. However, the GFT protocol defines certain extensions that overrule the TLM2.0
SystemC Modeling Library Reference Manual
X-2025.06-SP1
165</p>
</section>
<section id="page-166">
<h2>Page 166<a class="headerlink" href="#page-166" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
base protocol. Therefore, the following rules apply with regards to the TLM2.0 base protocol
attributes for a GFT transaction:</p>
<ol class="arabic simple">
<li><p>Burst_type: burst type should be taken from the burst_type  enum and not according to the
TLM2  base protocol rules. The burst type attribute should be valid with the WR_CMD  and RD_CMD
protocol states, the same applies for lock, access_mode  and access_type</p></li>
<li><p>tlm_response_status: this attribute should not be used, it is required to use the gft_rsp_enum.
The response should be valid with the WR_DATA_LAST_ACK  protocol state for writes, and with any
of the read data transfers for read transactions. There is only one error response allowed for the
whole transaction in case of writes, for reads multiple responses are allowed.</p></li>
<li><p>Byte_enables  are not supported in a GFT transaction, so the byte enable attributes should be
ignored.</p></li>
<li><p>It is not allowed to use IGNORE_COMMAND.</p></li>
<li><p>Streaming_width  shall be ignored.
The conversion between the GFT protocol definition and the TLM2.0 base protocol needs to take care
of these attribute semantics.
3.4.2. FT AXI API Definition
The FT AXI API definition is built on top of the TLM2.0 base protocol just like any other protocol in the
FT modeling approach. The FT AXI protocol definition adds the following extensions to the TLM2.0
base protocol:
•
scml2::axi_protocol_state_extension:
This is the payload extension that holds the protocol timing points for the AXI protocol it is used as
follows:
scml2::axi_protocol_state_enum protocol_state;
scml2::axi_protocol_state_extension *axi_state;
transaction.get_extension_attr(axi_state, protocol_state);
As socket that intends to communicate using the AXI protocol should indicate this using the
set_protocol  API:
P_socket.set_protocol&lt;scml2::axi_protocol_state_extension &gt;(“AXI”);
The AXI protocol defines the protocol states, each referring to a protocol timing point, as shown in
the following figure. They are represented in pairs to indicate the transfers that they represent.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
166</p></li>
</ol>
</section>
<section id="page-167">
<h2>Page 167<a class="headerlink" href="#page-167" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 60: AXI Protocol Definition
•
scml2::axi_response_extension:
This attribute models the RRESP[1:0]  and BRESP[1:0]  signals of the AXI protocol. Since these have
additional semantics compared to the TLM2.0 base protocol response attribute, there is a specific
AXI attribute for responses. The values correspond to the encodings of the AXI response signals
and follow the AXI rules:
◦
One response for the entire burst in case of writes.
◦
In case of a read transaction, the target can give different responses for the transfers in the burst.
◦
All data beats need to be executed independent of the response status.
◦
The default is axiOK.
The definition of the attribute values in relation to the AXI definition is given in the following table.
Table 45: AXI Definition Attribute Values
axi_rsp_enum
RRESP[1:0]
BRESP[1:0]
Response
Description
axiOK
b00
OKAY
Indicates that a normal access has been
successful, can indicate failure of an exclusive
access. This is the default for the extension.
axiEX_OK
b01
EXOKAY
Indicates an exclusive access has been
successful.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
167</p>
</section>
<section id="page-168">
<h2>Page 168<a class="headerlink" href="#page-168" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
axi_rsp_enum
RRESP[1:0]
BRESP[1:0]
Response
Description
axiSLV_ERR
b10
SLVERR
Is used to indicate a target error, which means
the transaction reached the target, but the target
wishes to return an error condition to the initiator.
axiDEC_ERR
b11
DECERR
Indicates a decode error by an interconnect
component, when there is no target at the
transaction address.
•
scml2::axi_burst_type_extension:
The burst type extension represents the ARBURST[1:0]  and AWBURST[1:0]  signals of the AXI
protocol. Since AXI defines an additional burst type than is supported using the TLM2.0 base
protocol, the specific extension is required. The default is axiFIXED.
typedef enum { axiFIXED, axiINCR, axiWRAP, axiBURST_ERR} axi_burst_type_enum;</p>
</section>
<section id="scml2-axi-burst-type-enum-burst-type-scml2-axi-burst-type-extension-burst-ext-transaction-get-extension-attr-burst-ext-burst-type-the-definition-of-the-attribute-values-in-relation-to-the-axi-definition-is-given-below-table-46-attribute-values-axi-burst-typ-e-enum-arburst-1-0-awburst-1-0-burst-type-description-access-axifixed-b00-fixed-fixed-address-burst-fifo-type-axiincr-b01-incr-incremental-address-burst-normal-sequential-memory-axiwrap-b10-wrap-incrementing-address-bursts-wrapping-to-a-lower-address-at-the-wrap-boundary-cache-line-axiburst-err-b11-reserved">
<h2>scml2::axi_burst_type_enum burst_type;
scml2::axi_burst_type_extension*burst_ext;
transaction.get_extension_attr(burst_ext, burst_type);
The definition of the attribute values in relation to the AXI definition is given below:
Table 46: Attribute Values
axi_burst_typ
e_enum
ARBURST[1:0]
AWBURST[1:0]
Burst
Type
Description
Access
axiFIXED
b00
FIXED
Fixed Address burst
FIFO-type
axiINCR
b01
INCR
Incremental address burst
Normal
sequential
memory
axiWRAP
b10
WRAP
Incrementing address bursts
wrapping to a lower address at the
wrap boundary
Cache line
axiBURST_ERR
b11
Reserved<a class="headerlink" href="#scml2-axi-burst-type-enum-burst-type-scml2-axi-burst-type-extension-burst-ext-transaction-get-extension-attr-burst-ext-burst-type-the-definition-of-the-attribute-values-in-relation-to-the-axi-definition-is-given-below-table-46-attribute-values-axi-burst-typ-e-enum-arburst-1-0-awburst-1-0-burst-type-description-access-axifixed-b00-fixed-fixed-address-burst-fifo-type-axiincr-b01-incr-incremental-address-burst-normal-sequential-memory-axiwrap-b10-wrap-incrementing-address-bursts-wrapping-to-a-lower-address-at-the-wrap-boundary-cache-line-axiburst-err-b11-reserved" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li></li>
</ul>
<p>•
scml2::axi_lock_type_extension:
The lock type extension is added to represent the atomic access support in AXI and represents the
values for the signals ARLOCK[1:0]  and AWLOCK[1:0].
typedef enum { axiNORMAL, axiEXCL, axiLOCK, axiLOCK_ERR} axi_lock_type_enum;</p>
<p>scml2::axi_lock_type_enum lock_type;
scml2::axi_lock_type_extension *lock_type_ext;
transaction.get_extension_attr(lock_type_ext, lock_type);
SystemC Modeling Library Reference Manual
X-2025.06-SP1
168</p>
</section>
<section id="page-169">
<h2>Page 169<a class="headerlink" href="#page-169" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The definition of the attribute values in relation to the AXI definition is given below:
Table 47: Attribute Values
axi_lock_type_enum
ARLOCK[1:0] AWLOCK[1:0]
Access Type
axiNORMAL
b00
Normal access
axiEXCL
b01
Exclusive access
axiLOCK
b10
Locked access
axiLOCK_ERR
b11
Reserved
•
scml2::axi_access_mode_extension:
Is an extension to represent the AWPROT[1:0]  and ARPROT[1:0]  signals, so only the signals related
to the protection unit. The default is axiNORM.
typedef enum { axiNORM, axiPRIV, axiNORM_NON_SECURE, axiPRIV_NON_SECURE}
axi_access_mode_enum;</p>
<p>scml2::axi_access_mode_enum access_mode;
scml2::axi_access_mode_extension *access_mode_ext;
transaction.get_extension_attr(access_mode_ext, access_mode);
The definition of the attribute values in relation to the AXI definition is given below:
Table 48: Attribute Values
axi_access_mode_enum
ARPROT[1:0]
AWPROT[1:0]
Protection Level
axiNORM
b00
Normal access
axiPRIV
b01
Privileged access
axiNORM_NON_SECURE
b10
Non secure normal access
axiPRIV_NON_SECURE
b11
Non secure privileged access
•
scml2::axi_access_type_extension:
This attribute represents ARPROT[2]  and AWPROT[2]  which indicate whether the transaction
represents a data or instruction access. It has been separated out to allow for easier conversion
to other protocols that also support access type information, but not necessarily combined with the
protection information as exists in AXI. The default is axiDATA_ACCESS.
typedef enum { axiDATA_ACCESS, axiINST_ACCESS} axi_access_type_enum;</p>
<p>scml2::axi_access_type_enum access_type;
SystemC Modeling Library Reference Manual
X-2025.06-SP1
169</p>
</section>
<section id="page-170">
<h2>Page 170<a class="headerlink" href="#page-170" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
scml2::axi_access_type_extension *access_type_ext;
transaction.get_extension_attr(access_type_ext, access_type);
The definition of the attribute values in relation to the AXI definition is given below:
Table 49: Attribute Values
axi_access_type_enum
ARPROT[2] AWPROT[2]
Access Type
axiDATA_ACCESS
b0
Data access
axiINST_ACCESS
b1
Instruction access
•
Cache support:
The AXI protocol defines cache information signals through ARCACHE[3:0]  and AWCACHE[3:0].
These signals are represented in the FT AXI protocol definition through separate Boolean
extensions. Notice the amba_  prefix for these extensions which allows to reuse them for other AMBA
protocol definitions.
DECLARE_EXTENSION(amba_cacheable_extension, bool, false);
DECLARE_EXTENSION(amba_bufferable_extension, bool, false);
DECLARE_EXTENSION(amba_cache_wr_alloc_extension, bool, false);
DECLARE_EXTENSION(amba_cache_rd_alloc_extension, bool, false);
The definition of the attribute values in relation to the AXI definition is given below:
amba_bufferable_extension
ARCACHE[0]  and AWCACHE[0]
Bufferable bit (B)
amba_cacheable_extension
ARCACHE[1]  and AWCACHE[1]
Cacheable bit©
amba_cache_rd_alloc_extension
ARCACHE[2]  and AWCACHE[2]
Read Allocate (RA)
amba_cache_wr_alloc_extension
ARCACHE[3]  and AWCACHE[3]
Write Allocate (WA)
•
User signals:
The AXI specification and also the FT AXI definition supports user extensions. These are user-
defined signals that are available in the FT AXI definition as sc_dt::sc_biguint&lt;1024&gt;  signals.
DECLARE_EXTENSION(amba_aw_user_signal_extension, sc_dt::sc_biguint&lt;1024&gt;, 0);
DECLARE_EXTENSION(amba_ar_user_signal_extension, sc_dt::sc_biguint&lt;1024&gt;, 0);
DECLARE_EXTENSION(amba_w_user_signal_extension, sc_dt::sc_biguint&lt;1024&gt;, 0);
DECLARE_EXTENSION(amba_r_user_signal_extension, sc_dt::sc_biguint&lt;1024&gt;, 0);
DECLARE_EXTENSION(amba_b_user_signal_extension, sc_dt::sc_biguint&lt;1024&gt;, 0);
•
scml2::axi_qos_extension:
The AXI specification and also the FT AXI definition supports QoS  signals. These signals are quality
of service signals that are available in the FT AXI definition as unsigned int  signals.
DECLARE_EXTENSION(axi_qos_extension, unsigned int, 0);
SystemC Modeling Library Reference Manual
X-2025.06-SP1
170</p>
</section>
<section id="page-171">
<h2>Page 171<a class="headerlink" href="#page-171" title="Permalink to this heading"></a></h2>
</section>
<section id="chapter-3-scml2-fast-timed-ft-modeling-these-represent-arqos-3-0-and-awqos-3-0-signals-in-axi-protocol-a-default-of-0-indicates-that-the-interface-is-not-participating-in-any-qos-scheme-note-this-signal-is-implemented-only-in-axi4-scml2-axi-region-extension-the-axi-specification-and-also-the-ft-axi-definition-supports-region-signals-these-are-to-support-multiple-regions-that-are-available-in-the-ft-axi-definition-as-unsigned-int-signals-declare-extension-axi-region-extension-unsigned-int-0-these-represent-arregion-3-0-and-awregion-3-0-signals-in-axi-protocol-the-4-bit-region-identifier-can-be-used-to-uniquely-identify-up-to-sixteen-different-regions-the-region-identifier-can-provide-a-decode-of-higher-order-address-bits-the-region-identifier-must-remain-constant-within-any-4-kilobyte-address-space-note-this-signal-is-implemented-only-in-axi4-scml2-axi-snoop-extension-the-axi-specification-and-also-the-ft-axi-definition-support-snoop-signals-these-are-to-support-different-kind-of-snoop-transactions-that-are-available-in-the-ft-axi-declare-extension-axi-snoop-extension-axi-snoop-enum-axiinvalidsnoop-in-ft-axi-enum-values-have-been-defined-which-represent-a-combination-of-barrier-domain-and-snoop-signals-this-is-done-to-ease-modeling-of-axi4-devices-the-definition-of-the-attribute-values-in-relation-to-the-axi-definition-is-given-below-table-50-axi-definition-attribute-values-axi-snoop-enum-ax-bar-0-axdomain-1-0-arsnoop-3-0-awsnoop-2-0-snoop-request-type-axiinvalidsnoop">
<h2>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
These represent ARQOS[3:0]  and AWQOS[3:0]  signals in AXI protocol. A default of 0  indicates that
the interface is not participating in any QoS scheme.
Note:
This signal is implemented only in AXI4.
•
scml2::axi_region_extension:
The AXI specification and also the FT AXI definition supports Region  signals. These are to support
multiple regions that are available in the FT AXI definition as unsigned int  signals.
DECLARE_EXTENSION(axi_region_extension, unsigned int, 0);
These represent ARREGION[3:0]  and AWREGION[3:0]  signals in AXI protocol.
The 4-bit region identifier can be used to uniquely identify up to sixteen different regions. The region
identifier can provide a decode of higher order address bits. The region identifier must remain
constant within any 4 kilobyte address space.
Note:
This signal is implemented only in AXI4.
•
scml2::axi_snoop_extension
The AXI specification and also the FT AXI definition support Snoop signals. These are to support
different kind of snoop transactions that are available in the FT AXI.
DECLARE_EXTENSION(axi_snoop_extension, axi_snoop_enum, axiInvalidSnoop);
In FT AXI, enum  values have been defined which represent a combination of Barrier, Domain  and
Snoop  Signals. This is done to ease modeling of AXI4 devices.
The definition of the attribute values in relation to the AXI definition is given below:
Table 50: AXI Definition Attribute Values
axi_snoop_enum
Ax
BAR
[0]
AxDOMAIN[1:0]
ARSNOOP[3:0]/
AWSNOOP[2:0]
Snoop Request Type
axiInvalidSnoop<a class="headerlink" href="#chapter-3-scml2-fast-timed-ft-modeling-these-represent-arqos-3-0-and-awqos-3-0-signals-in-axi-protocol-a-default-of-0-indicates-that-the-interface-is-not-participating-in-any-qos-scheme-note-this-signal-is-implemented-only-in-axi4-scml2-axi-region-extension-the-axi-specification-and-also-the-ft-axi-definition-supports-region-signals-these-are-to-support-multiple-regions-that-are-available-in-the-ft-axi-definition-as-unsigned-int-signals-declare-extension-axi-region-extension-unsigned-int-0-these-represent-arregion-3-0-and-awregion-3-0-signals-in-axi-protocol-the-4-bit-region-identifier-can-be-used-to-uniquely-identify-up-to-sixteen-different-regions-the-region-identifier-can-provide-a-decode-of-higher-order-address-bits-the-region-identifier-must-remain-constant-within-any-4-kilobyte-address-space-note-this-signal-is-implemented-only-in-axi4-scml2-axi-snoop-extension-the-axi-specification-and-also-the-ft-axi-definition-support-snoop-signals-these-are-to-support-different-kind-of-snoop-transactions-that-are-available-in-the-ft-axi-declare-extension-axi-snoop-extension-axi-snoop-enum-axiinvalidsnoop-in-ft-axi-enum-values-have-been-defined-which-represent-a-combination-of-barrier-domain-and-snoop-signals-this-is-done-to-ease-modeling-of-axi4-devices-the-definition-of-the-attribute-values-in-relation-to-the-axi-definition-is-given-below-table-50-axi-definition-attribute-values-axi-snoop-enum-ax-bar-0-axdomain-1-0-arsnoop-3-0-awsnoop-2-0-snoop-request-type-axiinvalidsnoop" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li></li>
<li></li>
</ul>
<p>Initialization
Value
axiReadNoSnoop
0b0
0b00/0b11
ARSNOOP = 0b0000
Read No Snoop
axiReadOnce
0b0
0b01/0b10
ARSNOOP = 0b0000
Read Once
SystemC Modeling Library Reference Manual
X-2025.06-SP1
171</p>
</section>
<section id="page-172">
<h2>Page 172<a class="headerlink" href="#page-172" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
axi_snoop_enum
Ax
BAR
[0]
AxDOMAIN[1:0]
ARSNOOP[3:0]/
AWSNOOP[2:0]
Snoop Request Type
axiReadShared
0b0
0b01/0b10
ARSNOOP = 0b0001
Read Shared
axiReadClean
0b0
0b01/0b10
ARSNOOP = 0b0010
Read Clean
axiReadNotShareDirty
0b0
0b01/0b10
ARSNOOP = 0b0011
Read Not Shared
Dirty
axiReadUnique
0b0
0b01/0b10
ARSNOOP = 0b0111
Read Unique
axiCleanUnique
0b0
0b01/0b10
ARSNOOP = 0b1011
Clean Unique
axiMakeUnique
0b0
0b01/0b10
ARSNOOP = 0b1100
Make Unique
axiCleanShared
0b0
0b00/0b01/0b10
ARSNOOP = 0b1000
Clean Shared
axiCleanInvalid
0b0
0b00/0b01/0b10
ARSNOOP = 0b1001
Clean Invalid
axiMakeInvalid
0b0
0b00/0b01/0b10
ARSNOOP = 0b1101
Make Invalid
axiDVM_Complete
0b0
0b01/0b10
ARSNOOP = 0b1110
DVM Complete
axiDVM_Message
0b0
0b10/0b10
ARSNOOP = 0b1111
DVM Message
axiWriteNoSnoop
0b0
0b00/0b11
AWSNOOP = 0b000
Write No Snoop
axiWriteUnique
0b0
0b01/0b10
AWSNOOP = 0b000
Write Unique
axiWriteLineUnique
0b0
0b01/0b10
AWSNOOP = 0b001
Write Line Unique
axiWriteClean
0b0
0b00/0b01/0b10
AWSNOOP = 0b010
Write Clean
axiWriteBack
0b0
0b00/0b01/0b10
AWSNOOP = 0b011
Write Back
axiEvict
0b0
0b01/0b10
AWSNOOP = 0b100
Evict
axiWriteEvict
0b0
0b00/0b01/0b10
AWSNOOP = 0b101
WriteEvict
•
scml2::axi_domain_extension
The AXI specification and also the FT AXI definition support Domain  signals. These indicate the
shareability domain of a read/write  transaction.
DECLARE_EXTENSION(axi_domain_extension, axi_domain_enum, axiNon_Shareable);
These represent ARDOMAIN[1:0]  and AWDOMAIN[1:0]  signals in AXI protocol.
The definition of the attribute values in relation to the AXI definition is given below.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
172</p>
</section>
<section id="page-173">
<h2>Page 173<a class="headerlink" href="#page-173" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Table 51: AXI Definition Attribute Values
axi_domain_enum
AxDOMAIN[1:0]
Domain Type
axiNon_Shareable
0b00
Non-Shareable
axiInner_Shareable
0b01
Inner Shareable
axiOuter_Shareable
0b10
Outer Shareable
axiSystem
0b11
System
•
scml2::axi_barrier_extension
The AXI specification and also the FT AXI definition support Barrier  signals. These indicate a
read/write  barrier transaction.
DECLARE_EXTENSION(axi_barrier_extension, axi_barrier_enum, axiNormal);
These represent ARBAR[1:0]  and AWBAR[1:0]  signals in AXI protocol.
The definition of the attribute values in relation to the AXI definition is given below.
Table 52: AXI Definition Attribute Values
axi_barrier_enum
AxBAR[1:0]
Barrier Type
axiNormal
0b00
Normal access, respecting
barriers
axiMemory
0b01
Memory Barrier
axiIgnore
0b10
Normal access, ignoring
barriers
axiSynchronizing
0b11
Synchronization barrier
•
scml2::axi_wr_unique_extension
The AXI specification and also the FT AXI definition support AWUNIQUE  signals. These can be used
to improve the operation of lower levels of cache hierarchy, such as a L3 or system level cache.
DECLARE_EXTENSION(axi_wr_unique_extension, bool, false);
SystemC Modeling Library Reference Manual
X-2025.06-SP1
173</p>
</section>
<section id="page-174">
<h2>Page 174<a class="headerlink" href="#page-174" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
All payload attributes should be created by the initiator at the start of the transaction (AWVALID  or
ARVALID) to make sure that all extensions that is used are available. All AXI attributes should be set by
the initiator at the start of the transaction, except:
•
axi_rsp_enum: Should be set by the target. It can be set one time for writes (with the BVALID  phase)
and can be set with each data beat (RVALID) for reads.
•
The content pointed to by the data_ptr  can be modified during the transaction:
◦
By the initiator to make write data available per write data beat.
◦
By the target to make read data available per read data beat.
◦
A target should not use the data_ptr  ahead of the first WVALID  in case of write transactions.
The AXI protocol definition is built according to the FT Modeling approach, so this means that the
extensions defined for the AXI protocol are not ignorable within the component. The AXI protocol
definition is built on top of the TLM2.0 base protocol so the TLM2.0 base protocol attributes are always
available. However, the AXI protocol defines certain extensions that overrule the TLM2.0 base protocol.
Therefore, the following rules apply with regards to the TLM2.0 base protocol attributes for a AXI
transaction:</p>
<ol class="arabic simple">
<li><p>Burst_type: The burst type should be taken from the burst_type  enum and not according to the
TLM2-GP rules. The burst type attribute should be valid with the AWVALID  and ARVALID  protocol
states, the same applies for lock, access_mode  and access_type.</p></li>
<li><p>tlm_response_status: This attribute should not be used, it is required to use the axi_rsp_enum.
The response should be valid with the BVALID  protocol state, or with any of the read data transfers.
There is only one error response allowed for the whole transaction in case of writes, for reads
multiple responses are allowed.</p></li>
<li><p>Data_length  attribute is limited to the permitted values in AXI: it represents AWLEN/ARLEN  as follows:
data_length = AWLEN + 1;</p></li>
<li><p>Byte_enables  represent the WSTRB  note, which for AXI byte enables cannot be wider than the
BUSWIDTH  template parameter on the sockets.</p></li>
<li><p>It is not allowed to use IGNORE_COMMAND .</p></li>
<li><p>Streaming_width  is ignored.</p></li>
<li><p>The AXI signals AWSIZE  and ARSIZE  are represented by the common extension
burst_size_extension, as follows:
ARSIZE = log2(burst_size_extension == 0? BUSWIDTH/8: burst_size_extension)
The values are limited to the allowed values in AXI (1, 2, 4, 8, 16, 32, 64  and 128).
SystemC Modeling Library Reference Manual
X-2025.06-SP1
174</p></li>
</ol>
</section>
<section id="page-175">
<h2>Page 175<a class="headerlink" href="#page-175" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
8. The AXI signals AWID, ARID, WID, RID, BID  are represented by the common extension
trans_id_extension.
9. The common extension wrap_addr_extension  represents the start address for a wrapping burst
in AXI, the payload address always refers to the lowest address in the transaction as per the TLM2
standard.
3.4.3. FT ACE API Definition
The FT ACE API definition is built on top of the FT AXI protocol and includes all the APIs as defined by
FT AXI protocol.
The FT ACE protocol definition adds the following extensions to the FT AXI protocol:
•
scml2::ace_response_extension
This extension models the RRESP[3:2]  and CRRESP[3:2]  signals of the ACE protocol. These
additional read/snoop  response bits provide information for shareable read  transaction.
In case of a read  transaction, the ace_response_extension  must have constant value for all data
beats in the burst.
The definition of the attribute values in relation to the ACE definition is given in the following table.
Table 53: ACE Definition Attribute Values
ace_response_enum
RRESP[3:
2]/CRRESP[3
:2]
Response
Meaning
aceRspNotSharedClean
b00
Not Shared &amp;
Clean
Indicates that initiator does not take the
responsibility to ensure that the cache
line is written to the main memory.
Also, it indicates that the line is the only
cached copy.
aceRspNotSharedDirty
b01
Not Shared &amp;
Dirty
Indicates that cache line is dirty and
initiator takes the responsibility to
ensure that the cache line is written to
the main memory. Also, it indicates that
the line is the only cached copy.
aceRspSharedClean
b10
Shared &amp;
Clean
Indicates that initiator does not take the
responsibility to ensure that the cache
line is written to the main memory.
Also, it indicates that another copy
of the data might be held in another
cache.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
175</p>
</section>
<section id="page-176">
<h2>Page 176<a class="headerlink" href="#page-176" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
ace_response_enum
RRESP[3:
2]/CRRESP[3
:2]
Response
Meaning
aceRspSharedDirty
b11
Shared &amp;
Dirty
Indicates that cache line is dirty and
initiator takes the responsibility to
ensure that the cache line is written to
the main memory. Also, it indicates that
another copy of the data might be held
in another cache.
•
scml2::ace_rsp_pass_data_extension
This extension models the CRRESP[0]  signal of the ACE protocol. It indicates whether the snoop
request will have data transfer or not.
DECLARE_EXTENSION(ace_rsp_pass_data_extension, bool, false);
When set to true, it indicates that a full cache line of data will be provided on the Snoop Data
channel.
•
scml2::ace_rsp_was_unique_extension
This extension models the CRRESP[4]  signal of the ACE protocol. It provides information on the
unique/shared state of the cache line before the snoop request.
DECLARE_EXTENSION(ace_rsp_was_unique_extension, bool, false);
When set to true, it indicates that the cache line was in unique state before snoop request.
Note:
FT AXI protocol has no semantics to indicate CRRESP[1]  bit. This is because the bit represents
hardware errors which are not modeled in modeling world.
3.4.4. FT AXI4 Stream API Definition
The FT AXI4 Stream API definition is built on top of the TLM2.0 base protocol just like any other
protocol in the FT modeling approach. The FT AXI4 Stream protocol definition adds the following new
extensions to the TLM2.0 base protocol.
•
scml2::axi4_stream_protocol_state_extension
This is the payload extension that holds the protocol timing points for the AXI4 Stream protocol.
A socket that intends to communicate using the AXI4 Stream protocol should indicate this using the
set_protocol  API:
P_socket.set_protocol&lt;scml2::axi4_stream_protocol_state_extension</p>
<blockquote>
<div><p>(“AXI4-Stream”);
SystemC Modeling Library Reference Manual
X-2025.06-SP1
176</p>
</div></blockquote>
</section>
<section id="page-177">
<h2>Page 177<a class="headerlink" href="#page-177" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The AXI4 Stream protocol defines the protocol states, each referring to a protocol timing point, as
shown below. They are shown in pairs to indicate the transfers that they represent.
Figure 61: FT AXI4 Stream API Definition
•
scml2::axi4_stream_tkeep_extension
DECLARE_ARRAY_EXTENSION(axi4_stream_tkeep_extension, unsigned char);
The value of this extension is unsigned char*  array with length equal to number of valid bytes
in the array. This array corresponds to the TKEEP  signal of the AXI4 Stream interface and gives
information on the NULL  bytes in the data stream. The semantics for this extension follow the same
rules that are defined for byte enable array in TLM2 Reference manual. The following rules are
important to note:
◦
The elements in the tkeep_extension  array shall be interpreted as follows. A value of 0  at
index i  shall indicate that byte at index i  in data stream is NULL  bytes, and a value of 0xff  shall
indicate that the corresponding byte is either Positional  or Data  byte depending on value of
byte_enable  array at the same index. The meaning of all other values shall be undefined. The
value 0xff  has been chosen so that the tkeep  extension array can be used directly as a mask.
◦
The tkeep  extension mask may be defined by a small pattern applied repeatedly or by a large
pattern covering the whole data array.
◦
If the length of tkeep  extension is 0, then it implies that the value of tkeep  array is assumed to
be 0xff  for all the data bytes, that is, there are no NULL  bytes in the stream.
This extension will be added to the TLM2 payload using the following semantics:
SET_ARRAY_EXT_ATTR(trans, scml2::axi4_stream_tkeep_extension, unsigned char,
tkeep_array_ptr, datalength );
Where:
trans
Is the FT payload.
tkeep_array_ptr
Returns the pointer to start of extension.
data length
Is the length of the array in bytes.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
177</p>
</section>
<section id="page-178">
<h2>Page 178<a class="headerlink" href="#page-178" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
◦
The macro will add the axi4_stream_tkeep_extension  to the payload, if it does not exist
already.
◦
This gets automatically resized in case, the extension existed already and the original valid count
was less than the count specified.
To retrieve the value of the array, use the following macro:
GET_ARRAY_EXT_ATTR(trans, scml2:: axi4_stream_tkeep_extension, unsigned char,
tkeep_array_ptr, num_entries);
◦
The number of valid entries gets stored in num_entries .
◦
The start of the array is stored in tkeep_array_ptr  variable which is of type unsigned char* .
•
scml2::axi4_stream_tuser_extension
This extension contains value of TUSER  signal on an AXI4 Stream interface. The TUSER  signal
contains the user sideband information that needs to be sent with the data stream.
This is not a new extension, but a typedef  for scml2:: amba_wdata_usr_sig_extension.
•
scml2::axi4_stream_tdest_extension
DECLARE_EXTENSION(axi4_stream_tdest_extension, unsigned, 0);
This extension can be used to specify TDEST  signal on an AXI4 Stream interface.
In addition to the above new extensions, AXI4 Stream protocol uses the following extensions that
are already defined in FT Modeling.
•
scml2::trans_id_extension
DECLARE_EXTENSION(transaction_id_extension, unsigned int, 0);
This extension contains value of TID  signal on an AXI4 Stream interface. The TID  signal specifies
the data stream identifier that indicates different streams.
TDATA  and TSTRB  signals of the AXI4 Stream protocol are modeled using the existing semantics of
data  pointer and byte enable  pointer in TLM2 payload.
TDEST  signal is modeled by address field of the TLM Generic Payload. The following table
summarizes all the signals of the AXI4 Stream protocol and their corresponding payload semantics.
Table 54: AXI4 Stream Protocol Signals and Payload Semantics
AXI4 Stream
Interface Signal
Names
FT Modeling Semantics
TVALID
Value on axi4_stream_protocol_state_extension.
TREADY
Value on axi4_stream_protocol_state_extension.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
178</p>
</section>
<section id="page-179">
<h2>Page 179<a class="headerlink" href="#page-179" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
AXI4 Stream
Interface Signal
Names
FT Modeling Semantics
TDATA
Data  pointer on TLM2 Payload.
TSTRB
Byte Enable  pointer on TLM2 Payload one-to- one correspondence with Data
pointer.
TKEEP
Value on scml2::axi4_stream_tkeep_extension.
TLAST
Value on axi4_stream_protocol_state_extension.
TID
Value on scml2::transaction_id_extension.
TDEST
Address field of TLM2 payload or axi4_stream_tdest_extension.
TUSER
Value on scml2:: amba_wdata_usr_sig_extension.
3.4.5. FT CHI API Definition
The FT CHI API definition is built on top of the TLM2.0 base protocol just like any other protocol in the
FT modeling approach. The FT CHI protocol definition adds the following extensions to the TLM2.0
base protocol:
•
scml2::chi_rnf_protocol_state_extension
This is the payload extension, that holds the protocol timing points for the CHI protocol. Since CHI
RN-F includes all the CHI channels, this extension can be used to model timing points for RN-D, RN-
I, SN-F and SN-I.
•
scml2::chi_allow_retry_extension
This extension models the AllowRetry  CHI protocol signal.
•
scml2::chi_req_opcode_extension
This extension models the Opcode  CHI protocol signal on Request channel.
•
scml2::chi_snp_opcode_extension
This extension models the Opcode  CHI protocol signal on Snoop request channel.
•
scml2::chi_data_opcode_extension
This extension models the Opcode  CHI protocol signal on Data channel.
•
scml2::chi_resp_opcode_extension
This extension models the Opcode  CHI protocol signal on Response channel.
•
scml2::chi_atomic_opcode_extension
SystemC Modeling Library Reference Manual
X-2025.06-SP1
179</p>
</section>
<section id="page-180">
<h2>Page 180<a class="headerlink" href="#page-180" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
This extension models the sub opcodes for atomic load and store transactions.
•
scml2::chi_data_pull_extension
This extension models the DataPull  CHI protocol signal.
•
scml2::chi_data_source_extension
This extension models the DataSource  CHI protocol signal.
•
scml2::chi_dbid_extension
This extension models the DBID  CHI protocol signal.
•
scml2::chi_do_not_data_pull_extension
This extension models the DoNotDataPull  CHI protocol signal.
•
scml2::chi_do_not_go_to_sd_extension
This extension models the DoNotGoToSD  CHI protocol signal.
•
scml2::chi_endian_extension
This extension models the Endian  CHI protocol signal.
•
scml2::chi_exclusive_extension
This extension models the Exclusive  CHI protocol signal.
•
scml2::chi_exp_comp_ack_extension
This extension models the ExpCompAck  CHI protocol signal.
•
scml2::chi_fwd_nid_extension
This extension models the FwdNID  CHI protocol signal.
•
scml2::chi_fwd_state_extension
This extension models the FwdState  CHI protocol signal.
•
scml2::chi_fwd_txnid_extension
This extension models the FwdTxnId  CHI protocol signal.
•
scml2::chi_home_nid_extension
This extension models the HomeNid  CHI protocol signal.
•
scml2::chi_likely_shared_extension
This extension models the LikelyShared  CHI protocol signal.
•
scml2::chi_lpid_extension
This extension models the LPID  CHI protocol signal.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
180</p>
</section>
<section id="page-181">
<h2>Page 181<a class="headerlink" href="#page-181" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
•
scml2::chi_memattr_early_write_ack_extension
This extension models the CHI MemAttr[0]  protocol signal.
•
scml2::chi_memattr_device_extension
This extension models the MemAttr[1]  CHI protocol signal.
•
scml2::chi_memattr_cacheable_extension
This extension models the MemAttr[2]  CHI protocol signal.
•
scml2::chi_memattr_allocate_hint_extension
This extension models the MemAttr[3]  CHI protocol signal.
•
scml2::chi_ccid_extension
This extension models the CCID  CHI protocol signal.
•
scml2::chi_dataid_extension
This extension models the DataID  CHI protocol signal.
•
scml2::chi_data_check_extension
This extension models the DataCheck  CHI protocol signal.
•
scml2::chi_poison_extension
This extension models the Poison  CHI protocol signal.
•
scml2::chi_non_secure_extension
This extension models the NS  CHI protocol signal.
•
scml2::chi_order_extension
This extension models the Order  CHI protocol signal.
•
scml2::chi_p_crd_type_extension
This extension models the PCrdType  CHI protocol signal.
•
scml2::chi_qos_extension
This extension models the QoS  CHI protocol signal.
•
scml2::chi_resp_extension
This extension models the Resp  CHI protocol signal.
•
scml2::chi_resp_err_extension
This extension models the RespErr  CHI protocol signal.
•
scml2::chi_data_resp_extension
SystemC Modeling Library Reference Manual
X-2025.06-SP1
181</p>
</section>
<section id="page-182">
<h2>Page 182<a class="headerlink" href="#page-182" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
This extension models the Resp  CHI protocol signal on Data channel.
•
scml2::chi_data_resp_err_extension
This extension models the RespErr  CHI protocol signal on Data channel.
•
scml2::chi_ret_to_src_extension
This extension models the RetToSrc  CHI protocol signal.
•
scml2::chi_return_nid_extension
This extension models the ReturnNID  CHI protocol signal.
•
scml2::chi_rsvdc_extension
This extension models the RSVDC  CHI protocol signal.
•
scml2::chi_return_txnid_extension
This extension models the ReturnTxnID  CHI protocol signal.
•
scml2::chi_snoop_me_extension
This extension models the SnoopMe  CHI protocol signal.
•
scml2::chi_snp_attr_extension
This extension models the SnpAttr  CHI protocol signal.
•
scml2::chi_srcid_extension
This extension models the SrcID  CHI protocol signal.
•
scml2::chi_stash_lpid_extension
This extension models the StashLPID  CHI protocol signal.
•
scml2::chi_stash_lpid_valid_extension
This extension models the StashLPIDValid  CHI protocol signal.
•
scml2::chi_stash_nid_extension
This extension models the StashNID  CHI protocol signal.
•
scml2::chi_stash_nid_valid_extension
This extension models the StashNIDValid  CHI protocol signal.
•
scml2::chi_req_tgtid_extension
This extension models the TgtID  CHI protocol signal on Request channel.
•
scml2::chi_data_tgtid_extension
This extension models the TgtID  CHI protocol signal on Data channel.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
182</p>
</section>
<section id="page-183">
<h2>Page 183<a class="headerlink" href="#page-183" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
•
scml2::chi_resp_tgtid_extension
This extension models the TgtID  CHI protocol signal on Response channel.
•
scml2::chi_req_txnid_extension
This extension models the TxnID  CHI protocol signal on Request and Snoop channel.
•
scml2::chi_resp_txnid_extension
This extension models the TxnID  CHI protocol signal on Response channel.
•
scml2::chi_data_txnid_extension
This extension models the TxnID  CHI protocol signal on Data channel.
•
scml2::chi_vmid_extension
This extension models the VMIDExt  CHI protocol signal.
•
scml2::chi_deep_extension
This extension models the Deep  CHI protocol signal.
•
scml2::chi_pgroup_id_extension
This extension models the PGroupId  CHI protocol signal.
•
scml2::chi_mpam_extension
This extension models the MPAM  CHI protocol signal.
•
scml2::chi_resp_cbusy_extension
This extension models the CBusy  CHI protocol signal on Response channel.
•
scml2::chi_data_cbusy_extension
This extension models the CBusy  CHI protocol signal on Data channel.
•
scml2::chi_slc_rep_hint_extension
This extension models the SLCRepHint  CHI protocol signal.
•
scml2::chi_do_dwt_extension
This extension models the DoDWT  CHI protocol signal.
•
scml2::chi_stash_group_id_extension
This extension models the StashGroupId  CHI protocol signal.
•
scml2::chi_tag_group_id_extension
This extension models the TagGroupId  CHI protocol signal.
•
scml2::chi_req_tag_op_extension
SystemC Modeling Library Reference Manual
X-2025.06-SP1
183</p>
</section>
<section id="page-184">
<h2>Page 184<a class="headerlink" href="#page-184" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
This extension models the TagOp  CHI protocol signal on Request channel.
•
scml2::chi_data_tag_op_extension
This extension models the TagOp  CHI protocol signal on Data channel.
•
scml2::chi_resp_tag_op_extension
This extension models the TagOp  CHI protocol signal on Response channel.
•
scml2::chi_tag_extension
This extension models the Tag  CHI protocol signal.
•
scml2::chi_tag_update_extension
This extension models the TU  CHI protocol signal.
•
scml2::chi_trace_tag_extension
This extension models the TraceTag  CHI protocol signal.
3.4.6. FT PCIe API Definition
The FT PCIe API definition is built on top of the TLM2.0 base protocol just like any other protocol in the
FT modeling approach. The FT PCIe protocol definition adds the following extensions to the TLM2.0
base protocol.
•
pcie_req_tlp_extension
This extension models the contents of PCIe Request TLP.
•
pcie_cpl_tlp_extension
This extension models the contents of PCIe Completion TLP.
•
pcie_credit_dllp_extension
This extension models the contents of PCIe Credit DLLP.
•
pcie_dllp_extension
This extension models the contents of all other DLLPs, except Credit DLLP.
•
pcie_protocol_state_extension
This extension holds the protocol timing points for FT PCIe protocol.
Contents of these extensions are defined in ${SNPS_VP_HOME}/common/include/scml2_tlm2/
snps_tlm2_extensions/snps_tlm2_pcie_proto_extension.h.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
184</p>
</section>
<section id="page-185">
<h2>Page 185<a class="headerlink" href="#page-185" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
3.4.7. FT CXL API Definition
The FT CXL API definition is built on top of the TLM2.0 base protocol just like any other protocol in the
FT modeling approach. The FT CXL protocol definition adds the following extensions to the TLM2.0
base protocol.
•
cxl_mem_m2s_req_extension
This extension models the contents of CXL.mem  request message (read/write request to CXL
memory).
•
cxl_mem_s2m_ndr_extension
This extension models the contents of CXL.mem  non-data response message (write response from
CXL memory).
•
cxl_mem_s2m_drs_extension
This extension models the contents of CXL.mem  data response message (read data from CXL
memory).
Contents of these extensions are defined in ${SNPS_VP_HOME}/common/include/scml2_tlm2/
snps_tlm2_extensions/snps_tlm2_cxl_proto_extension.h.
3.5. Protocol Checker
P
r
o
t
o
c
o
l</p>
<p>C
h
e
c
k
e
r
This chapter describes:
•
Introduction
•
Features
•
Input Requirements
•
Getting Started
3.5.1. Introduction
Protocol checker is a utility added in extended SCML2 initiator and target socket to enable verification of
FT  protocol semantics in the TLM2 peripherals. It supports the following protocols:
•
TLM2  FT  AXI
•
TLM2  FT  GFT
•
TLM2  GP
SystemC Modeling Library Reference Manual
X-2025.06-SP1
185</p>
</section>
<section id="page-186">
<h2>Page 186<a class="headerlink" href="#page-186" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
3.5.2. Features
This section describes the various protocol violations reported by Protocol Checker. To detect a
violation, Protocol Checker applies the standard TLM2 FT  and TLM2 GP  protocol rules for each protocol,
and reports if any of the rules is violated.
An invalid state transition by the initiator or target is reported as State Transition violation. For valid state
transitions, see FT GFT Protocol Definition and FT AXI API Definition. For TLM2  GP, phase transition is
checked. For example, in the FT  AXI  protocol ARREADY  to BVALID  is an invalid transition and is reported
as State Transition violation by Protocol Checker, as shown below.
Figure 62: State Transition ARREADY — BVALID is Invalid
The Protocol Checker reports State Transition Timing violation if minimum delay requirement between
any valid state transitions is not met. To validate the timing, it applies Timing annotation rules as
mentioned in Table 38, table Table 40 and Table 41. This violation is not reported for TLM2  GP  as the
base protocol does not have any rules regarding phase transition timing.
The Protocol Checker reports State Transition Timing violation, as the minimum requirement of one
clock delay between ARVALID  and RVALID  is not met. This is indicated by red signal in the figure below.
The green signal indicates call at delay of one clock cycle, as required by the protocol definition.
Figure 63: State Transition Timing Violation
Checking for channel availability is a universal feature of FT  modeling that needs to be verified for every
protocol. The channel owner, who initiates access to that channel, is responsible to ensure that the
channel is free before you invoke a new access on the channel. If the channel is accessed before it is
free, the Protocol Checker reports Channel violation.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
186</p>
</section>
<section id="page-187">
<h2>Page 187<a class="headerlink" href="#page-187" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
3.5.3. Input Requirements
To report State Transition Timing violations, Protocol Checker requires clock period at which initiators
and targets operate. For this, it relies on the extended scml2  sockets that have an additional user API,
set_clock. This API should be called by each initiator and target at the end of elaboration to specify
the clock period at which they will operate.
Note:
If the user model does not call set_clock  to set the clock period, the Protocol Checker does not
report timing violations.
3.5.4. Getting Started
To enable or disable the Protocol Checker:</p>
<ol class="arabic simple">
<li><p>From the VP Explorer menu bar, select Analysis&gt;Configure.
The Configure Analysis dialog box appears.
Figure 64: Configure Analysis Dialog Box — Enabling Analysis</p></li>
<li><p>Expand the General node and select Protocol Checker.</p></li>
<li><p>Toggle the checkboxes on right-hand side panel to enable or disable the Protocol Checker.
To view the results of your analysis, after the simulation suspends or completes:</p></li>
<li><p>Open the Results view and right-click on the Protocol Checker item for your model.</p></li>
<li><p>From the context menu, select Send To&gt;Protocol Checker Trace/Stats.
Where, Protocol Checker Stats is the statistic data that depicts the number of violations and Protocol
Checker Trace is the trace data that shows the event corresponding to the time of violation.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
187</p></li>
</ol>
</section>
<section id="page-188">
<h2>Page 188<a class="headerlink" href="#page-188" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 65: Viewing Results
This section provides example of the slicing parameters that you can use to understand the violations.
•
Metric
•
Calling_Direction
•
Reason_Code
•
State_Transition
•
Transaction_Type
Figure 66: Bifurcating Results
Metric
Default view that shows all the existing violations in a single view.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
188</p>
</section>
<section id="page-189">
<h2>Page 189<a class="headerlink" href="#page-189" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
For example:
Protocol Checker (PROTOCOL_VIOLATION)=12  depicts, protocol violation occurred 12 times during
the simulation, as shown below.
Figure 67: Metric Slicing
Calling_Direction
You can bifurcate results on calling direction, or the originator of violations.
For example:
Protocol Checker (Target) = 10  depicts, target is responsible for these violations, as shown figure
below.
Figure 68: Calling_Direction Slicing
Reason_Code
Specifies the reason of violation.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
189</p>
</section>
<section id="page-190">
<h2>Page 190<a class="headerlink" href="#page-190" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
For example:
Protocol Checker (Timing)  depicts, timing violation has occurred, as shown below.
Figure 69: Reason_Code Slicing
State_Transition
Specifies the state transition associated with the reported violation.
For example:
Protocol Checker (ARVALID_2_RVALID_LAST)  depicts, violation occurred while going from ARVALID
to RVALID_LAST, as shown below.
Figure 70: State_Transition Slicing
SystemC Modeling Library Reference Manual
X-2025.06-SP1
190</p>
</section>
<section id="page-191">
<h2>Page 191<a class="headerlink" href="#page-191" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Transaction_Type
Bifurcates data on the type of transaction. Data is separated for READ  and WRITE  transactions, as shown
below.
Figure 71: Transaction_Type Slicing
You can also enable TLM  port tracing to get the associated transaction for a particular violation, as
shown below.
Figure 72: Interpolating with TLM Port Trace
You can use multiple slicing options simultaneously to slice the data, an example is shown below.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
191</p>
</section>
<section id="page-192">
<h2>Page 192<a class="headerlink" href="#page-192" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
To slice the data using Reason_Code, Transaction_Type, Calling_Direction:</p>
<ol class="arabic simple">
<li><p>In Chart view, click on Configure on the left hand side, as shown below.
Figure 73: Example of Multiple Slicing</p></li>
<li><p>Set the required slicing parameters to true.
For example:
Protocol Checker (Reason_code=Timing, Calling_Direction= Target,
Transaction_Type=Read)  depicts, timing violation by target for read transaction.
If you interpolate it with TLM  port trace, RData  starts in parallel with Raddr  which causes timing violation.
This is because, the protocol demands a minimum of clock cycle delay between the two.
3.6. Protocol Conversion
When connecting two FT sockets with different protocol, the FT infrastructure automatically introduces
implicit protocol conversion logic. These protocol converter blocks are not visible in Platform Architect
GUI. They are instantiated between sockets at run-time based on the socket protocol. Typically
connected sockets have identical TLM Port Traces when visualized in PA Studio. However, when
implicit protocol conversion is enabled, the two connected sockets show different TLM Port Traces
based on the protocol set.
Table 55: Supported Protocol Converters
From (Initiator)
To (Target)
TLM2_GP
FT AXI
TLM2_GP
FT GFT
SystemC Modeling Library Reference Manual
X-2025.06-SP1
192</p></li>
</ol>
</section>
<section id="page-193">
<h2>Page 193<a class="headerlink" href="#page-193" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Table 55: Supported Protocol Converters (Continued)
From (Initiator)
To (Target)
FT AXI
TLM2_GP
FT AXI
FT GFT
FT GFT
TLM2_GP
FT GFT
FT AXI
Simulation may terminate if you connect two sockets with different protocols where implicit protocol
conversion is not available.
Example: When connecting an AXI socket with CHI socket, simulation terminates with an error
message. One such error message is shown as follows.
Error!! HARDWARE.HW.HW.i_VPU.DRVR.p_socket (AXI) is connected to a socket with
different protocol (CHI)
Warning: simulation terminated without clean shutdown. Most likely exit() or abort()
was called.
Note:
FT socket protocol is set using API set_protocol(). Port Adaptors call this API based on
ft_protocol_tag  attribute that is set on socket in Platform Architect GUI.
3.7. Fast Track Logging in Fast Time Modeling
FT infrastructure provides a set of macros that are built on top of FastTrack logging system, providing
additional information for diagnostic purposes. This includes implicit support for printing function name,
line number and support for annotated time.
You need to include the header file scml2_tlm2/snps_tlm2_utils/ft_debug_util.h  to use these
macros.
For more details about FastTrack logging and how to enable it, refer FastTrack in the SCML Model
Reference Manual.
These can also be enabled from Platform Architect Studio, as shown below.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
193</p>
</section>
<section id="page-194">
<h2>Page 194<a class="headerlink" href="#page-194" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 74:
The following macros are available:
•
Logging Macros
◦
FT_LOG_INFO(t, msg)
◦
FT_LOG_INFO_TO(sysc_module, t, msg)
◦
FT_LOG_INFO(t, msg)
◦
FT_LOG_INFO_TO(sysc_module, t, msg)
◦
FT_LOG_WARNING(t, msg)
◦
FT_LOG_WARNING_TO(sysc_module, t, msg)
◦
FT_LOG_ERROR(t, msg)
◦
FT_LOG_ERROR_TO(sysc_module, t, msg)
◦
FT_MODEL_INTERNAL(level, t, msg)
◦
FT_MODEL_INTERNAL_TO(sysc_module, level, t, msg)
•
Assertion Macros
•
◦
FT_ASSERT_WITH_MSG(assertion, msg)
◦
FT_ASSERT_WITH_MSG_TO(sysc_module, assertion, msg)
◦
FT_ASSERT(assertion)
◦
FT_ASSERT_TO(sysc_module, assertion)
Example: An example code snippet exercising these macros and it’s output is as follows.
// Example Code
void sysc_module_thread(void) {
sc_core::sc_time t; // SystemC time is 0ns
t = sc_core::sc_time(100, sc_core::SC_NS);
FT_LOG_INFO(t, “This is an info message”);</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    wait(t); // SystemC time will now be 100ns
    t = sc_core::SC_ZERO_TIME;
    std::string s = &quot;warning&quot;;
</pre></div>
</div>
<p>SystemC Modeling Library Reference Manual
X-2025.06-SP1
194</p>
</section>
<section id="page-195">
<h2>Page 195<a class="headerlink" href="#page-195" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
FT_LOG_WARNING (t, “This is a ” &lt;&lt; s &lt;&lt; ” message”);
int err_code = -1;
t = sc_core::sc_time(500, sc_core::SC_NS);
FT_LOG_ERROR(t, “This is an error message with code:” &lt;&lt; err_code);
t = sc_core::sc_time(1000, sc_core::SC_NS);
FT_MODEL_INTERNAL_TO(this, 5, t, “This is a model internal message”);
FT_ASSERT_WITH_MSG(err_code != -1, “This is an assert message”);
}
Simulation Output:
// Simulation Output</p>
<p>0 ps HARDWARE.HW.HW.i_sysc_module Info[Generic Info] 100 ns ***
sysc_module_thread:17 *** This is an info message
100000 ps  HARDWARE.HW.HW.i_sysc_module Warning[Generic Warning] 100 ns ***
sysc_module_thread:22 *** This is a warning message
100000 ps  HARDWARE.HW.HW.i_sysc_module Error[Generic Error] 600 ns ***
sysc_module_thread:26 *** This is an error message with code:-1
100000 ps  HARDWARE.HW.HW.i_sysc_module Model Internal[Internal Level 5] 1100 ns ***
sysc_module_thread:29 *** This is a model internal message</p>
<p>***************************** FT_ASSERT *****************************</p>
<p>sysc_module_thread() This is an assert message
In module: HARDWARE.HW.HW.i_sysc_module</p>
<p>Fatal: (F4) assertion failed: err_code != -1
In file: sysc_module.h:31
In process: HARDWARE.HW.HW.i_sysc_module.sysc_module_thread &#64; 100 ns</p>
<p>Info: (I99) simulation aborted
(16:17:38) Simulation terminated by signal 6
3.8. Examples
Platform Architect Studio ships various examples based on FT Modeling methodology. These can be
used as starting point examples for creating new FT models. These can be accessed while creating
new TLM project in Platform Architect, as shown in the following figure.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
195</p>
</section>
<section id="page-196">
<h2>Page 196<a class="headerlink" href="#page-196" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 75:
These examples are shipped as source code and provide logic explanation using inline comments.</p>
<ol class="arabic simple">
<li><p>ft_axi_arbiter
◦
An Nx1 (N inputs, 1 output) arbiter using FT AXI protocol as interfaces.</p></li>
<li><p>ft_axi_bridge
◦
A transparent pass-through FT AXI bridge with 1 input and 1 output.</p></li>
<li><p>ft_axi_target
◦
A single ported FT AXI target.
◦
Explains how to effectively use TLM return type semantics (TLM_ACCEPTED/TLM_UPDATED).
◦
Explains how to implement AXI state callbacks.
◦
Explains how to use AXI specific protocol attributes.</p></li>
<li><p>ft_chi_initiator
◦
A single ported FT CHI initiator.
◦
Explains how to implement CHI state callbacks.
◦
Explains how to use CHI specific protocol attributes.</p></li>
<li><p>ft_cxs_i
◦
An FT CXS transmitter/receiver using initiator socket as interface.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
196</p></li>
</ol>
</section>
<section id="page-197">
<h2>Page 197<a class="headerlink" href="#page-197" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
6. ft_cxs_t
◦
An FT CXS transmitter/receiver using target socket as interface.
7. tlm_at_target_ft_wrapper
◦
An integration of a third party/custom TLM module (Target) with Custom TLM2 protocol.
◦
Explains how to create a wrapper with FT AXI target interface.
◦
Explains how to map AXI events to Custom TLM2 protocol.
3.9. The FT_blocks Library
Virtualizer ships some off-the-shelf FT components. These are visible in the Platform Creator tool GUI in
the Library Browser, as shown in the following figure:
Figure 76: The FT_blocks Library
These IPs act as lego blocks for creating the virtual platform of your SoC.
These modules are implemented using the TLM-2.0 (Transaction-Level Modeling) framework and
leverages the scml2 library for socket management and configuration. Each of these blocks are
explained in the following sections.
P
r
o
t
o
c
o
l</p>
<p>C
h
e
c
k
e
r
This chapter describes:
•
ft_cxs_bridge Block
•
ft_image_loader Block
•
ft_axi_rd_wr_mux Block
•
ft_axi_rd_wr_demux Block
•
ft_axi_reorder_buffer Block
•
ft_axi_splitter Block
•
ft_axi_buffer Block
SystemC Modeling Library Reference Manual
X-2025.06-SP1
197</p>
</section>
<section id="page-198">
<h2>Page 198<a class="headerlink" href="#page-198" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
3.9.1. ft_cxs_bridge Block
The ft_cxs_bridge  is a SystemC module designed to act as a transparent bridge between upstream
and downstream CXS ports. It facilitates the transfer of flits (flow control units) and credits between the
two ports, ensuring proper communication and synchronization.
Figure 77: The ft_cxs_bridge Block
Key Features:
•
CXS Protocol Support: Implements the CXS protocol for communication between upstream and
downstream ports.
•
Flit and Credit Handling: Transfers flits and credits between upstream and downstream ports.
Interfaces:
The ft_cxs_bridge  module includes the following interfaces:</p>
<ol class="arabic simple">
<li><p>Clock Interfaces:
◦
clk: Input clock for synchronizing the bridge’s operations.</p></li>
<li><p>CXS Target Interfaces:
◦
cxs_ds: An scml2::ft_target_socket  that acts as the downstream interface for receiving flits
and credits.
◦
cxs_us: An scml2::ft_target_socket  that acts as the upstream interface for receiving flits and
credits.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
198</p></li>
</ol>
</section>
<section id="page-199">
<h2>Page 199<a class="headerlink" href="#page-199" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The ft_cxs_bridge Parameters
The following explains the parameters available to configure ft_cxs_bridge:
Figure 78: Parameters of ft_cxs_bridge
Table 1: Description of the ft_cxs_bridge  Parameters
Name
Type
Default
Allowed Values
Description
BUSWIDTH
template
128/256/512
Sets the bus width
for the CXS bridge
interface
3.9.2. ft_image_loader Block
The ft_image_loader  is a SystemC module designed to load binary images into a simulation
environment. It supports various image formats, including binary and ELF, and provides basic choices
for error handling. Apart from image loading during initialization of simulation, this block is fully
transparent.
Figure 79: The ft_image_loader Block
SystemC Modeling Library Reference Manual
X-2025.06-SP1
199</p>
</section>
<section id="page-200">
<h2>Page 200<a class="headerlink" href="#page-200" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Key Features:
•
Image Loading: Supports loading of binary and ELF images into memory.
•
Protocol Support: Configurable to support multiple protocols, including AXI, GFT, and CHI.
Interfaces:
The ft_image_loader  module includes the following interfaces:
•
TLM Interfaces:
◦
in: An scml2::ft_target_socket  that acts as the input interface for incoming FT transactions.
◦
out: An scml2::ft_initiator_socket  that acts as the output interface for forwarding FT
transactions.
The ft_image_loader Parameters
The following explains the parameters available to configure ft_image_loader:
Figure 80: The ft_image_loader Parameters
Table 1:The ft_image_loader  Parameters
Name
Type
Default
Allowed Values
Description
BUSWIDTH
template
32/64/128/256/
512/1024/2048/
4096
Sets the bus width for the
interface
/ImageInfo/cpu0/i
mage_path
file
(specializ
ation of
string)
Path to the image file to be
loaded.
/Settings/ft_prot
ocol_tag
string
AXI
TLM2_GP/AXI/G
FT/CHI
Sets the protocol type for the
interface ports
SystemC Modeling Library Reference Manual
X-2025.06-SP1
200</p>
</section>
<section id="page-201">
<h2>Page 201<a class="headerlink" href="#page-201" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
/Settings/base_ad
dress
integer
0x0
Base address where the
image is loaded in memory
(effective for binary images
only).
/Settings/ignore_
errors
Boolean
true/false
Controls whether to ignore
errors during image loading.
Example Platform
The library also includes an example platform for this block: example_ft_image_loader. When
launching it in Platform Architect Studio, you may inspect the memory at initial_crunch  time to
confirm it has been preloaded with data. At runtime, a GFRBM block checks correctness of some of the
preloaded data words in memory.
3.9.3. ft_axi_rd_wr_mux Block
The ft_axi_rd_wr_mux  is a SystemC module designed to multiplex AXI read and write transactions
into a single output path. It is particularly useful in scenarios where separate read and write paths need
to be combined for further processing.
Figure 81: The ft_axi_rd_wr_mux Block
Key Features:
•
Read/Write Multiplexing: Combines AXI read and write transactions into a single output path.
•
Protocol Compliance: Ensures that only read transactions are routed from the read input and only
write transactions are routed from the write input.
Interfaces:
The ft_axi_rd_wr_mux  module includes the following interfaces:</p>
<ol class="arabic simple">
<li><p>Clock Interfaces:
◦
clk: Input clock for synchronizing the multiplexer’s operations.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
201</p></li>
</ol>
</section>
<section id="page-202">
<h2>Page 202<a class="headerlink" href="#page-202" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
2. TLM Interfaces:
◦
in_axi_rd: An scml2::ft_target_socket  that acts as the input interface for AXI read
transactions.
◦
in_axi_wr: An scml2::ft_target_socket  that acts as the input interface for AXI write
transactions.
◦
out_axi: An scml2::ft_initiator_socket  that acts as the output interface for multiplexed AXI
transactions.
The ft_axi_rd_wr_mux Parameters
The following explains the parameters available to configure ft_axi_rd_wr_mux:
Figure 82: The ft_axi_rd_wr_mux Parameters
Table 3:The ft_axi_rd_wr_mux  Parameters
Name
Type
Default
Allowed Values
Description
BUSWIDTH
template
32/64/128/256/512
/1024/2048/4096
Sets the bus width for the AXI
interface.
3.9.4. ft_axi_rd_wr_demux Block
The ft_axi_rd_wr_demux  is a SystemC module designed to demultiplex AXI transactions into separate
read and write paths. It is particularly useful in scenarios where read and write transactions need to be
handled independently.
Figure 83: The ft_axi_rd_wr_demux Block
SystemC Modeling Library Reference Manual
X-2025.06-SP1
202</p>
</section>
<section id="page-203">
<h2>Page 203<a class="headerlink" href="#page-203" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Key Features:
•
Read/Write Demultiplexing: Separates AXI read and write transactions into distinct paths.
Interfaces:
The ft_axi_rd_wr_demux  module includes the following ports:</p>
<ol class="arabic simple">
<li><p>Clock Interface:
◦
clk: Input clock for synchronizing the demultiplexer’s operations.</p></li>
<li><p>TLM Interfaces:
•
in_axi: An scml2::ft_target_socket  that acts as the input interface for incoming AXI
transactions.
•
out_axi_rd: An scml2::ft_initiator_socket  that acts as the output interface for AXI read
transactions.
•
out_axi_wr: An scml2::ft_initiator_socket  that acts as the output interface for AXI write
transactions.
The ft_axi_rd_wr_demux Parameters
The following explains the parameters available to configure ft_axi_rd_wr_demux:
Figure 84: The ft_axi_rd_wr_demux Parameters
Table 4:The ft_axi_rd_wr_demux  Parameters
Name
Type
Default
Allowed Values
Description
BUSWIDTH
template
32/64/128/256/512
/1024/2048/4096
Sets the bus width for the AXI
interface.
fwd_dmi_to_out_rd Boolean
true/false
Controls DMI request routing:
true forwards to read channel,
false forwards to write channel.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
203</p></li>
</ol>
</section>
<section id="page-204">
<h2>Page 204<a class="headerlink" href="#page-204" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
3.9.5. ft_axi_reorder_buffer Block
The ft_axi_reorder_buffer  is a SystemC module designed to reorder AXI transactions to ensure
proper sequencing of read and write responses. It is particularly useful in scenarios where out-of-order
transactions need to be reordered to maintain protocol compliance.
Figure 85: The ft_axi_reorder_buffer Block
Key Features:
•
Transaction Reordering: Reorders AXI read and write responses to ensure proper sequencing.
•
Buffering: Provides configurable buffering for read data and write responses.
•
Configuration: Allows configuration of buffer depths, delays, and maximum transaction IDs.
Interfaces:
The ft_axi_reorder_buffer  module includes the following interfaces:</p>
<ol class="arabic simple">
<li><p>Clock Interfaces:
◦
clk: Input clock for synchronizing the reorder buffer’s operations.</p></li>
<li><p>TLM Interfaces:
•
in: An scml2::ft_target_socket  that acts as the input interface for incoming AXI transactions.
•
out: An scml2::ft_initiator_socket  that acts as the output interface for reordered AXI
transactions.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
204</p></li>
</ol>
</section>
<section id="page-205">
<h2>Page 205<a class="headerlink" href="#page-205" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The ft_axi_reorder_buffer Parameters
The following explains the parameters available to configure ft_axi_reorder_buffer:
Figure 86: The ft_axi_reorder_buffer Parameters
Table 5:The ft_axi_reorder_buffer  Parameters
Name
Type
Default
Allowed Values
Description
BUSWIDTH
template
32/64/128/256/512/10
24/2048/4096
Sets the bus width for the AXI
interface
r_buffer_depth
integer
1…∞
Read data reorder buffer
depth
b_buffer_depth
integer
1…∞
Write response reorder buffer
depth
max_arid
integer
1…∞
Output Read transaction IDs
is between 0…max_arid
max_awid
integer
1…∞
Output Write transaction IDs is
between 0…max_awid
3.9.6. ft_axi_splitter Block
The ft_axi_splitter  is a SystemC module designed to split AXI transactions from a wide input bus to
multiple narrower output buses. It is particularly useful in scenarios where data needs to be distributed
across multiple ports or when the input and output bus widths differ.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
205</p>
</section>
<section id="page-206">
<h2>Page 206<a class="headerlink" href="#page-206" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
Figure 87: The ft_axi_splitter Block
Key Features:
•
Transaction Splitting: Splits incoming AXI transactions into smaller transactions for multiple output
ports.
•
Bus Width Conversion: Supports conversion between different input and output bus widths.
•
Configuration: Allows configuration of the number of output ports, maximum transaction size, and
other parameters.
•
Bypass Mode: Provides a bypass path for transactions that do not require splitting. This is done for
multi-beat narrow transactions &amp; AXI Fixed burst transactions.
Interfaces:
The ft_axi_splitter  module includes the following interfaces:</p>
<ol class="arabic simple">
<li><p>Clock Interfaces:
◦
clk: Input clock for synchronizing the splitter’s operations.</p></li>
<li><p>TLM Interfaces:
◦
in: An scml2::ft_target_socket  that acts as the input interface for incoming AXI transactions.
◦
out: A vector of scml2::ft_initiator_socket  objects, representing the output interfaces
for split AXI transactions. The number of output ports is configurable via the m_num_out_ports
parameter.
◦
bypass: An scml2::ft_initiator_socket  that provides a direct path for transactions that do
not require splitting.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
206</p></li>
</ol>
</section>
<section id="page-207">
<h2>Page 207<a class="headerlink" href="#page-207" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The ft_axi_splitter Parameters
The following explains the parameters available to configure ft_axi_splitter:
Figure 88: The ft_axi_splitter Parameters
Table 6:The ft_axi_splitter  Parameters
Name
Type
Default
Allowed Values
Description
IN_BUSWIDTH
template
32/64/128/256/512/10
24/2048/4096
Sets the input bus width for
the AXI interface
OUT_BUSWIDTH template
32/64/128/256/512/10
24/2048/4096
Sets the output bus width for
the AXI interface
num_out_po
rts
integer
1…64
Specifies number of output
ports in the splitter
max_trans_sz
_in_bytes
integer
1…∞
Specifies maximum
transaction size in bytes for
split transactions
rd_addr_fw_d
elay
integer
0…∞
Specifies delay in clock cycles
for forwarding read address
phase transactions
wr_addr_fw_d
elay
integer
0…∞
Specifies delay in clock cycles
for forwarding write address
phase transactions
wr_resp_fw_d
elay
integer
0…∞
Specifies delay in clock cycles
for forwarding write response
phase transactions
max_trans_id
_per_port
integer
1…∞
Specifies maximum number of
transaction IDs per output port
for outstanding transactions
SystemC Modeling Library Reference Manual
X-2025.06-SP1
207</p>
</section>
<section id="page-208">
<h2>Page 208<a class="headerlink" href="#page-208" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
3.9.7. ft_axi_buffer Block
The ft_axi_buffer  is a SystemC module designed to act as an AXI protocol buffer. It provides
buffering capabilities for AXI transactions, enabling frequency conversion and managing delays
between AXI channels. For further details, see the section Buffer Support in the SBLTLM2FT_BL  model
library documentation.
Figure 89:
Key Features:
•
Buffering: Provides configurable buffering for AXI channels, including read/write address, data, and
response channels.
•
Frequency Conversion: Supports clock frequency conversion between input and output clocks.
•
Configuration: Allows configuration of channel depths, delays, and other parameters.
Interfaces:
The ft_axi_buffer  module includes the following interfaces:</p>
<ol class="arabic simple">
<li><p>Clock Interfaces:
◦
▪
out_clk: Input clock for the output interface.
▪
in_clk: Input clock for the input interface.</p></li>
<li><p>TLM Interfaces:
◦
out: An scml2::ft_initiator_socket  that acts as the forward transport interface for outgoing
AXI transactions.
◦
in: An scml2::ft_target_socket  that acts as the backward transport interface for incoming
AXI transactions.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
208</p></li>
</ol>
</section>
<section id="page-209">
<h2>Page 209<a class="headerlink" href="#page-209" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
The ft_axi_buffer Parameters
The following explains the parameters available to configure ft_axi_buffer:
Figure 90: The ft_axi_buffer Parameters
Table 7:The ft_axi_buffer  Parameters
Name
Type
Default
Allowed Values
Description
BUSWIDTH
templ
ate
32/64/128/256/512/1024/20
48/4096
Sets the bus width for the AXI
interface
/Buffer/Read
_address_cha
nnel/depth
integer
0…65535
Set the buffer depth for read
address channel. Legal values:
0 up to 65535
/Buffer/Read
_address_cha
nnel/fw_de
lay
integer
0…65535
Set the buffer forward delay for
read address channel. Legal
values: 0 up to 65535
/Buffer/Read
_address_cha
nnel/bw_de
lay
integer
0…65535
Set the buffer backward delay
for read address channel. Legal
values: 0 up to 65535
/Buffer/Read
_data_chann
el/depth
integer
0…65535
Set the buffer depth for read
data channel. Legal values: 0 up
to 65535
/Buffer/Read
_data_chann
el/fw_delay
integer
0…65535
Set the buffer forward delay for
read data channel. Legal values:
0 up to 65535
SystemC Modeling Library Reference Manual
X-2025.06-SP1
209</p>
</section>
<section id="page-210">
<h2>Page 210<a class="headerlink" href="#page-210" title="Permalink to this heading"></a></h2>
<p>Chapter 3: SCML2 Fast Timed (FT) Modeling
 
/Buffer/Read
_data_chann
el/bw_delay
integer
0…65535
Set the buffer backward delay
for read data channel. Legal
values: 0 up to 65535
/Buffer/Writ
e_address_ch
annel/depth
integer
0…65535
Set the buffer depth for write
address channel. If depth
is specified as 0; tide_mark
cannot be configured for write
transactions. Legal values: 0 up
o 65535
/Buffer/Writ
e_address_ch
annel/fw_de
lay
integer
0…65535
Set the buffer forward delay for
write address channel. Legal
values: 0 up to 65535
/Buffer/Writ
e_address_ch
annel/bw_de
lay
integer
0…65535
Set the buffer backward delay
for write address channel. Legal
values: 0 up to 65535
/Buffer/Writ
e_data_chann
el/depth
integer
0…65535
Set the buffer depth for write
data channel. Legal values: 0 up
to 65535
/Buffer/Writ
e_data_chann
el/fw_delay
integer
0…65535
Set the buffer forward delay for
write data channel. Legal values:
0 up to 65535
/Buffer/Writ
e_data_chann
el/bw_delay
integer
0…65535
Set the buffer backward delay
for write data channel. Legal
values: 0 up to 65535
/Buffer/Writ
e_data_chann
el/tide_mark
integer
0…65535
Set the buffer tide mark for write
data channel so that transaction
is not be released from buffer
until tide mark is hit or write
completes from initiator side.
/Buffer/Writ
e_response_c
hannel/depth
integer
0…65535
Set the buffer depth for write
response channel. Legal values:
0 up to 65535
/Buffer/Writ
e_response_c
hannel/fw_de
lay
integer
0…65535
Set the buffer forward delay for
write response channel. Legal
values: 0 up to 65535
/Buffer/Writ
e_response_c
hannel/bw_de
lay
integer
0…65535
Set the buffer backward delay
for write response channel.
Legal values: 0 up to 65535
SystemC Modeling Library Reference Manual
X-2025.06-SP1
210</p>
</section>
<section id="page-211">
<h2>Page 211<a class="headerlink" href="#page-211" title="Permalink to this heading"></a></h2>
<p>Chapter 4
Clock Objects
c
l
o
c
k</p>
<p>o
b
j
e
c
t
s
This chapter describes the clock objects.
•
Overview
•
Clocks and Reset
•
Modeling Objects for Clocks (Clock Objects)
•
Base Classes
•
Modeling Objects for Base Classes (Modeling Objects)
•
Convenience Classes
•
Modeling Objects for Convenience Classes (Convenience Objects)
•
Code Example
Note:
If the following error message is issued when simulating:
ERROR: Error in scml_clock ‘divider’: the attached master clock ‘master’ is no
scml_clock!
or
Error in get_scml_clock ‘divider’: the driving clock port must be bound to a
channel
that implements scml_clock_if!
You must use an object of type scml_clock for the clock source object and export it using an
sc_export&lt;sc_signal_inout_if&gt;  export, as shown in the following code.
sc_export&lt;sc_signal_inout_if<bool>&gt; p_CLK; // clock output port
scml_clock m_clkObject; // clock source object
For details, see GIPL_CLK example provided in the Generic IP Library manual, available with the
Synopsys Model Library documentation.
4.1. Overview
The following table summarizes the clock objects.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
211</p>
</section>
<section id="page-212">
<h2>Page 212<a class="headerlink" href="#page-212" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
Table 56: Clock Objects
Modeling Object
Summary
scml_clock
It implements sc_clock_if. It is an optimized version of sc_clock.
scml_divided_clock
It is a clock derived from another clock by multiplying the start time
and/or the period with specified integer factors.
scml_clock
It is a module which takes a clock and an enable signal as inputs
and produces a gated clock as output.
scml_clock_counter
It has to be attached to a clock and is used to get the number of
clock edges that have happened in a certain period.
scml2::clocked_module
It is the base class for modules that want to receive SCML clock tick
callbacks.
scml2::clocked_timer
It is a modeling object that provides a timer callback mechanism
based on an SCML clock.
scml2::clocked_callback
It is a convenience class that forwards a clock tick callback to any
member function of a module without the need to inherit from the
clocked_module  base class.
scml2::clocked_event
It is a convenience class that allows a SystemC method or thread to
wait until a certain clock tick happens.
scml2::clocked_peq_container It is a modeling object for TLM2 FT models using the non-blocking
APIs. It buffers payload arriving in the model, like multiple
outstanding transactions, possibly coming with different timing
annotations from different initiators.
scml2::clocked_peq
It is a modeling object similar to the clocked_peq_container  that
can trigger a callback whenever an element from the payload buffer
becomes available.
4.2. Clocks and Reset
•
scml_clock
•
scml_divided_clock
•
Dynamic Clock Parameter Change and Reset
4.2.1. scml_clock
An scml_clock  object implements sc_clock_if. It is an optimized version of an sc_clock. When
nothing is sensitive to the events of the clock, no events notifications are scheduled.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
212</p>
</section>
<section id="page-213">
<h2>Page 213<a class="headerlink" href="#page-213" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
A number of extensions come with an scml_clock  that are not available for an sc_clock:
•
changing the period of a clock
•
disabling/enabling a clock
•
receiving a callback after a specified number of clock ticks
Objects of type scml_clock  can be constructed using one of the following constructors:
scml_clock(const char* name,
const sc_core::sc_time&amp; period,
double dutyCycle=0.5,
const sc_core::sc_time&amp; startTime=sc_core::SC_ZERO_TIME,
bool posedgeFirst=true);</p>
<p>scml_clock(const char* name,
double periodV,
sc_core::sc_time_unit periodTu,
double dutyCycle=0.5);</p>
<p>scml_clock(const char* name,
double periodV,
sc_core::sc_time_unit periodTu,
double dutyCycle,
double startTtimeV,
sc_core::sc_time_unit startTimeTu,
bool posedgeFirst=true);
where:
name
Specifies a name for the clock object.
period
Specifies the clock period.
periodV
Specifies the value of the clock period.
periodTu
Specifies the time unit for the clock period.
dutyCycle
Specifies the duty cycle of the clock object.
startTime
Specifies the time of the first clock edge.
startTimeV
Specifies the value of the time of the first clock edge.
startTimeTu
Specifies the time unit for the time of the first clock edge.
posedgeFirst Specifies if the first edge is a posedge  or a negedge.
The following functions are available to set/get properties of the clock object:
•
const char* name() const;
Returns the name of the clock.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
213</p>
</section>
<section id="page-214">
<h2>Page 214<a class="headerlink" href="#page-214" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
•
bool is_master() const;
Returns true  for clock sources and false  for divided (class scml_divided_clock) or gated clocks
(class scml_clock_gate).
•
s
e
t
_
p
e
r
i
o
d
(
)</p>
<p>f
u
n
c
t
i
o
n
g
e
t
_
p
e
r
i
o
d
(
)</p>
<p>f
u
n
c
t
i
o
n
sc_core::sc_time get_period() const;
void set_period(const sc_core::sc_time &amp;t);
Gets and sets the clock period. Setting the period is only valid for clock sources. It can be set
(changed) at any time. The new value is returned by get_period()  after the next update phase of
the SystemC kernel.
•
s
e
t
_
d
u
t
y
_
c
y
c
l
e
(
)</p>
<p>f
u
n
c
t
i
o
n
g
e
t
_
d
u
t
y
_
c
y
c
l
e
(
)</p>
<p>f
u
n
c
t
i
o
n
double get_duty_cycle()const;
void set_duty_cycle(double d);
Gets and sets the duty cycle. The value provided to set_duty_cycle()  must be larger 0.0  and
smaller 1.0.
•
s
e
t
_
s
t
a
r
t
_
t
i
m
e
(
)</p>
<p>f
u
n
c
t
i
o
n
g
e
t
_
s
t
a
r
t
_
t
i
m
e
(
)</p>
<p>f
u
n
c
t
i
o
n
sc_core::sc_time&amp; get_start_time()const;
void    set_start_time(const sc_core::sc_time&amp; t);
Gets or sets the start time of the clock. Immediately after changing the period or enabling the clock,
it returns the start time of the next period, that is the first period following the new properties. Setting
the start time is only valid for clock sources. It must only be called before the initialization phase of
the SystemC kernel.
•
s
e
t
_
p
o
s
e
d
g
e
_
f
i
r
s
t
(
)</p>
<p>f
u
n
c
t
i
o
n
g
e
t
_
p
o
s
e
d
g
e
_
f
i
r
s
t
(
)</p>
<p>f
u
n
c
t
i
o
n
bool get_posedge_first()const;
void set_posedge_first(bool posedgeFirst);
Gets and sets the posedge_first  property of the clock. It must only be called before the
initialization phase of the SystemC kernel.
•
s
e
t
_
p
e
r
i
o
d
_
m
u
l
t
i
p
l
i
e
r
(
)</p>
<p>f
u
n
c
t
i
o
n
g
e
t
_
p
e
r
i
o
d
_
m
u
l
t
i
p
l
i
e
r
(
)</p>
<p>f
u
n
c
t
i
o
n
double get_period_multiplier()const;
void set_period_multiplier(double m);
Gets and sets the period multiplier of the clock. Setting the period multiplier is only valid for divided
clocks. It can be set at any time. The new value is returned by get_period_multiplier()  after the
next update phase of the SystemC kernel.
•
d
i
s
a
b
l
e
(
)</p>
<p>f
u
n
c
t
i
o
n
e
n
a
b
l
e
(
)</p>
<p>f
u
n
c
t
i
o
n
void enable();
void disable();
Enables (that is, makes active) or disables (that is, makes inactive) the clock. When an scml_clock
is disabled, the output is 0  for a normal clock, and 1  for an inverted clock (starting with a negative
edge, that is, get_posedge_first()  returning false).
•
d
i
s
a
b
l
e
d
(
)</p>
<p>f
u
n
c
t
i
o
n
bool disabled();
Tests whether the clock is disabled.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
214</p>
</section>
<section id="page-215">
<h2>Page 215<a class="headerlink" href="#page-215" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
•
r
u
n
n
i
n
g
(
)</p>
<p>f
u
n
c
t
i
o
n
bool running();
Tests whether the clock is running. For a clock source, this is equivalent to !disabled(). For a
divided clock or gated clock, it also considers the running state of the clock sources. That is, a
divided clock or gated clock is running if it is enabled and the clock source is running.
The scml_clock  provides a notification mechanism for changes of the parameters period  and
enabled . An observer of clock parameter changes must inherit the base class scml_clock_observer
and implement the method handle_clock_parameters_updated() . When the period of a clock
is changed, or a clock is enabled or disabled, the new parameters become active with the next
update phase. During the update, the clock calls handle_clock_parameters_updated()  for all
registered observers. If multiple parameters of the clock are changed within the same cycle, then
handle_clock_parameters_updated()  is only called at one time.
•
u
n
r
e
g
i
s
t
e
r
_
o
b
s
e
r
v
e
r
(
)</p>
<p>f
u
n
c
t
i
o
n
r
e
g
i
s
t
e
r
_
o
b
s
e
r
v
e
r
(
)</p>
<p>f
u
n
c
t
i
o
n
void register_observer(scml_clock_observer* o);
void unregister_observer(scml_clock_observer* o);
Registers or unregisters a clock observer with the clock.
The scml_clock  is the basic modeling object for the clocked modeling style of the SCML fast timed
(FT) modeling style, see Introduction to SCML FT Modeling. It provides an ease of use mechanism
to register callbacks with clock boundaries. A clock boundary is defined as the beginning of a period.
For a normal clock, it corresponds to the positive edge; for an inverted clock (get_posedge_first()
returning false) to a negative edge. Within this clock callback API, the clock boundary is called a clock
tick.
Clock tick callbacks are called from the context of a SystemC method, that is internal to the clock. The
call happens during the evaluation phase of the first delta cycle of the SystemC time, that corresponds
to the clock edge.
Note:
SystemC processes that are sensitive to the clock edge event, is only activated in the second delta
cycle.
The main user interface of the clock tick mechanism is provided by the class clocked_module, see
scml2::clocked_module. Within an scml_clock, the following functions are related to clock ticks:
•
bool check_at_tick() const;
Checks whether there is a clock tick at the current SystemC time. The result is independent from the
current delta cycle. That means, check_at_tick()  returns true  already in the first delta cycle that
corresponds to a clock tick, although processes that are sensitive to the clock edge event are only
activated in the second delta cycle.
•
sc_core::sc_time get_next_edge_offset(bool pos_edge) const;
Returns the offset (as SystemC time) to the next positive or negative edge of the clock, depending
on the value of the argument pos_edge.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
215</p>
</section>
<section id="page-216">
<h2>Page 216<a class="headerlink" href="#page-216" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
•
unsigned long long get_tick_count() const;
Queries the tick count of the clock. This corresponds to the number of clock ticks, since the start
of the simulation. The return value takes all phases when the clock was disabled, as well as, all
changes of the clock period into account.
This function has been optimized for speed when called in a synchronous way, that is from a tick
callback. An unsynchronized call is more expensive, but only the first time for a given SystemC time,
due to internal caching of the result.
•
sc_dt::uint64 get_clock_count() const;
Returns the same value as get_tick_count(). This function is provided for backward compatibility.
•
unsigned long long get_tick_count(const sc_core::sc_time&amp; delay) const;
Returns the tick count of the clock for the future SystemC time sc_time_stamp()+delay. For
example, if called with delay  = SC_ZERO_TIME, it returns the current tick count, which is equivalent to
get_tick_count().
•
sc_core::sc_time get_tick_time(long long clock_ticks_to_skip) const;
Gets the SystemC time for the clock tick that happens after clock_ticks_to_skip  ticks from now.
For example if called with clock_ticks_to_skip  = 0, it returns the time of the next tick.
•
void get_next_tick_data(const sc_core::sc_time&amp; delay, unsigned long long&amp; count,
sc_core::sc_time&amp; time) const;
Gets the clock count and SystemC time for the next clock tick after a given future SystemC time.
The future point in time is given by the sc_time  argument delay, which is interpreted relative to the
current SystemC time sc_time_stamp(). If called synchronized (the future point in time corresponds
to a clock tick), it returns the data for the next following clock tick.
Several events are available for clock objects. They can be accessed using the following functions:
•
n
e
g
e
d
g
e
(
)</p>
<p>f
u
n
c
t
i
o
n
p
o
s
e
d
g
e
(
)</p>
<p>f
u
n
c
t
i
o
n
e
v
e
n
t
(
)</p>
<p>f
u
n
c
t
i
o
n
n
e
g
e
d
g
e
_
e
v
e
n
t
(
)</p>
<p>f
u
n
c
t
i
o
n
p
o
s
e
d
g
e
_
e
v
e
n
t
(
)</p>
<p>f
u
n
c
t
i
o
n
v
a
l
u
e
_
c
h
a
n
g
e
d
_
e
v
e
n
t
(
)</p>
<p>f
u
n
c
t
i
o
n
const sc_event&amp; value_changed_event() const;
const sc_event&amp; posedge_event() const;
const sc_event&amp; negedge_event() const;</p>
<p>bool event();
bool posedge() const;
bool negedge() const;
Boolean functions to test whether a certain event occurred.
For tracing purposes, a reference to the current value can be obtained:
const bool &amp; get_data_ref() const;
Note:
The scml_clock  cannot be optimized when tracing is enabled. Enabling tracing disables clock
optimizations.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
216</p>
</section>
<section id="page-217">
<h2>Page 217<a class="headerlink" href="#page-217" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
4.2.2. scml_divided_clock
A divided clock is a special version of an scml_clock  that is derived from another clock by multiplying
the start time and/or the period with specified integer factors. In case both multipliers are 1, a local
mirror of the clock is obtained. An advantage of such a mirror of a clock is that it can be enabled and
disabled locally.
Objects of type scml_divided_clock  can be constructed using one of the following constructors:
scml_divided_clock(const char * name,
sc_in<bool> &amp; clk,
unsigned int periodMultiplier=1,
unsigned int startMultiplier=0);</p>
<p>scml_divided_clock(const char * name,
scml_clock_if &amp; clk,
unsigned int periodMultiplier=1,
unsigned int startMultiplier=0);</p>
<p>scml_divided_clock(const char * name,
unsigned int periodMultiplier=1,
unsigned int startMultiplier=0);
where:
name
Specifies a name for the clock object.
clk
Specifies the clock from which this object is derived.
periodMultiplier Specifies the factor by which the period is multiplied.
startMultiplier
Specifies the factor by which the start time is multiplied.
The defaults are such that a clone of the incoming clock is obtained.
The following functions are provided to connect the divided clock to its input clock.
o
p
e
r
a
t
o
r
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
d
i
v
i
d
e
d
_
c
l
o
c
k
o
p
e
r
a
t
o
r
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
d
i
v
i
d
e
d
_
c
l
o
c
k
b
i
n
d
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
d
i
v
i
d
e
d
_
c
l
o
c
k
b
i
n
d
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
d
i
v
i
d
e
d
_
c
l
o
c
k
void    bind(sc_in<bool> &amp;);
void bind(scml_clock_if &amp;);
void operator()(sc_in<bool> &amp;);
void operator()(scml_clock_if &amp;);
In addition to the API of an scml_clock, the following functions are available to set properties:
g
e
t
_
d
i
v
i
d
e
r
(
)</p>
<p>f
u
n
c
t
i
o
n
void set_divider(unsigned int div);
unsigned int get_divider() const;
o
r
i
g
i
n
a
l</p>
<p>c
l
o
c
k</p>
<p>p
e
r
i
o
d
,</p>
<p>d
e
f
i
n
i
t
i
o
n
Changes the clock period of a divided clock in multiples of the original clock period. The original
clock period is the parent’s clock period multiplied by the period multiplier constructor argument.
For example, if the parent clock period is p  and the divided clock period multiplier constructor
argument is 2, the original period is two times p. set_divider(4)  indicates that the new period
is four times the original period, that is 8p.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
217</p>
</section>
<section id="page-218">
<h2>Page 218<a class="headerlink" href="#page-218" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
The majority of methods of an scml_divided_clock  behave the same as with an scml_clock, with the
following exceptions:
bool is_master() const;
Always returns false.
bool disabled();
Tests whether the clock is disabled by the disable()/enable().
bool running();
Tests whether the clock is running. This is the case if it is not disabled, and the clock source is
running.
double get_duty_cycle() const;
void set_duty_cycle(double d);
Gets and sets the duty cycle of the divided clock. By default, a divided clock inherits the duty
cycle from its parent clock. Any change of the duty cycle of the clock source also becomes
visible on the divided clock. This behavior changes after the duty cycle of the divided clock has
been set explicitly by a call set_duty_cycle(). After such a call, the divided clock maintains
its own value for the duty cycle and the value of the clock source is no longer used. The value
provided to set_duty_cycle()  must be larger than 0.0  and smaller than 1.0.
The following functions to set properties are not supported by a divided clock and must not be called:
•
set_start_time(const sc_core::sc_time&amp;)
•
set_period(const sc_core::sc_time&amp;)
•
set_posedge_first(bool)
4.2.3. Dynamic Clock Parameter Change and Reset
This section describes how dynamic clock parameter changes and dynamic reset can be handled in the
FTM coding style.
With FTM coding style, it can be difficult to assure correct model behavior on dynamic clock parameter
changes like dynamically changing the clock period or disabling and enabling it. The main root cause for
the difficulties is temporal decoupling, but also pending transactions can be hard to handle.
To enable easier handling of dynamic clock parameter changes, class
scml_clock_parameter_change_control_if  provides an extension to the scml_clock  API which
allows driving each model into a state where clock parameter changes can safely be done before the
change is actually executed. The solution is based on a handshaking mechanism which blocks the
execution of the clock parameter change request until all registered clients signaled readiness.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
218</p>
</section>
<section id="page-219">
<h2>Page 219<a class="headerlink" href="#page-219" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
Flow
The general dynamic clock parameter change flow is the following:</p>
<ol class="arabic simple">
<li><p>On clock-parameter-change-request, the clock notifies all registered clients about a new clock-
parameter-change-request.</p></li>
<li><p>The clients prepare for clock parameter change. Usually this means returning from time traveling
and waiting for pending transactions. A model should no longer initiate any transactions or write to
external pins after it received a clock-parameter-change-request-notification.
When the client reaches the state where it can safely handle clock parameter changes, it signals
readiness to the clock and waits for the actual clock-parameter-changed-notification. A client can
also immediately signal readiness.</p></li>
<li><p>When all clients signaled readiness, the actual clock parameter change is executed in the following
update phase. The clock sends out a notification to all clock observers.</p></li>
<li><p>The clients continue running, usually waiting for the first clock tick after the notification.
Model State Requirements
Before signaling readiness for a clock parameter change, a model needs to meet certain requirements:
•
The model should not be time travelling (temporal decoupling).
•
The model is not allowed to have any pending transactions. This rule enables much easier handling
of clock parameter changes in network and target models.
•
No SystemC process owned by the model is allowed to be suspended by a wait call in a different
model. With FTM coding style this should only be the case for pending transactions, which anyway
need to be handled.
•
The model specific state has to allow clock parameter changes.
Note:
If all models in a virtual prototype follow these rules, pure target models usually need not take
part in the handshaking mechanism. They should natively allow clock parameter changes as
soon as all other models signal readiness.
Architecture
The scml_clock_parameter_change_control_if  is an extension to the scml_clock_if. For
details, see scml_clock. To support dynamic parameter changes, a clock needs to implement
both interfaces. Usually this is done by creating a wrapper around a scml_clock which implements
scml_clock_parameter_change_control_if.
The clock parameter change control needs to be bound to a scml_clock  so that it can be found by the
clients.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
219</p></li>
</ol>
</section>
<section id="page-220">
<h2>Page 220<a class="headerlink" href="#page-220" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
Client models need to implement both scml_clock_parameter_change_control_if::client  and
scml_clock_observer  to take part in the dynamic clock parameter change handshaking mechanism.
Clients have to check if a connected clock has an implementation of
scml_clock_parameter_change_control_if  bound to it and register to it.
API
Binding
void scml2::bind_scml_clock_parameter_change_control(
scml_clock_if* clk, scml_clock_parameter_change_control_if* d)
Binds an instance of a scml_clock_parameter_change_control_if  implementation d  to
clock clk. Only one instance can be bound at a time.
void scml2::unbind_scml_clock_parameter_change_control(scml_clock_if* clk)
Unbinds any scml_clock_parameter_change_control_if  from clock clk.
Fetch Clock Parameter Control Pointer
scml_clock_parameter_change_control_if*
scml2::get_scml_clock_parameter_change_control(scml_clock_if* clk)
Gets pointer to scml_clock_parameter_change_control_if  bound to clock clk. Returns 0  if
no scml_clock_parameter_change_control_if  is bound to this clock.
scml_clock_parameter_change_control_if*
scml2::get_scml_clock_parameter_change_control(
sc_core::sc_in<bool>&amp;
clk_in_port)
Convenience function: Gets pointer to scml_clock_parameter_change_control_if
bound to the clock signal connected to port clk_in_port. Returns 0  if no
scml_clock_parameter_change_control_if  is bound to this clock signal.
scml_clock_parameter_change_control_if
virtual void register_client(client* c)
Registers client c  to clock parameter change control.
virtual void signal_ready_for_parameter_change(client* c)
To be called by client c  to signal readiness to clock parameter change control.
scml_clock_parameter_change_control_if::client
virtual void handle_clock_parameter_change_request(
scml_clock_parameter_change_control_if*)
Called by clock parameter change control to notify the client a clock parameter change was
requested. The client should start preparing for clock parameter change on this notification.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
220</p>
</section>
<section id="page-221">
<h2>Page 221<a class="headerlink" href="#page-221" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
The requirements for dynamic reset are even stricter than for dynamic clock parameter change reset
has to be executed in each model in a Virtual Prototype at exactly the same time to assure functional
correctness.
To achieve this, the proposal is to have a long enough reset pulse that every model in a Virtual
Prototype has enough time to drive itself into a state where it can safely execute the reset. There is
no handshaking involved, when a model is unable to reach this state in time it terminates with an error
message.
Flow</p>
<ol class="arabic simple">
<li><p>On reset assert, all models stop regular execution as soon as possible and prepare for reset. When
a state is reached where reset can safely be executed, they block until reset de-assert.
A model should no longer initiate any transactions or write to external pins after reset assert.</p></li>
<li><p>On reset de-assert, the actual reset is executed.
If a model is still in a state where reset cannot be executed, it throws an error and terminate
execution. The simulation has to be restarted with a longer reset pulse.
Model State Requirements
The model state where reset can safely be executed is defined by the following rules:
•
The model is not time travelling.
•
The model does not have any pending transactions.
•
No SystemC process owned by the model is suspended by a wait call in a different model.
•
The model specific state allows executing reset.
Note:
If all models in a Virtual Prototype follow these rules, pure target models usually do not need
extra adaptation. They natively meet the requirements.
Architecture
No extra interfaces are involved in the dynamic reset flow. The only requirement is a reset generator
model which supports adjusting the reset pulse length.
4.3. Modeling Objects for Clocks (Clock Objects)
•
scml_clock_gate
•
scml_clock_counter
SystemC Modeling Library Reference Manual
X-2025.06-SP1
221</p></li>
</ol>
</section>
<section id="page-222">
<h2>Page 222<a class="headerlink" href="#page-222" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
4.3.1. scml_clock_gate
scml_clock_gate  is a module which takes a clock and an enable signal as input and produces a gated
clock as output. If the enable signal is true, the output clock equals the input clock. If the enable signal
is false, the output clock is disabled.
A clock gate has a clock and an enable input port:
sc_in<bool> clk;
sc_in<bool> en;
The following constructor is available:
scml_clock_gate(sc_module_name name);
where name  specifies a name for the clock object.
This constructor is explicit.
The scml_clock_gate  modeling object implements the interface scml_clock_if. It can, therefore, be
used like an sc_clock  or an scml_clock  object. For an API reference, see scml_clock.
The majority of methods of an scml_clock_gate  behaves the same as with an scml_clock, with the
following exceptions:
bool is_master() const;
Always returns false.
bool disabled();
Tests whether the clock is disabled by the en  input port.
bool running();
Tests whether the clock is running. This is the case if it is enabled by the en  input port, and the
clock source is running.
The following functions are not supported by a clock gate and must not be called:
•
enable()
•
disable()
•
set_duty_cycle(double)
•
set_start_time(const  sc_core::sc_time&amp;)
•
set_period(const  sc_core::sc_time&amp;)
•
set_posedge_first(bool)
•
set_period_multiplier(double)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
222</p>
</section>
<section id="page-223">
<h2>Page 223<a class="headerlink" href="#page-223" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
4.3.2. scml_clock_counter
s
c
m
l
_
c
l
o
c
k
_
c
o
u
n
t
e
r
An object of type scml_clock_counter  needs to be attached to a clock. It is used to get the number of
clock cycles that have happened in a certain period. The value of the counter is incremented at every
clock cycle. Its initial value is 0.
The following type definitions are available:
typedef sc_dt::uint64 data_type;
Objects of type scml_clock_counter  can be constructed using one of the following constructors:
scml_clock_counter(const char *name,
scml_clock_if &amp;clk);
scml_clock_counter(const char *name);
where:
name Specifies a name for the clock object.
clk
Specifies the clock that should be used to determine this counter value.
The single-argument constructor is explicit.
The counter can be manipulated by means of the following sets of functions:
g
e
t
_
c
o
u
n
t
(
)</p>
<p>f
u
n
c
t
i
o
n
data_type get_count() const;
void set_count(data_type var);
Gets and sets the counter.
w
r
i
t
e
(
)</p>
<p>f
u
n
c
t
i
o
n
r
e
a
d
(
)</p>
<p>f
u
n
c
t
i
o
n
data_type read() const;
void write(const data_type var);
Read and write function.
d
a
t
a
_
t
y
p
e
(
)</p>
<p>f
u
n
c
t
i
o
n
operator const data_type() const;
data_type operator=(const data_type var);
Accesses the scml_clock_counter  as a variable.
The following functions are provided to connect the clock counter to its input clock.
o
p
e
r
a
t
o
r
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
c
l
o
c
k
_
c
o
u
n
t
e
r
b
i
n
d
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
c
l
o
c
k
_
c
o
u
n
t
e
r
void    bind(scml_clock_if &amp;);
void operator()(scml_clock_if &amp;);
4.4. Base Classes
•
scml2::clocked_module
SystemC Modeling Library Reference Manual
X-2025.06-SP1
223</p>
</section>
<section id="page-224">
<h2>Page 224<a class="headerlink" href="#page-224" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
4.4.1. scml2::clocked_module
The class clocked_module  is the lower level user API for SCML clock tick callbacks. The intended use
is that a module can receive clock tick callbacks by inheriting from the scml2::clocked_module  class
and by implementing the virtual method handle_clock_tick.
A clocked_module  has a fixed association with one SCML clock interface, it is not allowed to change
the clock used by the clocked_module  at runtime.
A clock tick callback can be requested by the method request_clock_tick  callback. If there is already
a callback request pending, the earlier one of the two is maintained. It is possible to retrigger or cancel a
pending request.
Objects of type scml2::clocked_module  can be constructed using one of the following constructors:
clocked_module(scml_clock_if* clock=0);
clocked_module(sc_core::sc_in<bool>&amp; p);
where:
clock Specifies the SCML clock object that is associated with the clocked module.
p
Specifies the input port through which the clocked module is bound to its associated SCML clock.
Clocked modules can be constructed and destructed at any time during a simulation run. If a clocked
module is destructed and there is still a pending request for a clock tick callback for that object, it will
automatically be canceled.
The following functions are provided to connect the clocked module to an SCML clock.
void set_clock(scml_clock_if* clock);
Associates the clocked_module  with the provided SCML clock.
void set_clock(sc_core::sc_in<bool>&amp; p);
Associates the clocked_module  with the SCML clock, which is bound to the provided input
port.
scml_clock_if* get_clock() const;
Returns the associated SCML clock.
void request_clock_trigger(long long clock_ticks_to_skip);
Schedules a callback (that is, call to function handle_clock_tick) for a future clock tick. The
argument clock_ticks_to_skip  defines the number of ticks that is skipped from now. This
function can be called at any SystemC time.
If called while a previous clock tick callback request is still pending, the earlier one of the two
is maintained. That is, the new request is ignored if it targets the same or a later clock tick. If it
SystemC Modeling Library Reference Manual
X-2025.06-SP1
224</p>
</section>
<section id="page-225">
<h2>Page 225<a class="headerlink" href="#page-225" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
targets an earlier clock tick, then the previous request is canceled, and the request is scheduled
for the new earlier tick.
If a clock trigger was requested, then the requested/scheduled clock tick can be retrieved by a
call to method get_scheduled_clock_tick().
For example, after a call of request_clock_trigger(0), the clock tick count returned by
get_scheduled_clock_tick()  is one larger than the current clock tick count of the associated
SCML clock.
void request_clock_trigger(const sc_core::sc_time&amp; delay);
Schedules a callback (that is, call to function handle_clock_tick) for a future clock tick
after the time defined by the argument delay. The argument delay  is a SystemC time that is
interpreted relative to the current SystemC time sc_time_stamp(). This method usually is used
by TLM2 models with temporal decoupling, to synchronize to the next clock tick after the given
local time argument.
If called while a previous clock tick callback request is still pending, the earlier one of the two
is maintained. That is, the new request is ignored if it targets the same or a later clock tick. If it
targets an earlier clock tick, then the previous request is canceled and the request is scheduled
for the new earlier tick.
virtual void handle_clock_tick()=0;
When a requested clock tick callback expires, the SCML clock calls the method
handle_clock_tick() . The call happens from within the context of an SC_METHOD  that is
owned by the clock object. This is an abstract method that is implemented by the user in the
derived class to provide the functionality that is executed on a clock tick callback.
Caution:
You must not call next_trigger()  from within a clock tick callback, since this breaks the SCML
clock mechanism and results in a fatal misbehavior of the clock system.
bool is_clock_trigger_requested() const;
Returns true  if a clock tick callback was requested and is still pending.
void cancel_clock_trigger();
Cancels a pending clock tick callback request. It does nothing if no clock tick callback request is
currently pending. During the processing of a clock tick (that is within a handle_clock_tick()
call), it is not permitted to cancel a clock tick callback request that was scheduled for the
currently processed clock tick.
unsigned long long get_scheduled_clock_tick() const;
SystemC Modeling Library Reference Manual
X-2025.06-SP1
225</p>
</section>
<section id="page-226">
<h2>Page 226<a class="headerlink" href="#page-226" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
In case of a pending clock tick callback, this method returns the clock tick for which the tick
callback was requested/scheduled. If no clock tick callback is pending, then the returned value
is undefined.
4.5. Modeling Objects for Base Classes (Modeling Objects)
•
scml2::clocked_timer
4.5.1. scml2::clocked_timer
This is a modeling object that provides a timer callback mechanism based on an SCML clock. The
clocked_timer  object is based on the clocked_module  object and is similar to the clocked_callback
object. The timer can be started to expire after a number of clock ticks. When it expires, it calls the
callback that is registered with the object. The timer can be configured to expire at one time, multiple
times or to run forever. It is possible to stop and resume the timer.
The following type definition is available:
enum eState { eS_Idle=0, eS_Running, eS_Stopped };
Objects of type clocked_timer  can be constructed using the following constructor:
clocked_timer(const std::string&amp; name, scml_clock_if* clock=0);
where:
name
Specifies a name for the clocked timer object.
clock Specifies the SCML clock object that is associated with the clocked timer object.
Clocked timer objects can be constructed and destructed at any time during a simulation run
The following functions are provided to connect the clocked timer to an SCML clock.
void set_clock(scml_clock_if* clock);
Associates the clocked_timer  with the provided SCML clock.
void set_clock(sc_core::sc_in<bool>&amp; p);
Associates the clocked_timer  with the SCML clock, which is bound to the provided input port.
scml_clock_if* get_clock() const;
Returns the associated SCML clock.
Registering a callback for alarm notifications is typically done using the following macro:
m_clk_timer.set_callback(SCML2_CLOCKED_CALLBACK(clock_cb));
void start(long long ticks_per_period, long long shot_count=-1);
SystemC Modeling Library Reference Manual
X-2025.06-SP1
226</p>
</section>
<section id="page-227">
<h2>Page 227<a class="headerlink" href="#page-227" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
Starts the timer. It expires after ticks_per_period  ticks. For example, a timer started with
start (1)  expires at the next clock tick. With ticks_per_period = 0, the timer does not
start.
The argument shot_count  specifies how many alarm callbacks are triggered by the timer with
a distance of ticks_per_period  ticks. With shot_count = 1,the timer expires one time. With
shot_count = -1  (default), the timer runs forever or until it is stopped by calling stop(). With
shot_count=0  the timer does not start.
If start()  is called while the timer is running, it first be stopped before it is restarted. If a
running timer is started with ticks_per_period=0  or shot_count=0, the timer is stopped and
left in the idle state, so that it is not possible to resume it at a later time.
void start(const sc_core::sc_time&amp; period, long long shot_count=-1);
Starts the timer. This is a convenience method comparable to start(long&gt; long, long
long). The period in clock ticks is derived by the sc_time  argument period, by rounding up to
the next higher multiple of the current clock period. For more details, see the description of the
method, start(long  long, long long)
void stop();
Stops a running timer. The timer is left in a state that allows it to be resumed at a later time. It
has no effect, if called on an idle or already stopped timer.
bool resume_stopped();
Resume a stopped timer. Only timers that have been stopped by stop()  can be resumed.
In that case, the timer continues to run with the status at which it was stopped. If the timer
was stopped in the middle of a period, than the timer finishes the already started period. For
example, a timer started at clock tick 100with period=10  and shot_count=3, stopped at time
115 (after one alarm and another half period), and resumed at time 200, expires at the times
205 and 215.
It returns true  on success. It returns false, if it is called on an idle or already running timer.
unsigned long long get_counter_value();
Returns the value of the internal counter of the timer. It counts the number of clock ticks since
the last start or restart.
bool get_counter_value(const sc_core::sc_time delay, unsigned long long&amp; value);
Tries to retrieve the value of the internal counter of the timer for the future time
sc_time_stamp()+DELAY. For example, if called with DELAY=SC_ZERO_TIME, it delivers the
same value as get_counter_value(). The value can only be delivered if the provided delay is
shorter than the duration until the timer fires next, in which case the function returns true  and
writes the counter value into the reference argument VALUE. If delay exceeds the next fire time,
the function returns false  and does not write into VALUE. The function also fails and returns
false  in case it is called from a timer callback.
eState get_state();
SystemC Modeling Library Reference Manual
X-2025.06-SP1
227</p>
</section>
<section id="page-228">
<h2>Page 228<a class="headerlink" href="#page-228" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
Returns the state of the timer. To avoid dependency on scheduling order, the state at the
beginning of the current SystemC time is returned. A change to the state only becomes visible
after the SystemC time advances. If called from the timer callback, it returns the state before
the current clock cycle.
bool is_active();
Returns true, if the timer is running. To avoid dependency on scheduling order, the activity
state at the beginning of the current SystemC time is returned. A change to the state only
becomes visible after the SystemC time advances. If called from the timer callback, it returns
the state before the current clock cycle.
long long get_remaining_shot_count();
Returns the number of remaining shots. To avoid dependency on scheduling order, the activity
state at the beginning of the current SystemC time is returned. A change to the state only
becomes visible after the SystemC time advances. If called from the timer callback, it returns
the value before the current clock cycle.
4.6. Convenience Classes
•
scml2::clocked_callback
•
scml2::clocked_event
4.6.1. scml2::clocked_callback
The class scml2::clocked_callback  is a convenience class that forwards a clock tick callback to any
member function of a module without the need to inherit from the clocked_module  base class. This
makes it easier to have multiple clock callbacks within a single module. Since the callback is received
using a clocked_callback, it involves an internal method redirection which is slightly slower than a
callback received using inheriting the module directly from clocked_module.
Objects of type clocked_callback  can be constructed using the following constructor:
clocked_callback(const std::string&amp; name, scml_clock_if* clock=0)
where:
name
Specifies a name for the clocked callback object.
clock Specifies the SCML clock object that is associated with the clocked callback object.
Clocked callbacks can be constructed and destructed at any time during a simulation run. If a clocked
callback is destructed and there is still a pending callback request for that object, it will automatically be
canceled.
The following functions are provided to connect the clocked callback to an SCML clock.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
228</p>
</section>
<section id="page-229">
<h2>Page 229<a class="headerlink" href="#page-229" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
void set_clock(scml_clock_if* clock);
Associates the clocked_callback  with the provided SCML clock.
void set_clock(sc_core::sc_in<bool>&amp; p);
Associates the clocked_callback  with the SCML clock, which is bound to the provided input
port.
scml_clock_if* get_clock() const;
Returns the associated SCML clock.
Registering a method to be called as clock callback is typically done using the following macro:
m_clk_cb.set_callback(SCML2_CLOCKED_CALLBACK(clock_cb));
void request_trigger(long long clock_ticks_to_skip);
Schedules a callback for a future clock tick. The argument clock_ticks_to_skip  defines the
number of ticks that is skipped from now. This function can be called at any SystemC time.
If called while a previous callback request is still pending, the earlier one of the two is
maintained. That is, the new request is ignored if it targets the same or a later clock tick. If it
targets an earlier clock tick, then the previous request is canceled, and the request is scheduled
for the new earlier tick.
If a callback was requested, then the requested/scheduled clock tick can be retrieved by a call
to method get_scheduled_clock_tick().
For example, after a call of request_trigger(0), the clock tick count returned by
get_scheduled_clock_tick()  will be one larger than the current clock tick count of the
associated SCML clock.
void request_trigger(const sc_core::sc_time&amp; delay);
Schedules a callback for a future clock tick after the time defined by the argument delay. The
argument delay  is a SystemC time that is interpreted relative to the current SystemC time
sc_time_stamp(). This method is usually be used by TLM2 models with temporal decoupling
to synchronize to the next clock tick after the given local time argument.
If called while a previous callback request is still pending, the earlier one of the two is
maintained. That is, the new request is ignored if it targets the same or a later clock tick. If it
targets an earlier clock tick, then the previous request is canceled, and the request is scheduled
for the new earlier tick.
bool is_trigger_requested() const;
Returns true  if a callback was requested and is still pending.
void cancel_trigger();
SystemC Modeling Library Reference Manual
X-2025.06-SP1
229</p>
</section>
<section id="page-230">
<h2>Page 230<a class="headerlink" href="#page-230" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
Cancels a pending callback request. It does nothing, if no callback request is currently pending.
During the processing of a callback, it is not permitted to cancel a callback request that was
scheduled for the currently processed clock tick.
In certain cases, it can also be useful to create a one-shot callback. Here, the idea is to have a class
method to be called at one time on a clock tick. For this purpose, a set of global functions are provided
that create a clocked_callback  and trigger a request after a certain number of ticks or a certain
SystemC delay. This can be used for example, to trigger a certain behavior after a register access.
template &lt;class MOD_TYPE, typename FUNCPTR_TYPE&gt;
void request_clocked_method_callback(
scml_clock_if* clock, long long clock_ticks_to_skip,
MOD_TYPE* mod, FUNCPTR_TYPE func
);
template &lt;class MOD_TYPE, typename FUNCPTR_TYPE&gt;
void request_clocked_method_callback(
sc_core::sc_in<bool>&amp; clock_port, long long clock_ticks_to_skip,
MOD_TYPE* mod, FUNCPTR_TYPE func
);
template &lt;class MOD_TYPE, typename FUNCPTR_TYPE&gt;
void request_clocked_method_callback(
scml_clock_if* clock, const sc_core::sc_time&amp; delay,
MOD_TYPE* mod, FUNCPTR_TYPE func
);
template &lt;class MOD_TYPE, typename FUNCPTR_TYPE&gt;
void request_clocked_method_callback(
sc_core::sc_in<bool>&amp; clock_port, const sc_core::sc_time&amp; delay,
MOD_TYPE* mod, FUNCPTR_TYPE func
4.6.2. scml2::clocked_event
An scml2::clocked_event  is a convenience class that allows a SystemC method or thread to
wait until a certain clock tick happens. The clocked_event  object has the same set of APIs as a
clocked_module, but also provides a wait()  API, so that a thread can wait for a number of clock
cycles or for the first clock tick after a certain delay. It has a wait_for_trigger()  API that halts
execution, until a certain clock tick specified by requested_trigger  (similar to the clocked_module)
happens. This object also has a next_trigger()  API to mimic dynamic sensitivity of the methods. In
this case, the trigger is aligned with clock edges.
Objects of type clocked_event  can be constructed using one of the following constructors:
clocked_event(const std::string&amp; name, scml_clock_if* clock=0);
clocked_event(const std::string&amp; name, sc_core::sc_in<bool>&amp; p);
where:
name
Specifies a name for the clocked event object.
clock Specifies the SCML clock object that is associated with the clocked event object.
p
Specifies the input port through which the clocked event is bound to its associated SCML clock.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
230</p>
</section>
<section id="page-231">
<h2>Page 231<a class="headerlink" href="#page-231" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
Clocked events can be constructed and destructed at any time during a simulation run. If a clocked
callback is destructed and there is still a trigger pending, it will automatically be canceled. If a thread or
a method is waiting for a clock tick, it never wakes up or be activated again.
The following functions are provided to connect the clocked event to an SCML clock.
void set_clock(scml_clock_if* clock);
Associates the clocked_event  with the provided SCML clock.
void set_clock(sc_core::sc_in<bool>&amp; p);
Associates the clocked_event  with the SCML clock, which is bound to the provided input port.
scml_clock_if* get_clock() const;
Returns the associated SCML clock.
void request_trigger(long long clock_ticks_to_skip);
Schedules a trigger for a future clock tick, which wakes up a SystemC thread (which is called
wait()), or which reactivates a SystemC methods (which is called next_trigger()). The
argument clock_ticks_to_skip  defines the number of ticks that is skipped from now. It can
be called at any SystemC time.
If called while a previous trigger request is still pending, the earlier one of the two is maintained.
That is, the new request is ignored if it targets the same or a later clock tick. If it targets an
earlier clock tick, then the previous request is canceled, and the request is scheduled for the
new earlier tick.
If a trigger was requested, then the requested/scheduled clock tick can be retrieved by a call to
method get_scheduled_clock_tick().
For example, after a call of request_clock_trigger(0), the clock tick count returned by
get_scheduled_clock_tick()  is one larger than the current clock tick count of the associated
SCML clock.
void request_trigger(sc_core::sc_time delay);
Schedules a trigger for a future clock tick after the time defined by the argument delay. The
argument delay  is a SystemC time that is interpreted relative to the current SystemC time
sc_time_stamp(). This method usually is used by TLM2 models with temporal decoupling, to
synchronize to the next clock tick after the given local time argument.
If called while a previous trigger request is still pending, the earlier one of the two is maintained.
That is, the new request is ignored if it targets the same or a later clock tick. If it targets an
earlier clock tick, then the previous request is canceled, and the request is scheduled for the
new earlier tick.
bool is_trigger_requested() const;
Returns true  if a trigger was requested and is still pending.
void cancel_trigger();
SystemC Modeling Library Reference Manual
X-2025.06-SP1
231</p>
</section>
<section id="page-232">
<h2>Page 232<a class="headerlink" href="#page-232" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
Cancels a pending trigger request. It does nothing if no trigger is currently pending. During the
processing of a clock tick (that is from a callback, or a handle_clock_tick()  call), it is not
permitted to cancel a trigger request that was scheduled for the currently processed clock tick.
void waitfor_trigger();
Blocks the calling SystemC thread, until a clocked trigger happens. The clocked trigger is
requested by a call to the method request_trigger(ticks/delay). The blocked thread
wakes up when the requested clock tick happens. It must only be called from the context of a
SystemC thread.
void wait(long long clock_ticks_to_skip);
Blocks the calling SystemC thread, until the specified clock tick happened. The clock tick is
specified by the argument clock_ticks_to_skip, which defines the number of ticks that is
skipped from now. It can be called at any SystemC time, but only from the context of a SystemC
thread.
It is possible to wake up the thread at an earlier time by calling request_trigger(ticks/
delay)  with an argument that specifies an earlier clock tick. To wake up the thread at a later
time, it is first necessary to cancel the pending trigger with a call to cancel_trigger().
void wait(sc_core::sc_time delay);
Blocks the calling SystemC thread, until the specified clock tick happened. The clock tick is
specified by the argument delay, which is a SystemC time that is interpreted relative to the
current SystemC time sc_time_stamp(). This method usually is used by TLM2 models with
temporal decoupling to synchronize to the next clock tick after the given local time argument. It
can be called at any SystemC time, but only from the context of a SystemC thread.
It is possible to wake up the thread at an earlier time by calling request_trigger(ticks/
delay)  with an argument that specifies an earlier clock tick. To wake up the thread at a later
time, it is first necessary to cancel the pending trigger with a call to cancel_trigger().
void next_trigger();
Temporarily overrides the static sensitivity list of the calling SystemC method. The method
is reactivated when a certain clock tick happens. With this version of the next_trigger()
function, the triggering clock tick is left undefined. It must be scheduled by calling
request_trigger(ticks/delay).
void next_trigger(long long clock_ticks_to_skip);
Temporary overrides the static sensitivity list of the calling SystemC method. The method is
reactivated when the specified clock tick happens. The clock tick is specified by the argument
clock_ticks_to_skip, which defines the number of ticks that is skipped from now. It can be
called at any SystemC time, but only from the context of a SystemC method.
It is possible to reactivate the method at an earlier time by calling request_trigger(ticks/
delay)  with an argument that specifies an earlier clock tick. To wake up the method at a later
time, it is first necessary to cancel the pending trigger with a call to cancel_trigger().
SystemC Modeling Library Reference Manual
X-2025.06-SP1
232</p>
</section>
<section id="page-233">
<h2>Page 233<a class="headerlink" href="#page-233" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
void next_trigger(sc_core::sc_time delay);
Temporary overrides the static sensitivity list of the calling SystemC method. The method is
reactivated when the specified clock tick happens. The clock tick is specified by the argument
delay, which is a SystemC time that is interpreted relative to the current SystemC time
sc_time_stamp(). This method usually is used by TLM2 models with temporal decoupling to
synchronize to the next clock tick after the given local time argument. It can be called at any
SystemC time, but only from the context of a SystemC method.
It is possible to reactivate the method at an earlier time by calling request_trigger(ticks/
delay)  with an argument that specifies an earlier clock tick. To wake up the method at a later
time, it is first necessary to cancel the pending trigger with a call to cancel_trigger().
4.7. Modeling Objects for Convenience Classes (Convenience Objects)
•
scml2::clocked_peq_container
•
scml2::clocked_peq
4.7.1. scml2::clocked_peq_container
A typical problem in TLM2 FT models using the non-blocking APIs is that it can be required to manage
multiple outstanding transactions, possibly coming with different timing annotations from different
initiators. The clocked_peq_container  is a convenience object to help in this case. It can be used
to buffer payloads arriving in the model. Payloads are pushed into the container tagged with an arrival
stamp (clock tick counts to be precise). The container behaves like a list of payload that is sorted by the
arrival stamp. There is an API to iterate over the payloads in the buffer, the iterator only provides with
those payloads for which the arrival time is in the past (compared to the current SystemC time when
iterating). In this way, this object helps to comply with the basic FT clocked modeling rules. Because the
timestamp is stored based on tick counts, it is possible to adjust arrival times when clock parameters
change (period/enable/disable).
The API of the container conforms to the STL and provides iteration into the forward direction of the list
(from old to new payloads). There is a constant and a non-constant version of the iterator. The constant
iterator provides a faster iteration mechanism. The non-constant iterator allows removing the payload it
is pointing to from the list.
The scml2::clocked_peq_container  class is templated with the underlying type of the payload:
template <typename PAYLOAD> class clocked_peq_container;
The following type definitions for iterators are available:
typedef clocked_peq_container_iterator<PAYLOAD> iterator;
typedef clocked_peq_container_const_iterator<PAYLOAD> const_iterator;
Objects of type clocked_peq_container  can be constructed using one of the following constructors:
clocked_peq_container(scml_clock_if* clock=0);
clocked_peq_container(sc_core::sc_in<bool>&amp; p);
SystemC Modeling Library Reference Manual
X-2025.06-SP1
233</p>
</section>
<section id="page-234">
<h2>Page 234<a class="headerlink" href="#page-234" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
where:
clock Specifies the SCML clock object that is associated with the clocked PEQ container object.
p
Specifies the input port through which the clocked PEQ container is bound to its associated SCML clock.
The following functions are provided to connect the clocked PEQ container to an SCML clock.
void set_clock(scml_clock_if* clock);
Associates the clocked_peq_container  with the provided SCML clock.
void set_clock(sc_core::sc_in<bool>&amp; p);
Associates the clocked_peq_container  with the SCML clock, which is bound to the provided
input port.
scml_clock_if* get_clock() const;
Returns the associated SCML clock.
bool notify(PAYLOAD* payload, const sc_core::sc_time&amp; arrival_local_time);
Pushes a payload into the container that was received by a temporal decoupled transport
at local time arrival_local_time. The local time argument is given as SystemC time. It is
converted to the clock tick count by rounding down to the last clock tick.
bool notify(
PAYLOAD* payload, const sc_core::sc_time&amp; arrival_local_time,
long long delay_ticks
);
Pushes a payload into the container that was received by a temporal decoupled transport.
The local time is defined by two arguments, the SystemC time arrival_local_time  and the
additional number of clock ticks delay_ticks. The internal arrival clock tick count is calculated
by first converting arrival_local_time  to the clock tick count by rounding down to the last
clock tick, and then incrementing it by delay_ticks.
bool notify(void* payload, unsigned long long clock_ticks_to_skip);
Pushes a payload into the container that was received by a temporal decoupled transport at the
local time that is clock_ticks_to_skip  clock ticks in the future.
bool notifyAt(void* payload, unsigned long long arrival_tick_count);
Pushes a payload into the container that was received by a temporal decoupled transport at the
local time represented by the clock tick count arrival_tick_count.
bool is_empty() const;
Returns true  if the container is empty. This only considers visible payload (timestamp &lt;
get_clock()-&gt;get_tick_count()).
SystemC Modeling Library Reference Manual
X-2025.06-SP1
234</p>
</section>
<section id="page-235">
<h2>Page 235<a class="headerlink" href="#page-235" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
const_iterator begin() const;
Returns a constant iterator that points to the beginning of the internal sorted list. This only
considers visible payload (timestamp &lt; get_clock()-&gt;get_tick_count()).
iterator begin();
Returns a non-constant iterator that points to the beginning of the internal sorted list. This only
considers visible payload (timestamp &lt; get_clock()-&gt;get_tick_count()).
const_iterator end() const;
Returns a constant iterator that points to the end of the internal sorted list. This only considers
visible payload (timestamp &lt; get_clock()-&gt;get_tick_count()).
iterator end();
Returns a non-constant iterator that points to the end of the internal sorted list. This only
considers visible payload (timestamp &lt; get_clock()-&gt;get_tick_count()).
PAYLOAD* get_next();
Extracts the first element from the internal sorted list. It returns a null-pointer if the list is empty.
This only considers visible payload (timestamp &lt; get_clock()-&gt;get_tick_count()).
void remove(const iterator&amp; pos);
Removes the payload at the position, which is given by the iterator argument pos . The payload
itself is not deleted.
This operation invalidates all the iterators, which are currently pointing into the container.
Managing the iterators is the user’s responsibility.
bool remove(PAYLOAD* payload);
Removes the payload given by the payload  argument. The payload itself is not deleted. This
only considers visible payload (timestamp &lt; get_clock()-&gt;get_tick_count()). It returns
true  if the payload was found and removed. False  is returned if the payload was not found. If
the same payload is contained multiple times, than only the first occurrence is removed.
If this operation succeeds, it invalidates all iterators which are currently pointing into the
container. Managing the iterators is the user’s responsibility.
bool has_more_events() const;
Returns true  if more payload is available in the container. In contrast to the method
is_empty(), it considers not only the visible, but all payload. This method is usually used, if all
visible/past payload has been processed/removed, to check, if more processing has to be done
at a future time.
unsigned long long get_next_event_arrival_tick() const;};
Returns the arrival clock tick of the next payload in the sorted list of the container. This method
must not be called if has_more_events()  returned false.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
235</p>
</section>
<section id="page-236">
<h2>Page 236<a class="headerlink" href="#page-236" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
Note:
This method does not only consider the visible, but all payload. This method is usually used when all
current processing has been done, to retrieve the time for which more processing are scheduled.
An object of class clocked_peq_container_iterator  is a pointer into a clocked_peq_container
that allows iterating in forward direction over the sorted list of the container. This non-constant version
of iterators can be used to remove that payload from the container, which it is currently pointing to.
Iterating is slightly slower than with the constant version clocked_peq_container_const_iterator.
Iterators are usually generated by the begin()  and end()  method of a clocked PEQ container.
The scml2::clocked_peq_container_iterator  class is templated with the underlying type of the
payload:
template <typename PAYLOAD> class clocked_peq_container_iterator;
The API of the iterator conforms to the STL and provides the following methods:
PAYLOAD* operator*() const;
Returns the payload pointed to by the iterator.
PAYLOAD* operator-&gt;() const;
Returns the payload pointed to by the iterator.
self&amp; operator++();
Moves the iterator forward to the next entry in the container. It returns an iterator, that points to
the new position.
self operator++(int);
Moves the iterator forward to the next entry in the container. It returns an iterator, that points to
the old position.
bool operator==(const self&amp; x) const;
Compares the iterator to the other iterator x. It returns true, if both iterators are pointing to the
same position.
bool operator!=(const self&amp; x) const;
Compares the iterator to the other iterator x. It returns true, if both iterators are pointing to
different positions.
An object of class clocked_peq_container_const_iterator  is a pointer into a
clocked_peq_container  that allows iterating in forward direction over the sorted list of the
container. This constant iterator cannot be used to remove that payload from the container,
which it is currently pointing to. Iterating is slightly faster than with the non-constant version
clocked_peq_container_iterator. Iterators are usually generated by the begin()  and end()
method of a container.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
236</p>
</section>
<section id="page-237">
<h2>Page 237<a class="headerlink" href="#page-237" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
The scml2::clocked_peq_container_const_iterator  class is templated with the underlying type of
the payload:
template <typename PAYLOAD> class clocked_peq_container_const_iterator;
The API of the iterator conforms to the STL and provides the following methods:
const PAYLOAD* operator*() const;
Returns the payload pointed to by the iterator.
const PAYLOAD* operator-&gt;() const;
Returns the payload pointed to by the iterator.
self&amp; operator++();
Moves the iterator forward to the next entry in the container. It returns an iterator, that points to
the new position.
self operator++(int);
Moves the iterator forward to the next entry in the container. It returns an iterator, that points to
the old position.
bool operator==(const self&amp; x) const;
Compares the iterator to the other iterator x. It returns true, if both iterators are pointing to the
same position.
bool operator!=(const self&amp; x) const;
Compares the iterator to the other iterator x. It returns true, if both iterators are pointing to
different positions.
4.7.2. scml2::clocked_peq
This is a modeling object similar to the clocked_peq_container. It has a set of additional features:
•
It allows registering a callback, which is triggered whenever an element from the payload buffer
becomes available.
•
The callback is called when the SystemC time has moved forward to the point of the arrival/notified
time, that got stored with the payload in the buffer.
•
It is possible to block the callback triggers. When blocked, the callback is not triggered, until it is
unblocked.
•
When the callback is unblocked and the buffer contains a payload with arrival time that is in the past,
the callback is triggered at the next clock edge following the unblock time.
The scml2::clocked_peq  class is templated with the underlying type of the payload:
template <typename PAYLOAD> class clocked_peq;
SystemC Modeling Library Reference Manual
X-2025.06-SP1
237</p>
</section>
<section id="page-238">
<h2>Page 238<a class="headerlink" href="#page-238" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
The following type definitions for iterators are available:
typedef clocked_peq_iterator<PAYLOAD> iterator;
typedef clocked_peq_const_iterator<PAYLOAD> const_iterator;
Objects of type clocked_ peq  can be constructed using one of the following constructors:
clocked_peq(scml_clock_if* clock=0);
clocked_peq(sc_core::sc_in<bool>&amp; p);
where:
clock
Specifies the SCML clock object that is associated with the clocked PEQ container
object.
p
Specifies the input port through which the clocked PEQ container is bound to its
associated SCML clock.
The following functions are provided to connect the clocked PEQ to an SCML clock.
void set_clock(scml_clock_if* clock);
Associates the clocked_peq  with the provided SCML clock.
void set_clock(sc_core::sc_in<bool>&amp; p);
Associates the clocked_peq  with the SCML clock, which is bound to the provided input port.
scml_clock_if* get_clock() const;
Returns the associated SCML clock.
Registering a callback for notifications of new payload is typically done using the following macro:
m_clk_peq.set_callback(SCML2_CLOCKED_CALLBACK(clock_cb));
bool notify(PAYLOAD* payload, const sc_core::sc_time&amp; arrival_local_time);
Pushes a payload into the PEQ that was received by a temporal decoupled transport at local
time arrival_local_time. The local time argument is given as SystemC time. It is converted
to the clock tick count by rounding down to the last clock tick.
bool notify(PAYLOAD* payload, const sc_core::sc_time&amp; arrival_local_time, long long
delay_ticks);
Pushes a payload into the PEQ that was received by a temporal decoupled transport. The local
time is defined by two arguments, the SystemC time arrival_local_time  and the additional
number of clock ticks delay_ticks. The internal arrival clock tick count is calculated by first
converting arrival_local_time  to the clock tick count by rounding down to the last clock tick,
and then incrementing it by delay_ticks.
bool notify(void* payload, unsigned long long clock_ticks_to_skip);
SystemC Modeling Library Reference Manual
X-2025.06-SP1
238</p>
</section>
<section id="page-239">
<h2>Page 239<a class="headerlink" href="#page-239" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
Pushes a payload into the PEQ that was received by a temporal decoupled transport at the
local time that is, clock_ticks_to_skip  clock ticks in the future.
bool notifyAt(void* payload, unsigned long long arrival_tick_count);
Pushes a payload into the PEQ that was received by a temporal decoupled transport at the
local time represented by the clock tick count arrival_tick_count.
bool is_empty() const;
Returns true  if the PEQ is empty. This only considers visible payload (timestamp  &lt;
get_clock()-&gt; get_tick_count()).
const_iterator begin() const;
Returns a constant iterator that points to the beginning of the internal sorted list. This only
considers visible payload (timestamp &lt; get_clock()-&gt;get_tick_count()).
iterator begin();
Returns a non-constant iterator that points to the beginning of the internal sorted list. This only
considers visible payload (timestamp &lt; get_clock()-&gt;get_tick_count()).
const_iterator end() const;
Returns a constant iterator that points to the end of the internal sorted list. This only considers
visible payload (timestamp &lt; get_clock()-&gt;get_tick_count()).
iterator end();
Returns a non-constant iterator that points to the end of the internal sorted list. This only
considers visible payload (timestamp &lt; get_clock()-&gt;get_tick_count()).
PAYLOAD* get_next();
Extracts the first element from the internal sorted list. It returns a null pointer if the list was
empty. This only considers visible payload (timestamp &lt; get_clock()-&gt;get_tick_count()).
void remove(const iterator&amp; pos);
Removes the payload at position which is given by the iterator argument pos. The payload itself
is not deleted.
This operation invalidates all the iterators which are currently pointing into the container.
Managing the iterators is the user’s responsibility.
bool remove(PAYLOAD* payload);
Removes the payload given by the payload argument. The payload itself is not deleted. This
only considers visible payload (timestamp &lt; get_clock()-&gt;get_tick_count()). It returns
true  if the payload was found and removed. False  is returned if the payload was not found. If
the same payload is contained multiple times, than only the first occurrence is removed.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
239</p>
</section>
<section id="page-240">
<h2>Page 240<a class="headerlink" href="#page-240" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
If this operation succeeds, it invalidates all those iterators, which are currently pointing into the
container. Managing the iterators is the user’s responsibility.
bool has_more_events() const;
Returns true  if more payload is available in the container. In contrast to the method
is_empty(), this considers not only the visible, but all payload. This method is usually used,
if all visible/past payload has been processed/removed. To learn, if more processing has to be
done at a future time, even if no new payload is pushed into the container; an unblocked PEQ
schedules another callback notification for the future.
unsigned long long get_next_event_arrival_tick() const;
Returns the arrival clock tick of the next payload in the PEQ. This is the time tick at
which an unblocked PEQ sends the next callback. This method must not be called if
has_more_events()  returned false!
Note:
This method does not only consider the visible, but all payload. This method is usually used when all
current processing has been done, to retrieve the time, when the next callback notifies to continue
with more processing.
void block();
Blocks the sending of callbacks for the next payload arrival time.
void unblock(const sc_core::sc_time&amp; local_time_before_clock_tick);
Schedules to unblock the PEQ after a SystemC time interval of
local_time_before_clock_tick. If at the time of unblocking, the PEQ contains a payload
with an arrival time that lays in the past, then a callback is sent at the next clock edge following
the unblock time.
For example: Calling unblock(SC_ZERO_TIME)  on a blocked PEQ, that contains a visible
payload (arrival time in the past) schedules a callback for the next clock tick.
void unblock(const sc_core::sc_time&amp; local_time_before_clock_tick, long long
delay_ticks);
Schedules to unblock the PEQ after a SystemC time interval of
local_time_before_clock_tick  plus delay_ticks  clock ticks. For more details, see the
method unblock(const sc_core::sc_time&amp;).
void unblock(unsigned long long clock_ticks_to_skip);
Schedules to unblock the PEQ after clock_ticks_to_skip  clock ticks. For more details, see
the method unblock(const sc_core::sc_time&amp;).
For example: Calling unblock(0)  on a blocked PEQ that contains a visible payload (arrival time
in the past) schedules a callback for the next clock tick.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
240</p>
</section>
<section id="page-241">
<h2>Page 241<a class="headerlink" href="#page-241" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
void unblockAt(unsigned long long tick_count_for_unblock);
Schedules to unblock the PEQ for the time given by the clock tick count
tick_count_for_unblock. If tick_count_for_unblock  lays in the past, then the PEQ
is unblocked at the next tick count. For more details, see the method unblock(const
sc_core::sc_time&amp;).
For example: Calling unblockAt(get_clock()-&gt;get_tick_count())  on a blocked PEQ that
contains a visible payload (arrival time in the past) schedules a callback for the next clock tick.
An object of class clocked_peq_iterator  is a pointer into a clocked_peq  that allows iterating in
forward direction over the sorted list of the PEQ. This non-constant version of iterators can be used
to remove the payload it is currently pointing to from the PEQ. Iterating is slightly slower than with the
constant version clocked_peq_const_iterator. Iterators are usually generated by the begin()  and
end()  method of a clocked PEQ.
The scml2::clocked_peq_iterator  class is templated with the underlying type of the payload:
template <typename PAYLOAD> class clocked_peq_iterator;
The API of the iterator conforms to the STL and provides the following methods:
PAYLOAD* operator*() const;
Returns the payload pointed to by the iterator.
PAYLOAD* operator-&gt;() const;
Returns the payload pointed to by the iterator.
self&amp; operator++();
Moves the pointer forward to the next entry in the PEQ. It returns an iterator that points to the
new position.
self operator++(int);
Moves the pointer forward to the next entry in the PEQ. It returns an iterator that points to the
old position.
bool operator==(const self&amp; x) const;
Compares the iterator to the other iterator x. It returns true  if both iterators are pointing to the
same position.
bool operator!=(const self&amp; x) const;
Compares the iterator to the other iterator x. It returns true  if both iterators are pointing to
different positions.
An object of class clocked_peq_const_iterator  is a pointer into a clocked_peq  that allows iterating
in forward direction over the sorted list of the PEQ. This constant iterator cannot be used to remove the
payload it is currently pointing to from the PEQ. Iterating is slightly faster than with the non-constant
SystemC Modeling Library Reference Manual
X-2025.06-SP1
241</p>
</section>
<section id="page-242">
<h2>Page 242<a class="headerlink" href="#page-242" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
version clocked_peq_iterator. Iterators are usually generated by the begin()  and end()  method of
a container.
The scml2::clocked_peq_const_iterator  class is templated with the underlying type of the payload:
template <typename PAYLOAD> class clocked_peq_const_iterator;
The API of the iterator conforms to the STL and provides the following methods:
const PAYLOAD* operator*() const;
Returns the payload pointed to by the iterator.
const PAYLOAD* operator-&gt;() const;
Return the payload pointed to by the iterator.
self&amp; operator++();
Moves the pointer forward to the next entry in the PEQ. It returns an iterator that points to the
new position.
self operator++(int);
Moves the pointer forward to the next entry in the PEQ. It returns an iterator that points to the
old position.
bool operator==(const self&amp; x) const;
Compares the iterator to the other iterator x. It returns true  if both iterators are pointing to the
same position.
bool operator!=(const self&amp; x) const;
Compares the iterator to the other iterator x. It returns true  if both iterators are pointing to
different positions.
4.8. Code Example
c
l
o
c
k</p>
<p>o
b
j
e
c
t
s
e
x
a
m
p
l
e
This section describes how a programmable clock peripheral can be implemented based on
scml_clock.
•
Programmable Clock Peripherals
4.8.1. Programmable Clock Peripherals
Programmable clock peripherals and timers can be coded easily by using clock tick callbacks.
This is achieved by deriving the Timer from scml2::clocked_module  and implementing
handle_clock_tick():
SC_MODULE Timer: private scml2::clocked_module {
public:
SystemC Modeling Library Reference Manual
X-2025.06-SP1
242</p>
</section>
<section id="page-243">
<h2>Page 243<a class="headerlink" href="#page-243" title="Permalink to this heading"></a></h2>
<p>Chapter 4: Clock Objects
 
sc_in<bool> clk_in;
[…]
private:
[…]
virtual void end_of_elaboration() {
set_clock(clk_in);
}
virtual void handle_clock_tick();
};
The functionality of the peripheral is implemented in the callback function attached to a memory-
mapped register, modeled as an object of type scml_memory.
For example, consider a module with the following data members:
scml_memory <unsigned int> CURRENT_VALUE_REG;
scml_memory <unsigned int> END_VALUE_REG;
unsigned long long mTimerStartTickCount;
Two call-back functions are registered with the END_VALUE_REG  memory-mapped register:
MEMORY_REGISTER_READ(CURRENT_VALUE_REG, f_read_curr_value);
MEMORY_REGISTER_WRITE(END_VALUE_REG, f_write_end_value);
The implementation of the write callback writes a new value to END_VALUE_REG  memory-mapped
register and restarts the timer:
void f_write_end_value(unsigned int new_value, unsigned int, unsigned int) {
END_VALUE_REG=new_value;
cancel_clock_trigger();
mTimerStartTickCount=get_clock()-&gt;get_tick_count();
request_clock_trigger(END_VALUE_REG - 1);
}
The actual counter value of the timer is only calculated on demand. The implementation of the read
callback takes the current tick count of the driving clock and subtracts the tick count from when the timer
started:
unsigned int f_read_curr_value(unsigned int, unsigned int) {
return (unsigned int) (get_clock()-&gt;get_tick_count() - mTimerStartTickCount);
}
SystemC Modeling Library Reference Manual
X-2025.06-SP1
243</p>
</section>
<section id="page-244">
<h2>Page 244<a class="headerlink" href="#page-244" title="Permalink to this heading"></a></h2>
<p>Chapter 5
Pulse TLM Modeling
The Pulse protocol is a TLM representation of a bool signal to model clocks, Pulse Width Modulation
(PWM) signals or any other regular or recurring Boolean signal in a system. Other than the default
SystemC representation using sc_signal<bool>, the pulse signal adds information so that it is
possible to avoid individual signal value change events for signals with a regular repeating pulse
shape. The result is better simulation performance. It is like the scml_clock_if  in that it represents
a repeating signal with a repeat frequency, start time, period, and active/idle width, but it differs from
the scml_clock_if  in that it also allows for irregular pulse shapes. The latter prevents that modelers
need to fall back to the default SystemC sc_signal  whenever a model may generate irregular or
unpredictable signals in certain cases.
The basis for Pulse TLM modeling is the pulse interface and the derived pulse protocol and pulse
modeling objects.
•
The pulse protocol is a TLM2 standards-based set of sockets and TLM interfaces built using the
pulse interface. The pulse protocol engine provides basic access to the pulse interface features or
allows to forward the pulse interface to reuse objects for further processing.
•
The pulse modeling objects provide a basic set of building blocks to create PWM generators, timers,
and clock dividers.
This chapter describes:
•
The Pulse Interface
5.1. The Pulse Interface
The pulse interface is a generic modeling interface used by building blocks as well as for model
interfaces. It is the basic interface shared by both types of components for exchanging information. The
pulse interface provides with pulse information for a Boolean signal:
•
It indicates whether the pulse is: occurs once, runs for a predefined number of periods, or
continuous running.
•
It provides with pulse shaping information: active level, start time, period, active width, and idle
width.
•
The pulse shaping information is static. Any change to the shape of the pulse implies the definition
of a new pulse shape with an updated start time, and so on. With every change, a pulse generator
should notify its observers that a new pulse definition is available.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
244</p>
</section>
<section id="page-245">
<h2>Page 245<a class="headerlink" href="#page-245" title="Permalink to this heading"></a></h2>
<p>Chapter 5: Pulse TLM Modeling
 
The pulse interface consists of:
•
An interface called by the pulse generator to notify pulse users of any changes in pulse shape
information for predictable pulses. In case of unpredictable pulses, a pulse generator uses the
forward interface to indicate a new pulse edge occurred.
•
An interface used by the pulse user to fetch the pulse shape information, get information about
future events for the pulse, and register itself as a pulse observer.
The pulse interface provides with three interface styles:
•
When the pulse is predictable and static, a target of the pulse can calculate future events for
the pulse using the pulse shape information. So, rather than counting pulse edges, a target can
calculate itself at which timepoint the N’th edge occurs using the start time, period, active and idle
width parameters. This interfacing style is the best for simulation performance.
•
When the pulse is predictable but has a semi-variable period, it is no longer possible for the target
to calculate future events based on the pulse period and so on, since these may change. However,
since the pulse is still predictable (the changes to the pulse shape are predictable and known to the
generator) it is possible for the target to request any future timepoint from the pulse generator. This
interfacing style is still good for simulation performance. The APIs to request future timepoints also
applies when the pulse is predictable and static.
•
When the pulse shape is not predictable or varies, the pulse generator should call the observer APIs
at each activation and idle event. Since this coding style generates simulation activity for every edge
this is less optimal for simulation performance.
A pulse generator should try to use the most optimal interfacing style at any point in time, but may need
to fall back to the less optimized style when needed. This change of style can happen during runtime,
for example, with a new configuration of the generator. The receiving side of a pulse should support
both interfacing styles. The target of a pulse interface cannot make any assumptions about the style
used at a certain point in time by a pulse generator.
•
The Pulse Definition Interface
•
The Pulse Observer Interface
5.1.1. The Pulse Definition Interface
Components or building blocks that define pulses should implement the pulse_if  interface. The
definition of the pulse interface is as follows:
class pulse_if {
public:
virtual ~pulse_if() {}
virtual bool is_enabled() =0;
virtual bool get_active_value() = 0;
virtual int get_run_mode() =0;
virtual bool is_predictable() =0;
virtual bool has_fixed_period() = 0;
virtual sc_core::sc_time get_period() =0;
virtual sc_core::sc_time get_start_time() =0;
SystemC Modeling Library Reference Manual
X-2025.06-SP1
245</p>
</section>
<section id="page-246">
<h2>Page 246<a class="headerlink" href="#page-246" title="Permalink to this heading"></a></h2>
<p>Chapter 5: Pulse TLM Modeling
 
virtual sc_core::sc_time get_active_width() =0;
virtual sc_core::sc_time get_idle_width() =0;
virtual unsigned long long get_pulse_count() =0;
virtual sc_core::sc_time get_active_time(unsigned long long
activations_to_skip=0) =0;
virtual sc_core::sc_time get_idle_time(unsigned long long idles_to_skip=0) =0;
virtual bool is_active() = 0;
virtual bool register_observer(pulse_observer*) =0;
virtual bool unregister_observer(pulse_observer*) =0;
};
The APIs are explained in subsequent sections:
•
bool is_enabled();
•
bool get_active_value();
•
bool is_predictable();
•
int get_run_mode();
•
bool has_fixed_period();
•
sc_core::sc_time get_start_time();
•
sc_core::sc_time get_period();
•
sc_core::sc_time get_active_width();
•
sc_core::sc_time get_idle_width();
•
unsigned long long get_pulse_count();
•
sc_core::sc_time get_active_time(unsigned long long activations_to_skip=0);
•
sc_core::sc_time get_idle_time(unsigned long long idles_to_skip=0);
•
bool is_active();
•
bool register_observer(pulse_observer*); bool unregister_observer(pulse_observer*);
bool is_enabled();
The return value of this API indicates whether the pulse is running or deactivated. For a PWM-based
pulse, this setting also controls whether the counter is active. This setting overrules the run mode value
(see below).
Note:
By default and at simulation start, pulses are disabled (unlike clocks which are running).
SystemC Modeling Library Reference Manual
X-2025.06-SP1
246</p>
</section>
<section id="page-247">
<h2>Page 247<a class="headerlink" href="#page-247" title="Permalink to this heading"></a></h2>
<p>Chapter 5: Pulse TLM Modeling
 
bool get_active_value();
This interface indicates the intended Boolean value for the active phase of the pulse. Pulse generators
should use this setting when they associate a certain bool value with the active state of the pulse and
must forward that further in the design. Pulse receivers can decide to ignore or overwrite this setting.
bool is_predictable();
The return value of this API indicates whether the pulse is predictable. When an observer of a pulse
receives a parameter updated  call, it should use this API to check what interface style of the pulse to
use. A pulse is predictable, if it is possible to calculate the timepoint for all edges for the pulse from the
start time, period, active width, and idle width values.
Note:
By default and at simulation start, pulses are predictable.
int get_run_mode();
This API indicates the predicted number of periods this pulse will emit. Allowed values are:
Allowed
Values
Description
-1
Indicates a continuously running pulse with no end time.
N (&gt;0)
A fixed number of pulses, each 1 period long (1 for one-shot).
0
Indicates a disabled pulse.
The run mode should be ignored for a disabled pulse (enabled()  returns false). It is OK to have run
mode == -1  when is_enabled  is false. It is an error to have a predictable pulse enabled and run
mode  set to 0. This setting does not apply to unpredictable pulses.
bool has_fixed_period();
Indicates whether the pulse has a fixed or variable period. When the pulse has a fixed period and
is predictable, then a pulse observer can calculate future events using period, active width, and idle
width. A predictable pulse that does not have a fixed period should use the get_active_time  and
get_idle_time  APIs. Predictable pulses with a fixed period are like clocks and derived pulses can also
be predictable. Pulses derived from a predictable pulse with a variable period are no longer predictable
themselves.
sc_core::sc_time get_start_time();
This API gets the starting point for the pulse. Returns the SystemC kernel time at which point the first
pulse starts. A pulse starts with an active period and is followed by the idle period. Pulses cannot start
with an idle period; in that case, the start time should be delayed.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
247</p>
</section>
<section id="page-248">
<h2>Page 248<a class="headerlink" href="#page-248" title="Permalink to this heading"></a></h2>
<p>Chapter 5: Pulse TLM Modeling
 
When receiving a parameter updated  call, start time can be in the future or in the past:
•
The start time is in the future in case there is a ramp-up period for the pulse to start.
•
The start time is in the past for example, for a PWM generator in case there is a clock or frequency
change in the middle of the pulse. In such a case, the start time should be recalculated to ensure
that future events of the current pulse still happen at the expected timepoint. This may require start
time to be in the past.
Start time only applies for predictable pulses with a fixed period.
sc_core::sc_time get_period();
Returns the period of the pulse, this is the total length of a single pulse (the sum of the time the pulse is
active and the time the pulse is idle). The period only applies to predictable pulses with a fixed period.
sc_core::sc_time get_active_width();
Returns the width of the pulse (the time it is active). It is possible for the active width to be
SC_ZERO_TIME, for example, in case of a 0%  duty cycle. Active width only applies to predictable pulses
with a fixed period.
sc_core::sc_time get_idle_width();
Returns the width of the inactive part of the pulse. It is possible for the idle width to be SC_ZERO_TIME,
for example, in case of 100%  duty cycle. Idle width only applies to predictable pulses with a fixed period.
unsigned long long get_pulse_count();
Returns the number of pulses that have occurred on this pulse_if. It is up to the pulse generator
implementation to decide when to (re-)start the pulse count. The pulse count should continue after a
parameter update even if that implies a start time that does not corresponds to the first counted pulse.
The pulse count should be available for predictable as well as unpredictable pulses.
sc_core::sc_time get_active_time(unsigned long long
activations_to_skip=0);
Returns the SystemC time for a future activation edge. The return value is the absolute timepoint,
that is, not relative to the current SystemC time. Returns the SystemC time for the activation (start
of next active time) that happens after activations_to_skip  activations from now. When called
with activations_to_skip  set to 0  (default), it should return the activation time of the current pulse,
which could be in the past. If it is not possible to predict the activation edge the API call should return
SC_ZERO_TIME. This API can be used for predictable pulses with fixed and variable periods, but not for
non-predictable pulses.
sc_core::sc_time get_idle_time(unsigned long long idles_to_skip=0);
Returns the SystemC time for a future idle edge. The return value is the absolute timepoint, that is, not
relative to the current SystemC time. Returns the SystemC time for the switch to idle that happens after
idles_to_skip  idle states from now. When called with idles_to_skip=0  (default), it should return
SystemC Modeling Library Reference Manual
X-2025.06-SP1
248</p>
</section>
<section id="page-249">
<h2>Page 249<a class="headerlink" href="#page-249" title="Permalink to this heading"></a></h2>
<p>Chapter 5: Pulse TLM Modeling
 
the time for the idle edge of the idle edge for the current pulse, which could be in the past, If it is not
possible to predict the idle edge the API call should return SC_ZERO_TIME. This API can be used for
predictable pulses with fixed and variable periods, but it not for non-predictable pulses.
bool is_active();
Should return true when the pulse is active for the current SystemC time. This API can be used for
predictable as well as unpredictable pulses.
bool register_observer(pulse_observer*); bool
unregister_observer(pulse_observer*);
These APIs register or deregister pulse observers. A pulse generator should notify all its observers
whenever there is a change in the pulse shaping information for predictable pulses, and on each active
an idle edge for unpredictable pulses.
5.1.2. The Pulse Observer Interface
The pulse_observer  interface should be implemented by components or building blocks that receive
pulses. Pulse generators should call the observer APIs to notify the pulse receivers of changes or
events. The definition of the pulse observer interface is as follows:
class pulse_observer {
public:
virtual ~pulse_observer() {}
virtual void handle_pulse_parameters_updated(scml2::objects::pulse_if*) =0;
virtual void handle_pulse_activation(scml2::objects::pulse_if*) =0;
virtual void handle_pulse_idle(scml2::objects::pulse_if*) =0;
virtual void handle_pulse_deleted(scml2::objects::pulse_if*) =0;
};
The APIs are explained in the following sections:
•
void handle_pulse_parameters_updated(scml2::objects::pulse_if*);
•
void handle_pulse_activation(scml2::objects::pulse_if*);
•
void handle_pulse_idle(scml2::objects::pulse_if*);
•
void handle_pulse_deleted(scml2::objects::pulse_if*);
void handle_pulse_parameters_updated(scml2::objects::pulse_if*);
Pulse generators should call this API to notify the pulse observers of any or changes to the pulse
definition. This is whenever the pulse is enabled or disabled or when the predictability of the pulse
is changing. Pulse generators should call the API whenever any parameter of a predictable pulse is
changing (active level, start time, period, active/idle width). The pulse_if*  argument allows to observe
multiple pulse interfaces from a single implementation.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
249</p>
</section>
<section id="page-250">
<h2>Page 250<a class="headerlink" href="#page-250" title="Permalink to this heading"></a></h2>
<p>Chapter 5: Pulse TLM Modeling
 
Rules to consider for a parameter update:
•
A parameter update results in a new pulse definition, that is, users of the pulse information should
disregard all previous information immediately (no transition effects). A series of pulses can be
generated as a series of one-shot pulses or pulses with a run mode set larger than 0 .
•
On a pulse update for all future events related to that pulse or derived from that pulse definition
should be canceled.
•
It is allowed for an update to define a new pulse with start time in the past. Periods in the past should
be ignored. An activation edge in the past is possible as transitional effect of a clock frequency
update when moving to a slower clock.
•
It is allowed to disable a pulse at any time, it is up to the receiving model to define the consequences
related to that (signal resets and so on.)
void handle_pulse_activation(scml2::objects::pulse_if*);
Pulse generators should use this to notify the pulse observers of a pulse activation event for
unpredictable pulses.
Rules to consider for a pulse activation call:
•
A pulse generator should call this API when the active part of a pulse starts.
•
It can be called from a method process (that is, no wait()  call is allowed in the implementation).
•
It is not allowed for predictable pulses.
•
It is not allowed for disabled pulses.
•
When a pulse activation call is received, all pulse shaping information of that pulse definition should
be ignored (as with unpredictable pulses in general).
void handle_pulse_idle(scml2::objects::pulse_if*);
Pulse generators should use this to notify the pulse observers that the pulse is entering the idle phase
for unpredictable pulses.
Rules to consider for a pulse idle call:
•
A pulse generator should call this API when the idle part of a pulse starts.
•
It can be called from a method process (that is, no wait()  call is allowed in the implementation).
•
It is not allowed for predictable pulses.
•
It is not allowed for disabled pulses.
•
When a pulse activation call is received all pulse shaping information of that pulse definition should
be ignored (as with unpredictable pulses in general).
SystemC Modeling Library Reference Manual
X-2025.06-SP1
250</p>
</section>
<section id="page-251">
<h2>Page 251<a class="headerlink" href="#page-251" title="Permalink to this heading"></a></h2>
<p>Chapter 5: Pulse TLM Modeling
 
void handle_pulse_deleted(scml2::objects::pulse_if*);
Pulse generators should use this to notify the pulse observers of the deletion of the pulse_if. It should
be used to ensure a proper cleanup at the end of a simulation. Local copies of the pulse_if  pointer
should be ignored and the pulse observer should no longer try to access any information from this pulse
after this call.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
251</p>
</section>
<section id="page-252">
<h2>Page 252<a class="headerlink" href="#page-252" title="Permalink to this heading"></a></h2>
<p>Chapter 6
Modeling Utilities
This chapter describes:
•
Port Utilities
•
Commands
•
Parameters
•
Reporting
•
FastTrack
6.1. Port Utilities
This section describes:
•
dmi_handler
•
initiator_socket
•
Pin Callback Functions
•
Utility APIs
6.1.1. dmi_handler
d
m
i
_
h
a
n
d
l
e
r
scml2::dmi_handler  is a convenience object that takes care of the DMI pointer requests and book
keeping. The object is targeting protocols for which the DMI handling is the same as for the TLM2
base protocol. It may be required to create a dedicated DMI handler for other protocol definitions, for
example, when address decoding can be influenced by other attributes like security and so on. The
DMI handler is initialized by giving it an interface that it should use to initiate TLM2 transport calls. The
model itself should then use the read and write APIs of the DMI handler to start a transaction. The DMI
handler first checks if it does not have a pointer available to provide the read or write data, if not it tries
to request a DMI pointer and if that fails it forwards the transaction of the TLM2 interface. The DMI
handler also has APIs to control whether DMI accesses are attempted.
The include file of the dmi_handler  objects is scml2/dmi_handler.h.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
252</p>
</section>
<section id="page-253">
<h2>Page 253<a class="headerlink" href="#page-253" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
The following sections describe:
•
Methods that are available to configure the dmi_handler  object:
•
The access methods of the dmi_handler  object.
The following methods are available to configure the dmi_handler  object:
d
m
i
_
h
a
n
d
l
e
r
s
e
t
_
i
n
t
e
r
f
a
c
e
(
)</p>
<p>m
e
t
h
o
d
void set_interface(tlm::tlm_fw_direct_mem_if<a class="reference external" href="tlm::tlm_generic_payload">tlm::tlm_generic_payload</a>* ifs)
Sets the forward DMI. This interface is used to request the DMI pointers.
d
m
i
_
h
a
n
d
l
e
r
i
s
_
d
m
i
_
e
n
a
b
l
e
d
(
)</p>
<p>m
e
t
h
o
d
bool is_dmi_enabled()
Returns true  if DMI accesses are allowed for the object, false  otherwise. DMI is enabled by
default.
d
m
i
_
h
a
n
d
l
e
r
e
n
a
b
l
e
_
d
m
i
(
)</p>
<p>m
e
t
h
o
d
void enable_dmi()
d
m
i
_
h
a
n
d
l
e
r
d
i
s
a
b
l
e
_
d
m
i
(
)</p>
<p>m
e
t
h
o
d
void disable_dmi()
Enables/disables DMI accesses for the object.
d
m
i
_
h
a
n
d
l
e
r
w
r
i
t
e
(
)</p>
<p>m
e
t
h
o
d
d
m
i
_
h
a
n
d
l
e
r
r
e
a
d
(
)</p>
<p>m
e
t
h
o
d
bool read(unsigned long long address,
unsigned char* data,
unsigned int dataLength,
const unsigned char* byteEnables,
unsigned int byteEnableLength,
sc_core::sc_time&amp; t)
bool write(unsigned long long address,
const unsigned char* data,
unsigned int dataLength,
const unsigned char* byteEnables,
unsigned int byteEnableLength,
sc_core::sc_time&amp; t)
bool read(unsigned long long address,
unsigned char* data,
unsigned int dataLength,
sc_core::sc_time&amp; t)
bool write(unsigned long long address,
const unsigned char* data,
unsigned int dataLength,
sc_core::sc_time&amp; t)
Try to do a DMI access. If a DMI access is not possible or if the access does not fit into one
DMI range, false  is returned. Otherwise the data is copied and true  is returned. The t
argument is incremented with the read or write latency, respectively.
d
m
i
_
h
a
n
d
l
e
r
r
e
a
d
_
d
e
b
u
g
(
)</p>
<p>m
e
t
h
o
d
bool read_debug(unsigned long long address,
unsigned char* data,
unsigned int dataLength)
bool write_debug(unsigned long long address,
const unsigned char* data,
unsigned int dataLength)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
253</p>
</section>
<section id="page-254">
<h2>Page 254<a class="headerlink" href="#page-254" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
Tries to do a DMI access. If a DMI access is not possible or if the access does not fit into one
DMI range, false  is returned. Otherwise the data is copied and true  is returned.
d
m
i
_
h
a
n
d
l
e
r
t
r
a
n
s
p
o
r
t
_
d
e
b
u
g
(
)</p>
<p>m
e
t
h
o
d
d
m
i
_
h
a
n
d
l
e
r
t
r
a
n
s
p
o
r
t
(
)</p>
<p>m
e
t
h
o
d
bool transport(tlm::tlm_generic_payload&amp; trans, sc_core::sc_time&amp; t)
bool transport_debug(tlm::tlm_generic_payload&amp; trans)
Try to do a DMI access. If a DMI access is not possible or if the access does not fit into one
DMI range, false  is returned. Otherwise the data is copied and true  is returned.
d
m
i
_
h
a
n
d
l
e
r
i
n
v
a
l
i
d
a
t
e
_
d
i
r
e
c
t
_
m
e
m
_
p
t
r
(
)</p>
<p>m
e
t
h
o
d
void invalidate_direct_mem_ptr(sc_dt::uint64 startRange,
sc_dt::uint64 endRange)
Must be called when the DMI pointers have to be invalidated.
The dmi_handler  object has the following access methods:
6.1.2. initiator_socket
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
scml2::initiator_socket  is a convenience TLM2 initiator socket specifically targeting the LT coding
style. It contains a dmi_handler  to manage DMI accesses and it implements the mappable_if  so that
this socket can be used as a destinations for a router. The initiator_socket  also gets a reference
to a quantum_keeper  that it uses to maintain timing annotation whenever the dmi_handler  does an
access of the forward transport interface of the socket. Transactions are initiated in the same way as for
the dmi_handler; that is, using read and write APIs.
The initiator_socket  object implements the mappable_if object, which means that it can be the
destination for a mapped range of a router object.
The include file of the initiator_socket  objects is scml2/initiator_socket.h.
The initiator_socket  class is templated with the BUSWIDTH:
template <unsigned int BUSWIDTH> class initiator_socket
The following methods are available to configure the initiator_socket  object:
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
s
e
t
_
q
u
a
n
t
u
m
k
e
e
p
e
r
(
)</p>
<p>m
e
t
h
o
d
template <typename T>
void set_quantumkeeper(T&amp; quantumKeeper)
Sets the quantum keeper the socket should use. The registered class must implement the
following methods (see the section on tlm_quantumkeeper  in the IEEE Std 1666 TLM-2.0
Language Reference Manual):
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
g
e
t
_
l
o
c
a
l
_
t
i
m
e
(
)</p>
<p>m
e
t
h
o
d
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
s
y
n
c
(
)</p>
<p>m
e
t
h
o
d
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
n
e
e
d
_
s
y
n
c
(
)</p>
<p>m
e
t
h
o
d
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
s
e
t
(
)</p>
<p>m
e
t
h
o
d
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
i
n
c
(
)</p>
<p>m
e
t
h
o
d
void inc(const sc_core::sc_time&amp; t)
void set(const sc_core::sc_time&amp; t)
bool need_sync() const
void sync()
sc_core::sc_time get_local_time() const
If a quantum keeper is set, the socket passes the local time when doing a bus access and
increment the local time when the timing annotation was incremented by the DMI access or bus
access. If needed (need_sync()  returns true), the socket synchronizes the quantum keeper
after incrementing the local time.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
254</p>
</section>
<section id="page-255">
<h2>Page 255<a class="headerlink" href="#page-255" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
If no quantum keeper is set, sc_core::SC_ZERO_TIME  is passed and wait()  is called if the
timing annotation was incremented.
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
s
e
t
_
e
n
d
i
a
n
n
e
s
s
(
)</p>
<p>m
e
t
h
o
d
void set_endianness(tlm::tlm_endianness endianness)
Sets the endianness of the initiator mode. If the endianness is different from the host
endianness, the socket converts the address and data before doing the access.
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
i
s
_
d
m
i
_
e
n
a
b
l
e
d
(
)</p>
<p>m
e
t
h
o
d
bool is_dmi_enabled()
Returns true  if DMI accesses are allowed for the object, false  otherwise. DMI is enabled by
default.
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
d
i
s
a
b
l
e
_
d
m
i
(
)</p>
<p>m
e
t
h
o
d
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
e
n
a
b
l
e
_
d
m
i
(
)</p>
<p>m
e
t
h
o
d
void enable_dmi()
void disable_dmi()
Enables/disables DMI accesses for the object.
The following access methods are available:
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
w
r
i
t
e
(
)</p>
<p>m
e
t
h
o
d
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
r
e
a
d
(
)</p>
<p>m
e
t
h
o
d
template <typename DT>
bool read(unsigned long long address, DT&amp; data)
template <typename DT>
bool write(unsigned long long address, const DT&amp; data)
Access methods to do single-word or subword accesses. The data passed must be in
arithmetic format (host endianness). If the endianness of the socket is different from the host
endianness, the data and address is converted before doing the access. First a DMI access
is done. If this fails, a bus access (b_transport()) is done. If this access fails with an error
response, false  is returned, otherwise true  is returned. If a quantum keeper is set, the local
time is passed with the bus access and the local time of the quantum keeper is incremented
with the returned timing annotation. If no quantum keeper is set, SC_ZERO_TIME  is passed and
wait()  is called if the timing annotation was incremented.
template <typename DT>
bool read(unsigned long long address, DT* data, unsigned int count)
template <typename DT>
bool write(unsigned long long address, const DT* data, unsigned int count)
Access methods for burst accesses. The passed data pointer should contain an array of words
in arithmetic format (host endianness). If the endianness of the socket is different from the host
endianness, the data and address are converted before doing the access. First a DMI access
is done. If this fails, a bus access (b_transport()) is done. If this access fails with an error
response, false  is returned; otherwise true  is returned. If a quantum keeper is set, the local
time is passed with the bus access and the local time of the quantum keeper is incremented
with the returned timing annotation. If no quantum keeper is set, SC_ZERO_TIME  is passed and
wait()  is called if the timing annotation was incremented.
template <typename DT>
bool read(unsigned long long address, DT&amp; data, sc_core::sc_time&amp; t)</p>
<p>template <typename DT>
bool write(unsigned long long address, const DT&amp; data, sc_core::sc_time&amp; t)
SystemC Modeling Library Reference Manual
X-2025.06-SP1
255</p>
</section>
<section id="page-256">
<h2>Page 256<a class="headerlink" href="#page-256" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
Access methods to do single-word or subword accesses. The data passed must be in
arithmetic format (host endianness). If the endianness of the socket is different from the host
endianness, the data and address are converted before doing the access. First a DMI access
is done. If this fails, a bus access (b_transport()) is done. If this access fails with an error
response, false  is returned, otherwise true  is returned. The time argument is passed with the
b_transport()  call. If a quantum keeper was set in the socket, it is ignored.
template <typename DT>
bool read(unsigned long long address, DT* data, unsigned int count,
sc_core::sc_time&amp;t)
template <typename DT>
bool write(unsigned long long address, const DT* data, unsigned int count)
Access methods for burst accesses. The passed data pointer should contain an array of words
in arithmetic format (host endianness). If the endianness of the socket is different from the host
endianness, the data and address are converted before doing the access. First a DMI access
is done. If this fails, a bus access (b_transport()) is done. If this access fails with an error
response, false  is returned; otherwise true  is returned. The time argument is passed with the
b_transport()  call. If a quantum keeper was set in the socket, it is ignored.
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
w
r
i
t
e
_
d
e
b
u
g
(
)</p>
<p>m
e
t
h
o
d
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
r
e
a
d
_
d
e
b
u
g
(
)</p>
<p>m
e
t
h
o
d
template <typename DT>
bool read_debug(unsigned long long address, DT&amp; data)
template <typename DT>
bool write_debug(unsigned long long address, const DT&amp; data)
Access methods to do single-word or subword debug accesses. The data passed must be in
arithmetic format (host endianness). If the endianness of the socket is different from the host
endianness, the data and address are converted before doing the access. First a DMI access
is done. If this fails, a bus access (b_transport()) is done. If the debug bus access did not
succeed, false  is returned; otherwise true  is returned.
template <typename DT>
bool read_debug(unsigned long long address, DT* data, unsigned int count)
template <typename DT>
bool write_debug(unsigned long long address, const DT* data, unsigned int count)
Access methods to do burst debug accesses. The passed data pointer should contain an array
of words in arithmetic format (host endianness). If the endianness of the socket is different from
the host endianness, the data and address are converted before doing the access. First a DMI
access is done. If this fails, a bus access (b_transport()) is done. If the debug bus access did
not succeed, false  is returned; otherwise true  is returned.
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
t
r
a
n
s
p
o
r
t
_
d
b
g
(
)</p>
<p>m
e
t
h
o
d
i
n
i
t
i
a
t
o
r
_
s
o
c
k
e
t
b
_
t
r
a
n
s
p
o
r
t
(
)</p>
<p>m
e
t
h
o
d
void b_transport(tlm::tlm_generic_payload&amp; trans, sc_core::sc_time&amp; t)
unsigned int transport_dbg(tlm::tlm_generic_payload&amp; trans)
tlm::tlm_sync_enum nb_transport_fw(tlm::tlm_generic_payload&amp; trans,
tlm::tlm_phase&amp; phase, sc_core::sc_time&amp; t)
bool get_direct_mem_ptr(tlm::tlm_generic_payload&amp; trans, tlm::tlm_dmi&amp; dmiData)
TLM2 access methods. First a DMI access is tried. If this fails, a bus access is done. No
endianness conversions are done; the passed transaction should already be in the correct
format.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
256</p>
</section>
<section id="page-257">
<h2>Page 257<a class="headerlink" href="#page-257" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
The following methods are available to register or unregister a backward path interface to the
initiator_socket. For more information, see the Accellera IEEE 1666 LRM Language Reference
Manual.
void register_bw_direct_mem_if(tlm::tlm_bw_direct_mem_if* bwInterface)
void unregister_bw_direct_mem_if(tlm::tlm_bw_direct_mem_if* bwInterface)
Register or unregister tlm::tlm_bw_direct_mem_if  to the initiator_socket. The
invalidate_direct_mem_ptr  method of all registered interfaces are called in case the
invalidate_direct_mem_ptr  call is done on the backward path of the initiator_sockets.
Multiple interfaces can be registered. In such cases, the call is forwarded to all registered
interfaces.
typedef tlm::tlm_bw_nonblocking_transport_if&lt;tlm::tlm_generic_payload,
tlm::tlm_phase&gt;</p>
<p>BwTransportIf
virtual void register_bw_transport_if(BwTransportIf* bwInterface)
virtual void unregister_bw_transport_if(BwTransportIf* bwInterface)
Register or unregister tlm::tlm_bw_nonblocking_transport_if  to the initiator_socket.
The nb_transport_bw  method of the registered interface is called in case the
nb_transport_bw  call is done on the backward path of the initiator_sockets. Only one
tlm::tlm_bw_nonblocking_transport_if  can be registered to the initiator_socket.
6.1.3. Pin Callback Functions
The following functions are available for registering user callbacks on changes of input pins:
•
The convenience functions for registering user callbacks on pins:
set_change_callback(pin, object, callback);
set_change_callback(pin, object, callback, tag);
set_posedge_callback(pin, object, callback)
set_posedge_callback(pin, object, callback, tag)
set_negedge_callback(pin, object, callback);
set_negedge_callback(pin, object, callback, tag);
where:
pin
Specifies the pin of type sc_in<T>. For set_posedge_callback  and set_negedge_callback, the
pin has to be of type sc_in<bool>.
obj
ect
Is a pointer to the class containing the callback method.
callb
ack
Is a pointer to a member function of the object class. It must have one of the following signatures:
void changeCallback() void changeCallback(int tag)
tag
Is an user-provided integer that is passed to the callback.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
257</p>
</section>
<section id="page-258">
<h2>Page 258<a class="headerlink" href="#page-258" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
Note:
◦
The SCML2_CALLBACK  macro can be used as a convenience macro for registering a member
function as a callback.
◦
The Pin Callback functions can only be registered before end of elaboration, so for example
in the module’s constructor, but not in its end_of_elaboration()  method.
6.1.4. Utility APIs
As part of the SCML2 library, there are some tool interfaces available. The important ones to be taken
into account while creating component models are listed in this section.
•
scml2::register_reset_trigger:
This is an API that is to be used in a component that has a reset output signal. The API allows a
software debugger or a simulation debugger like VP Explorer to trigger the reset behavior of the
component, so that you can develop a debugging and testing script that includes resetting part or all
of the system.
void scml2::register_reset_trigger(const std::string&amp; name,
SCML2_CALLBACK(func), const std::string&amp; description);
Arguments:
name
Is the logical reset domain name for the reset that is generated. This is the name
for the domain as it is used in the debugger. The specific use of this domain name
is specific to each debugger integration. For more information, check the debugger
integration manual. It is allowed to have multiple reset generators with the same
domain name. When a debugger triggers a reset domain, all trigger functions that are
registered with that domain is executed.
func
Is the member function of module that is called by the debugger and which should
implement a reset trigger.
description Is a string to describe the usage of the reset trigger.
Define the function that is triggered as follows:
int  func (const std::string&amp; arg);
◦
The function should return an integer value where 0  means success and all other values indicate
an error. The specific meaning of the return value is left to the designer. The return value is
passed to the debugger so that the right action can be taken.
◦
The string argument is intended to pass arguments from the debugger command into the function
driving the reset, so that the reset generator can be configured for a specific behavior. It is up to
SystemC Modeling Library Reference Manual
X-2025.06-SP1
258</p>
</section>
<section id="page-259">
<h2>Page 259<a class="headerlink" href="#page-259" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
the reset generator to decide what to do with the argument, it is required that the reset generator
has a default behavior so that it can work with an empty argument string.
◦
When a reset domain contains multiple reset generators they all get called with the same
argument string. The return value to the debugger is 0  if all calls were successful, else the return
value is determined by the last failing trigger call.
6.2. Commands
This section describes:
•
scml_command_processor
•
scml_loader
6.2.1. scml_command_processor
s
c
m
l
_
c
o
m
m
a
n
d
_
p
r
o
c
e
s
s
o
r
scml_command_processor  is an SCML object that provides the link between an interactive debugger
and the simulation. It allows the debugger to execute commands in the simulation, for example, to
switch the operating mode of a component or to generate data analysis about the execution and state of
the model. The command processor operates local to a specific component in a model and can manage
multiple commands each with their own set of arguments.
For more information on issuing user commands, see “About Commands” in the VP Explorer
Tcl Interface Reference Manual, and the section “Calling SCML User Commands” of the
VZ_SystemCShell.pdf.
scml_command_processor  can only be used using the following macros:
•
SCML_COMMAND_PROCESSOR
This macro is used to indicate which method should be called when the external debugger sends a
command to the object. The macro takes exactly one argument: the name of the command handler
method. The return type of this method should be std::string  and it should accept one parameter
of type const std::vector<a class="reference external" href="std::string">std::string</a> &amp;, which contains the command and its arguments, if
any.
It is guaranteed that the command handler method is only called for commands that have been
declared using the SCML_ADD_COMMAND  macro and for which the number of arguments lie within the
bounds declared by the SCML_ADD_COMMAND  macro.
The string that is returned by the command handler method is displayed by the debugger.
•
SCML_ADD_COMMAND
SystemC Modeling Library Reference Manual
X-2025.06-SP1
259</p>
</section>
<section id="page-260">
<h2>Page 260<a class="headerlink" href="#page-260" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
This macro is used to declare which commands can be handled by the object. The macro takes the
following parameters:
◦
std::string  name specifies the name of the command.
◦
unsigned int  minParam specifies the minimum number of parameters the command needs.
◦
unsigned int  maxParam specifies the maximum number of parameters the command accepts.
◦
std::string  synopsis is a short description of the command and its arguments.
◦
std::string  description is an elaborate description of the command and its arguments.
Caution:
Long-running SCML commands (execution time &gt; 1 second) can cause issues with
interactive debuggers. Use SCML_COMMAND_YIELD to prevent long delays in other
debugger requests.
•
SCML_COMMAND_YIELD
SCML commands block other debugger requests during their complete execution time. To avoid
unresponsive or even erroneous behavior in debuggers connected to the simulation, long-running
commands must call SCML_COMMAND_YIELD  After a second, to give other debugger requests a
chance to get executed.
SCML_COMMAND_YIELD  macro takes no parameters.
The following commands are available in the ::scsh  namespace to access
scml_command_processor  objects:
Table 57: Commands to Access scml_command_processor Objects
SCSH Command
VP Explorer Command
Description
list_commands
help  or instancehelp
When no arguments are given, the help commands
lists all global command followed by the commands
available only on the current instance context.
help_command  command
help  command  or
instancehelp  command
When the name of a command is given, the help
command provides help on just that command.
execute_commandinstance
command args
command  args  or
instance  command  args
If the current context is to some instance, then you
can call that instance’s commands directly.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
260</p>
</section>
<section id="page-261">
<h2>Page 261<a class="headerlink" href="#page-261" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
The VP Explorer command-line interface supports the notion of a current instance context to simplify
what users need to type. Therefore, the following approaches are shown in the Table 57 for each
command:
•
Where the current context is already set to an instance so the command acts on that instance
directly, and
•
Where the instance’s name is the first part of the command to call that instance’s command without
changing the context.
To set the current instance context, enter the name of an instance. You can enter its full hierarchical
name, and in most cases, a convenient shortcut is provided that you can also enter the instance name
without any hierarchy since that also uniquely identifies the instance. For example:
Tcl&gt; i_MyCore1
i_MyCore1&gt; help
In this example code, entering the instance name changed the current context to that instance and so
the prompt changed. Then, the subsequent help  command shows both the global commands and the
commands on that instance i_MyCore1.
Note:
The command handler method is called from a debugger. When scml_memory  or scml_router
objects are accessed from this handler, the readDebug()/writeDebug()  methods must be used.
Using read()/write()  or put()/get()  from this handler gives undefined behavior.
The following section shows a code example.
SC_MODULE(MyModule) {
SC_CTOR(MyModule) {
// Whenever a debugger sends a command to this object, we want the
// handleCommand method to be invoked.
SCML_COMMAND_PROCESSOR(handleCommand);
// This object understands two commands: ‘status’ and ‘load’.
SCML_ADD_COMMAND(“status”, 0, 0, “Reports that the status of this device”,
“This command will report the status of the A, B and C “
“registers”);
SCML_ADD_COMMAND(“load”, 1, 2, “load <filename> [format]”,
“This command loads the given file onto this device.”
“If no format is supplied, the ELF format is assumed.”
“Other supported formats are ‘raw’ and ‘coff’.”);
}</p>
<p>std::string handleCommand(const std::vector<a class="reference external" href="std::string">std::string</a>&amp; cmd)
{
if (cmd[0] == “status”) {
return getStatus();
} else if (cmd[0] == “load”) {
std::string filename = cmd[1];
std::string format = “ELF”;
if (cmd.size() == 2) format = cmd[2];
SystemC Modeling Library Reference Manual
X-2025.06-SP1
261</p>
</section>
<section id="page-262">
<h2>Page 262<a class="headerlink" href="#page-262" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
if (load(filename, format)) {
return “OK”;
} else {
return “Could not load ” + filename;
}
} else {
// This should never happen!
assert(false);
return “ERROR: unknown command ” + cmd[0];
}
}</p>
<p>std::string getStatus() const
{
…
}</p>
<p>bool load(std::string filename, std::string format)<br />
{
…
}
};
6.2.2. scml_loader
s
c
m
l
_
l
o
a
d
e
r
The scml_loader  class is an abstract base class that can be used to add image loading capabilities to
your sc_module. It only has one pure virtual method, loadImage, which has the following signature:
bool loadImage(const std::string&amp; fileName, long long offset,
const std::string&amp; type)
where:
fil
eN
ame
Specifies the relative or absolute path to the image that should be loaded.
off
set
Specifies the offset that should be added to all addresses in the image to obtain the absolute addresses at
which the image should be loaded. If your module does not support relative loading, your implementation
should check that offset  is 0  and if not, return false.
t
ype
Specifies the file format that is used by the image. If this is an empty string and your module supports
multiple file formats, your implementation should try to find out the file format by itself. If your module does
not support multiple formats, your implementation should verify that type  is an empty string and if not, return
false.
Where applicable, the “raw” type should also be supported for loading plain binary files. The possible values
of the type  parameter may be freely chosen.
Your implementation should return true  if the image was loaded successfully and false  otherwise.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
262</p>
</section>
<section id="page-263">
<h2>Page 263<a class="headerlink" href="#page-263" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
loadImage()  can be invoked in several ways:
•
By loading the image through the VP Explorer. For more information, see “Loading Software Images
to the Simulation” of the VP Explorer User Guide.
•
By means of the –cwr_load  or the –cwr_imagemap  command-line arguments. The following
section describes these arguments.
Instantiating an scml_loader  object in a simulation automatically adds the following command-line
arguments:
Note:
The -cwr_load  and -cwr_imagemap  command-line arguments only work on targets that have
this loading facility explicitly enabled.
•
–cwr_imagemapimageMappingFilecan be used to invoke the loadImage()  method of an
scml_loader  object. The imageMappingFile  should contain lines of the form moduleName
imageFile offset, separated by newlines, where:
moduleName
Is the hierarchical name of the sc_module  that instantiates the scml_loader  object.
imageFile
Is the relative or absolute path name to the file you want to load.
offset
Is the offset at which you want the image to be loaded.
•
–cwr_load moduleName,imageFile[,offset]  can be used to invoke the loadImage()  method of
an scml_loader  object, where:
moduleName
Is the hierarchical name of the sc_module  that instantiates the scml_loader  object.
imageFile
Is the relative or absolute path name to the file you want to load.
offset
Is the offset at which you want the image to be loaded. Specifying the offset is
optional. If no offset is specified, offset 0  is assumed.
6.3. Parameters
This section describes:
•
scml_property
•
scml_property_registry
•
scml_property_server_if
•
scml_simple_property_server
SystemC Modeling Library Reference Manual
X-2025.06-SP1
263</p>
</section>
<section id="page-264">
<h2>Page 264<a class="headerlink" href="#page-264" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
6.3.1. scml_property
scml_property  is an SCML object used for model configuration, it can hold a value of type int, bool,
double  or string. The value of a scml_property  is loaded during elaboration and is intended to
provide the link between platform authoring tools and the simulation. It provides an easy to use and
very flexible configuration mechanism for models. Typically, configuration parameters are stored in an
VP Config which is generated by the authoring tool (Platform Creator) and is loaded by VP Explorer at
the start of the simulation. Without recompiling or editing the model, it is then possible to change the
configuration of the simulation simply by editing or modifying the XML file.
The scml_property  classes can be used inside SystemC modules and automatically reads their value
from the XML file exported by Platform Creator.
The following scml_property  classes are available:
scml_property<int>
scml_property<unsigned int>
scml_property<double>
scml_property<bool>
scml_property<a class="reference external" href="std::string">std::string</a>
scml_property<long long>
scml_property<unsigned long long>
The scml_property  class is templated with the underlying value type. The following type definitions are
available to support generic programming:
typedef T value_type;
typedef scml_property_base&lt;value_type&gt; this_type;
typedef this_type* this_pointer_type;
typedef this_type&amp; this_reference_type;
The following constructors are available:
scml_property(const::std::string&amp; name);
scml_property(const::std::string&amp; name, T defaultValue);
where:
name
Specifies the name of the property. The name of the property is used together with the
hierarchical SystemC name of the module to access the value of the property in the XML
file.
defaultValue
Specifies the default of the property. This default is only used if the property is not found
in the XML file.
The following assignment operators are available:
this_reference_type operator=(const scml_property<T>&amp;);
this_reference_type operator=(value_type);
SystemC Modeling Library Reference Manual
X-2025.06-SP1
264</p>
</section>
<section id="page-265">
<h2>Page 265<a class="headerlink" href="#page-265" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
The following arithmetic assignment operators are available and behave as defined for the underlying
value type:
this_reference_type operator += (value_type);
this_reference_type operator -= (value_type);
this_reference_type operator /= (value_type);
this_reference_type operator *= (value_type);
this_reference_type operator %= (value_type);
this_reference_type operator ^= (value_type);
this_reference_type operator &amp;= (value_type);
this_reference_type operator |= (value_type);
this_reference_type operator &lt;&lt;= (value_type);
this_reference_type operator &gt;&gt;= (value_type);
A property object can be converted to the underlying value type:
g
e
t
N
a
m
e
(
)</p>
<p>f
u
n
c
t
i
o
n
operator T() const;</p>
<p>std::string getName() const;
Returns the name of the scml_property.
g
e
t
T
y
p
e
(
)</p>
<p>f
u
n
c
t
i
o
n
std::string getType() const;
Returns the type of the scml_property. The type can be one of the following strings: int,
unsigned int, bool, double, string, unsigned long long, long long.
class mymodule: public sc_module
{
public:
mymodule(sc_module_name name)
: sc_module(name),
intProp(“intProp”),
boolProp(“boolProp”),
doubleProp(“doubleProp”),
stringProp(“stringProp”)
{
SC_THREAD(my_thread);
}
scml_property<int> intProp;
scml_property<bool> boolProp;
scml_property<double> doubleProp;
scml_property<string> stringProp;</p>
<p>void my_thread () {
cout &lt;&lt; “mymodule: Int: ” &lt;&lt; intProp
&lt;&lt; ” Bool: ” &lt;&lt; boolProp
&lt;&lt; ” double: ” &lt;&lt; doubleProp
&lt;&lt; ” and string: ” &lt;&lt; stringProp
&lt;&lt; endl;
}
};
SystemC Modeling Library Reference Manual
X-2025.06-SP1
265</p>
</section>
<section id="page-266">
<h2>Page 266<a class="headerlink" href="#page-266" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
This module has a property of each of the possible types. Each of the properties is part of the
initialization list of the constructor. The properties automatically get their value upon construction of the
module. They can be used as their value types anywhere in the module.
Platform Creator exports the XML file containing all the properties of all the modules in the system. For
Platform Creator to know that a certain module has properties, these properties need to be added to the
respective module. Platform Creator can recognize the SCML properties automatically, or you can add
them manually.
6.3.2. scml_property_registry
The scml_property classes can only be used inside SystemC modules. Using scml_property  objects
does not require any knowledge of the scml_property_registry. Objects of type scml_property  get
their values automatically.
Two mechanisms are available to load values in properties:
•
An XML file exported by Platform Creator
•
A custom property server
The XML file exported by Platform Creator contains all the parameters of the system. Besides MODULE
parameters (which are the scml_property  objects of a module), Platform Creator also exports
CONSTRUCTOR, PORT, and PROTOCOL  parameters.
scml_property_registry  offers an API to read the values of these parameters.
The following enumeration type is available:
enum PropertyType {
GLOBAL,
CONSTRUCTOR,
MODULE,
PORT,
PROTOCOL
};
This enumeration type indicates the kind of parameter you want to access:
•
GLOBAL  is reserved for internal usage.
•
CONSTRUCTOR  indicates a constructor argument of a module.
•
MODULE  indicates a module parameter.
•
PORT  indicates a port parameter.
•
PROTOCOL  indicates a protocol parameter.
The scml_property_registry  class is a singleton class. A reference to the instance of the class can
be obtained by calling the static inst()  function:
static scml_property_registry&amp; inst();
SystemC Modeling Library Reference Manual
X-2025.06-SP1
266</p>
</section>
<section id="page-267">
<h2>Page 267<a class="headerlink" href="#page-267" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
The following functions are available for getting the values of a certain parameter:
g
e
t
D
o
u
b
l
e
P
r
o
p
e
r
t
y
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
p
r
o
p
e
r
t
y
_
r
e
g
i
s
t
r
y
g
e
t
S
t
r
i
n
g
P
r
o
p
e
r
t
y
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
p
r
o
p
e
r
t
y
_
r
e
g
i
s
t
r
y
g
e
t
B
o
o
l
P
r
o
p
e
r
t
y
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
p
r
o
p
e
r
t
y
_
r
e
g
i
s
t
r
y
g
e
t
I
n
t
P
r
o
p
e
r
t
y
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
p
r
o
p
e
r
t
y
_
r
e
g
i
s
t
r
y
int getIntProperty(PropertyType type, const std::string&amp; scHierName,
const std::string&amp; name);
bool getBoolProperty(PropertyType type, const std::string&amp; scHierName,
const std::string&amp; name);
std::string getStringProperty(PropertyType type,
const std::string&amp; scHierName,
const std::string&amp; name);
double getDoubleProperty(PropertyType type, const std::string&amp; scHierName,
const std::string&amp; name);
These functions all take the same parameters:
•
PropertyType type  specifies the type of property you want to access.
•
const std::string&amp; scHierName  specifies the hierarchical SystemC name of the sc_object  that
contains the parameter. In case of a PORT  or PROTOCOL  property, this is the hierarchical SystemC
name of the port. In case of a MODULE  or CONSTRUCTOR  parameter, this is the hierarchical name of the
module.
•
const std::string&amp; name  specifies the name of the property whose value you want to get.
s
e
t
C
u
s
t
o
m
P
r
o
p
e
r
t
y
S
e
r
v
e
r
(
)</p>
<p>f
u
n
c
t
i
o
n
bool setCustomPropertyServer(scml_property_server_if *);
Sets the custom property server.
Note:
This function must be called before any property that depends on it (to get its value) is constructed.
For more information about the scml_property_server_if  class, see scml_property_server_if.
std::vector<a class="reference external" href="std::string">std::string</a> getPropertyNames( const std::string&amp; scHierName);
Queries the list of names of the available parameters.
scml_property_registry::PropertyType getPropertyType( const std::string&amp; scHierName,
const std::string&amp; propName);
Queries the type of property.
class myport: public sc_port&lt;my_interface&gt;
{
public:
myport(const string&amp; name)
: sc_port&lt;my_interface&gt;(name.c_str())
{
// In a port, we can get our parameters by using the propertyAPI
intParam = scml_property_registry::inst().getIntProperty
(scml_property_registry::PROTOCOL, sc_object::name(), “intParam”);
}</p>
<p>SystemC Modeling Library Reference Manual
X-2025.06-SP1
267</p>
</section>
<section id="page-268">
<h2>Page 268<a class="headerlink" href="#page-268" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
unsigned int intParam;
};
6.3.3. scml_property_server_if
This class defines the interface a property server should implement.
g
e
t
D
o
u
b
l
e
P
r
o
p
e
r
t
y
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
p
r
o
p
e
r
t
y
_
s
e
r
v
e
r
_
i
f
g
e
t
S
t
r
i
n
g
P
r
o
p
e
r
t
y
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
p
r
o
p
e
r
t
y
_
s
e
r
v
e
r
_
i
f
g
e
t
B
o
o
l
P
r
o
p
e
r
t
y
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
p
r
o
p
e
r
t
y
_
s
e
r
v
e
r
_
i
f
g
e
t
U
I
n
t
P
r
o
p
e
r
t
y
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
p
r
o
p
e
r
t
y
_
s
e
r
v
e
r
_
i
f
g
e
t
I
n
t
P
r
o
p
e
r
t
y
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
p
r
o
p
e
r
t
y
_
s
e
r
v
e
r
_
i
f
virtual long long getIntProperty(const std::string &amp; name);
virtual unsigned long long getUIntProperty(const std::string &amp; name);
virtual bool getBoolProperty(const std::string &amp; name);
virtual std::string getStringProperty(const std::string &amp; name);
virtual double getDoubleProperty(const std::string &amp; name);
A property server should override these interface functions. It needs to provide the value of the
property whose name is provided as the argument.
Default implementations are available. They return 0, false, or the empty string depending on
the type.
This example shows how to implement a custom property server, based on STL maps.
class exampleCustomPropertyServer: public scml_property_server_if {
public:
exampleCustomPropertyServer() { this-&gt;load(); }
virtual ~exampleCustomPropertyServer() {}</p>
<p>public:
// scml_property_server_if
virtual long long getIntProperty(const std::string &amp; name);
virtual unsigned long long getUIntProperty(const std::string &amp; name);
virtual bool getBoolProperty(const std::string &amp; name);
virtual std::string getStringProperty(const std::string &amp; name);
virtual double getDoubleProperty(const std::string &amp; name);</p>
<p>private:
// disable
exampleCustomPropertyServer &amp; operator= (const exampleCustomPropertyServer &amp;);
exampleCustomPropertyServer(const exampleCustomPropertyServer &amp;);</p>
<p>private:
void load();</p>
<p>private:
// data members
map&lt;string, long long&gt; mName2longLong;
map&lt;string, unsigned long long&gt; mName2unsignedLongLong;
map&lt;string, bool&gt; mName2bool;
map&lt;string, string&gt; mName2string;
map&lt;string, double&gt; mName2double;
};</p>
<p>void
exampleCustomPropertyServer::load()
{
SystemC Modeling Library Reference Manual
X-2025.06-SP1
268</p>
</section>
<section id="page-269">
<h2>Page 269<a class="headerlink" href="#page-269" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
mName2string[ “HARDWARE.module1.myString” ] = “the string”;
mName2string[ “HARDWARE.module2.sub.myString” ] = “the string”;</p>
<p>mName2double[ “HARDWARE.module1.myDouble” ] = 1.234;
mName2double[ “HARDWARE.module2.sub.myDouble” ] = 1.234;</p>
<p>mName2bool[ “HARDWARE.module1.myBool” ] = true;
mName2bool[ “HARDWARE.module2.sub.myBool” ] = true;</p>
<p>mName2longLong[ “HARDWARE.module1.myInt” ] = 30;
mName2longLong[ “HARDWARE.module2.sub.myInt” ] = -33;
}</p>
<p>long long
exampleCustomPropertyServer::getIntProperty(const std::string &amp; name)
{
const long long r = mName2longLong[ name];
return r;
}</p>
<p>unsigned long long
exampleCustomPropertyServer::getUIntProperty(const std::string &amp; name)
{
const unsigned long long r = mName2unsignedLongLong[ name ];
return r;
}</p>
<p>bool
exampleCustomPropertyServer::getBoolProperty(const std::string &amp; name)
{
const bool r = mName2bool[ name ];
return r;
}</p>
<p>std::string
exampleCustomPropertyServer::getStringProperty(const std::string &amp; name)
{
const string r = mName2string[ name ];
return r;
}</p>
<p>double
exampleCustomPropertyServer::getDoubleProperty(const std::string &amp; name)
{
const double r = mName2double[ name ];
return r;
}
6.3.4. scml_simple_property_server
This class defines an example property server that implements the scml_property_server_if interface.
l
o
a
d
(
)</p>
<p>f
u
n
c
t
i
o
n
bool load(const std::string&amp; fileName);
SystemC Modeling Library Reference Manual
X-2025.06-SP1
269</p>
</section>
<section id="page-270">
<h2>Page 270<a class="headerlink" href="#page-270" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
Loads the properties from the file. Returns true  if the load succeeds, false  if an error
occurred.
g
e
t
D
o
u
b
l
e
P
r
o
p
e
r
t
y
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
s
i
m
p
l
e
_
p
r
o
p
e
r
t
y
_
s
e
r
v
e
r
g
e
t
S
t
r
i
n
g
P
r
o
p
e
r
t
y
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
s
i
m
p
l
e
_
p
r
o
p
e
r
t
y
_
s
e
r
v
e
r
g
e
t
B
o
o
l
P
r
o
p
e
r
t
y
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
s
i
m
p
l
e
_
p
r
o
p
e
r
t
y
_
s
e
r
v
e
r
g
e
t
U
I
n
t
P
r
o
p
e
r
t
y
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
s
i
m
p
l
e
_
p
r
o
p
e
r
t
y
_
s
e
r
v
e
r
g
e
t
I
n
t
P
r
o
p
e
r
t
y
(
)</p>
<p>f
u
n
c
t
i
o
n
s
c
m
l
_
s
i
m
p
l
e
_
p
r
o
p
e
r
t
y
_
s
e
r
v
e
r
virtual long long getIntProperty(const std::string&amp; name);
virtual unsigned long long getUIntProperty(const std::string&amp; name);
virtual bool getBoolProperty(const std::string&amp; name);
virtual std::string getStringProperty(const std::string&amp; name);
virtual double getDoubleProperty(const std::string&amp; name);
Returns the value of the property. If the property is not found, a warning message is printed and
a default is returned.
The property files have the following syntax:
file::= {line}*
line::= typeLine | valueLine | commentLine
typeline::= ‘[int]’ | ‘[uint]’ | ‘[bool]’ | ‘[string]’ | ‘[double]’
valueLine::=name’:’value
commentLine::= ‘#’ string
where:
name
Specifies the hierarchical name of the property.
value
Specifies the value for the property.
Properties that appear before the first typeLine  in the file are treated as int  properties.
The following code shows an example of a property file.
intproperty: -1
[uint]
property1 : 0
property2 : 1234
[string]
property3 : This is a string property
6.4. Reporting
DEPRECATED:
The scml2_logging  stream output has been deprecated in Product Version M-2016.12 and
redirected to the FastTrack infrastructure. However, you can temporarily enable the old behavior by
using the environment variable SNPS_VP_SLS_ENABLE_SCML2_STREAM_LOGGERS.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
270</p>
</section>
<section id="page-271">
<h2>Page 271<a class="headerlink" href="#page-271" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
This section describes:
•
status
•
stream
•
severity
6.4.1. status
scml2::status  is a simple object that maintains a string value and is used mostly to enable debugging
and analysis features. The value of the object can be visualized in tracing views or be used for
watchpoints and so on.
s
t
a
t
u
s
The status  object is a very simple object that holds a status value in string format. It can be used as
the base of other higher level modeling objects or it can be used to enable debugging and analysis for a
module.
The include file of the status object is scml2/status.h.
The following sections describe:
•
Constructors are available for the status  object.
•
Properties of the status  object.
The following constructors are available for the status  object.
explicit status(const std::string&amp; name)
Creates a new status object with the specified name.
The following are the properties of the status  object.
std::string get_name() const
Returns the name of the status  object.
void set_status(const std::string&amp; status)
Sets the new value of the status  object.
const std::string&amp; get_status() const
Returns the current value of the status  object.
const std::string&amp; get_description() const
Returns the description for the status  object.
void set_description(const std::string&amp;)
Sets the description for the status  object.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
271</p>
</section>
<section id="page-272">
<h2>Page 272<a class="headerlink" href="#page-272" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
6.4.2. stream
scml2::stream  is a convenience object for logging. It allows a stream like formatting syntax to be used
to log messages from models. The stream object will send the messages to backend logger objects for
processing (for example, sending it to std::cout). The stream has a name and associated severity
which allows to control the messages that are being logged, for example, to restrict them to a certain
hierarchy in the design and or a severity level. There are predefined severity levels for error, warning,
debug, note, and so on.
The include file for this object is scml2/stream.h.
The following sections describe:
•
Constructor available for the stream  object.
•
Properties of the stream  object.
The following constructor is available for the stream  object.
stream(const std::string&amp; name, const severity&amp; severity)
Creates a new stream with the specified name and severity level. For information on severity,
see severity.
stream(const severity&amp; severity)
Creates a new stream with the specified severity level. For information on severity, see severity.
The name of the stream is the name of the current sc_module.
The following are the properties of the stream  object.
std::string get_name() const
Returns the name of the stream  object.
const severity&amp; get_severity() const
Returns the severity  object of the stream  object.
bool is_enabled() const
Returns true  if the stream  object is enabled, or returns false  otherwise. The stream  object is
enabled in case at least one back-end object requests output from this stream.
All methods that are defined on std::ostream  are also defined on the scml2::stream  object. A
stream  object can be used as a replacement of an std::ostream  object like std::cerr  or std::cout.
The scml2::stream  object sends the output to the back-end logger objects only when the stream is
flushed. This is done when std::endl  or std::flush  is written to the stream.
Note:
SCML2_LOG  can be used as a convenience macro while checking if a stream  object is enabled.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
272</p>
</section>
<section id="page-273">
<h2>Page 273<a class="headerlink" href="#page-273" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
For example:
SCML2_LOG(myStream) &lt;&lt; “Debug output for myStream” &lt;&lt; std::endl;
In case the stream is disabled, the macro evaluates to one Boolean check. There is no performance
impact caused by example, the operator &lt;&lt;  or the implicit conversion operators in the debug output.
For performance reasons, the SCML2_LOG  macro should always be used, or the is_enabled  flag
should be checked before sending output to the stream.
Similarly, the SCML2_LOG_ASSERT  macro conditionally writes to a stream if its argument evaluates to
false.
For example:
SCML2_LOG_ASSERT(value == 0x1234, mStream) &lt;&lt; “Value cannot be 0x1234” &lt;&lt;
std::endl;
6.4.3. severity
The severity  object holds a severity name and value. Each stream  object has an associated
severity  object. For information on the stream  object, see stream.
Lower severity level values mean a higher severity.
The include file for this object is scml2/severity.h.
The following sections describe:
•
Constructor is available for the severity  object.
•
Available properties of the severity  object.
•
Predefined severity levels.
The following constructor is available for the severity  object.
severity(const std::string&amp; name, unsigned int level)
Creates a new severity  object with the specified name and severity level value.
The following are the available properties of the severity  object.
const std::string&amp; get_name() const
Returns the name of the severity  object.
unsigned int get_level() const
Returns the severity level value of the severity  object.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
273</p>
</section>
<section id="page-274">
<h2>Page 274<a class="headerlink" href="#page-274" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
The following severity levels are predefined by the logging library:
•
internal_error (5)
•
error (10)
•
warning (100)
•
note (1000)
•
debug (10000)
The severity  object has the following static methods to create the predefined severity  objects:
static severity internal_error()
static severity error()
static severity warning()
static severity note()
static severity debug()
6.5. FastTrack
FastTrack allows the modeler to trigger messages from within peripheral models. The following distinct
severities are defined:
•
Error
•
Warning
•
Info
Each severity has distinct categories. For a complete listing of the categories, see FastTrack
Categories. For information on how to use the FastTrack messages from an end-user perspective, see
the section “FastTrack Messages” of the VP Explorer User Guide.
The SCML2 modeling library provides macros to communicate a message to the FastTrack
infrastructure, which then presents the information to the end user.
From the modeler perspective, the information that needs to be passed is limited to the severity, the
category, and a user-defined message.
Without user intervention, the FastTrack implementation attempts to collect and present the following
additional information (tags) which can be presented to the end user:</p>
<ol class="arabic simple">
<li><p>The simulation time at which the message was triggered.</p></li>
<li><p>The instance name of the object from which the message originated.</p></li>
<li><p>The instance name of the processor core that triggered the memory access during which the
message was triggered.</p></li>
<li><p>The program counter of the fore mentioned processor.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
274</p></li>
</ol>
</section>
<section id="page-275">
<h2>Page 275<a class="headerlink" href="#page-275" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
5. If debug information is available for the software that is running on the processor:
a. The function name
b. The file and line number of the embedded software source code associated with the program
counter
6. If an OS kit is active:
a. The name of the Software Context of the processor at the moment the memory access was
executed.
The information presented to the end user can assist both in flagging embedded software errors
or modeling problems that are detected in peripheral models, and in debugging the problem that is
identified.
The modeler is strongly encouraged to flag FastTrack errors or warnings from model code in those
cases where the model would be able to detect fault conditions or potentially wrong programming
actions.
Adding FastTrack logging messages to the models can aid both the modeler and the embedded
software engineer in debugging embedded software or model problems when functional issues are
identified during simulation.
Note:
Besides the messages that are explicitly inserted in model code by the modeler, SCML2 modeling
objects trigger FastTrack messages when certain events occur (&gt;implicit messages). For a complete
list of events that are logged by SCML2 modeling objects, see Implicit FastTrack Messages.
The subsequent section outlines the API available to the modeler. For a detailed description on how the
collected information can be presented to and processed by the end user, see VP Explorer User Guide
and VZ_VirtualizerStudio.pdfVirtualizer Studio User Guide.
This section describes:
•
FastTrack API
•
FastTrack Categories
•
Implicit FastTrack Messages
•
Suppressing FastTrack Messages
6.5.1. FastTrack API
The FastTrack feature is exposed to the modeler using the SCML2 convenience macros, which are
defined in the header:
scml2/tagged_message_macros.h
SystemC Modeling Library Reference Manual
X-2025.06-SP1
275</p>
</section>
<section id="page-276">
<h2>Page 276<a class="headerlink" href="#page-276" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
Convenience macros for use in sc_modules  (where the implicit ‘this’ pointer refers to an sc_module) are
as follows:
•
SCML2_INFO  (info  category)
•
SCML2_WARNING  (warning  category)
•
SCML2_ERROR  (error  category)
•
SCML2_MODEL_INTERNAL  (model internal  category)
Convenience macros for use outside of sc_modules  are as follows:
•
SCML2_INFO_TO  (module, info  category)
•
SCML2_WARNING_TO  (module, warning  category)
•
SCML2_ERROR_TO  (module, error  category)
•
SCML2_MODEL_INTERNAL_TO  (model internal  category)
where ‘module’ is a pointer to an sc_module. The FastTrack infrastructure identifies the message that is
sent as originating from the given sc_module.
For a full description of info/warning/error  categories, see FastTrack Categories.
The macros presented above can be treated as stream objects, making the addition of FastTrack
messages to the existing or new models very easy and low effort.
For example:
SCML2_INFO(FUNCTIONAL_LOG)
&lt;&lt; “Initiating DMA transfer on channel “
&lt;&lt; mChannelID” &lt;&lt; std::endl;
where the category FUNCTIONAL_LOG  indicates to the end user that this message conveys information
about the high-level behavior of the model.
An additional convenience macro SCML2_ASSERT  checks a given condition, and in case the condition
evaluates to false:
•
A FastTrack error of category FATAL_ERROR  is raised.
•
The simulation is stopped.
Note:
As the simulation is stopped using sc_core::sc_stop, the simulation execution is not immediately
halt, but still continue until the next simulation sync point. Any code following the FATAL_ERROR
needs to support this.
This allows the modeler to check, report and exit on conditions which might lead to unstable or
catastrophic behavior in the model.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
276</p>
</section>
<section id="page-277">
<h2>Page 277<a class="headerlink" href="#page-277" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
For example,
SCML2_ASSERT(all_is_fine == true) &lt;&lt; “Something very bad has happened” &lt;&lt; std::endl;
Note:
•
The message content should be limited to a single line, and needs to be terminated with a
std::endl  character.
•
Only one line should be sent to the stream  object represented by the macro. For example, one
should not write:
SCML2_INFO(FUNCTIONAL_LOG)
&lt;&lt; “Message 1” &lt;&lt; std::endl
&lt;&lt; “Message 2” &lt;&lt; std::endl;
•
There is no need to include a timestamp or object name to the message, these are added
automatically.
6.5.2. FastTrack Categories
Based on the severity, the available FastTrack categories are Error, Warning, Info, Model Internal.
Each category has an enum  value for use in the API while modeling, and a name which are shown to the
user when the message occurs.
The following categories are available for use with the Error  severity:
Table 58: Error Categories
Category Enum
Category Name
Description
GENERIC_ERROR
Generic Error
Generic error raised by the model.
Used as fall-back category for
messages that are triggered by
legacy SCML Stream or VRE
logging infrastructure that is
redirected to FastTrack.
SCML_INVALID_API_USAGE
SCML Invalid API Usage
Internal use by SCML2 modeling
objects only. Points out wrong use
of the SCML2 API.
ACCESS_WRITE_RESERVED_VALUE
Access Write Reserved
Value
A register or bitfield is written with
a reserved value.
ACCESS_WRITE_UNDEFINED_VALUE
Access Write Undefined
Value
A register or bitfield is written with
an undefined value.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
277</p>
</section>
<section id="page-278">
<h2>Page 278<a class="headerlink" href="#page-278" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
Table 58: Error Categories (Continued)
Category Enum
Category Name
Description
CONFIGURATION_ERROR
Configuration Error
A parameter or combination
of parameters on a peripheral
model is set to an invalid value or
combination of values.
ACCESS_PERMISSION_CHECK_FAIL
Access Permission Check
Fail
A memory access to a
register/bitfield or memory is not
allowed. For example, due to
insufficient privileges or due to
the current configuration of the
peripheral.
ACCESS_WRITE_TO_READ_ONLY
Access Write To Read-Only
An attempt to write a read-only
memory location is done.
ACCESS_READ_FROM_WRITE_ONLY
Access Read From Write
Only
An attempt to read from a
write-only memory location is
done.
ACCESS_UNMAPPED_ADDRESS
Access Unmapped Address
An attempt to access from an
unallocated memory location is
done.
FUNCTIONAL_ERROR
Functional Error
A peripheral model can use this
to flag unexpected behavior in the
model.
FILE_NOT_FOUND
File Not Found
A file is not found.
FILE_FORMAT_ERROR
File Format Error
A file has the wrong format or
cannot be parsed.
STATE_ILLEGAL_TRANSITION
State Illegal Transition
A peripheral model can use this to
flag an illegal state transition in a
state machine.
STATE_ILLEGAL
State Illegal
A peripheral model can use this to
flag reaching an illegal state in a
state machine.
BUFFER_UNDERFLOW
Buffer Underflow
A peripheral model can use this
to flag a buffer underflow, that is,
an attempt to read from a buffer
which no longer has sufficient
active elements.
BUFFER_OVERFLOW
Buffer Overflow
A peripheral model can use this to
flag a buffer overflow, that is, an
attempt to write to a buffer that is
already full.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
278</p>
</section>
<section id="page-279">
<h2>Page 279<a class="headerlink" href="#page-279" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
Table 58: Error Categories (Continued)
Category Enum
Category Name
Description
UNDEFINED_ERROR
Undefined Error
An error which does not fit any of
the other predefined categories.
PROGRAMMING_ERROR
Programming Error
A peripheral model can use this to
flag a generic programming error,
that is, it is being accessed by
software in a way that violates the
specification.
FATAL_ERROR
Fatal Error
Flags a fatal error condition, and
terminates the simulation in a
clean way.
The following categories are available for use with the Warning  severity:
Table 59: Warning Categories
Category Enum
Category Name
Description
GENERIC_WARNING
Generic Warning
General warning raised by the model.
Used as fall-back category for messages
that are triggered by legacy SCML
Stream or VRE logging infrastructure that
is redirected to FastTrack.
SCML_IGNORED_CALL
SCML Ignored Call
Internal use by SCML2 modeling objects
only. Points out an API call without any
further effect (for example, making the
same call twice, or canceling an event
which was not scheduled or already
canceled).
FEATURE_NOT_MODELED
Feature Not Modeled
A peripheral model can use this to
indicate that a given feature that is being
exercised is not modeled and not planned
to be modeled due to for example, the
abstraction level.
FEATURE_TBD
Feature TBD
A peripheral model can use this to
indicate that a given feature that is being
exercised is not modeled yet.
FILE_SW_IMAGE_OVERWRITE
File SW Image
Overwrite
During image loading, a previously
written location gets overwritten.
ACCESS_IGNORED
Access Ignored
An access to a memory location is
ignored or has no effect.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
279</p>
</section>
<section id="page-280">
<h2>Page 280<a class="headerlink" href="#page-280" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
Table 59: Warning Categories (Continued)
Category Enum
Category Name
Description
ACCESS_INVALID_PERMISSION
Access Invalid
Permission
A warning raised when an access to
a memory object is allowed, but is for
example, ignored due to mismatching
access permission settings.
UNDEFINED_WARNING
Undefined Warning
A warning which does not fit any of the
other predefined categories.
CONFIGURATION_WARNING
Configuration Warning
Used to flag setting of parameters in a
way that is not advised.
PROGRAMMING_WARNING
Programming Warning
A peripheral model can use this to flag a
generic programming warning, that is, it is
being accessed by software in a way that
does not meet recommendations outlined
in the specification.
The following categories are available for use with the Info  severity:
Table 60: Info Categories
Category Enum
Category Name
Description
GENERIC_INFO
Generic Info
Generic information raised by the model. Used
as fall-back category for messages that are
triggered by legacy SCML Stream or VRE logging
infrastructure that is redirected to FastTrack.
FILE_OPEN
File Open
Logs opening of a file.
FILE_CLOSE
File Close
Logs closing of a file.
FUNCTIONAL_LOG
Functional Log
Logs high-level functional behavior of a peripheral
model, as an aid during debugging. The level
should be such that it makes sense to a software
developer.
FUNCTIONAL_LOG_VERBOSE
Functional Log
Verbose
Logs detailed functional behavior of a peripheral
model, as an aid during debugging. The level
should be such that it makes sense to a software
developer.
FUNCTIONAL_LOG_INTERNAL Functional Log
Internal
Logs internal behavior of a peripheral model,
as an aid during (mainly) model debugging.
This level of logging can expose implementation
details of the peripheral model.
STATE_TRANSITION
State Transition
Logs a state transition of a state machine.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
280</p>
</section>
<section id="page-281">
<h2>Page 281<a class="headerlink" href="#page-281" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
Table 60: Info Categories (Continued)
Category Enum
Category Name
Description
CONFIGURATION_INFO
Configuration Info
Logs parameter values/changes in configuration
using for example, Tcl calls.
SOFTWARE_LOG
Software Log
Used for messages that are emitted directly by
software running on a simulated processor, for
example, using SemiHosting.
The following categories are available for use with the Model Internal  severity.
Table 61: Model Internal Categories
Category Enum
Category Name
Description
SCML_CALLBACK_EN
TRY
SCML Callback
Entry
Internal use by SCML2 modeling objects only. Logs
calling of a registered callback by an SCML modeling
object.
SCML_CALLBACK_EXIT
SCML Callback Exit Internal use by SCML2 modeling objects only. Logs
returning from a registered callback by an SCML
modeling object.
LEGACY_LOGGING
Legacy Logging
Logs emitted by legacy logging infrastructure like
SCML stream.
LEVEL0
Internal Level 0
Lowest level log (least detailed) emitted by model code
to aid model debugging.
LEVEL1
Internal Level 1
Emitted by model code to aid model debugging.
LEVEL2
Internal Level 2
Emitted by model code to aid model debugging.
LEVEL3
Internal Level 3
Emitted by model code to aid model debugging.
LEVEL4
Internal Level 4
Emitted by model code to aid model debugging.
LEVEL5
Internal Level 5
Emitted by model code to aid model debugging.
LEVEL6
Internal Level 6
Highest level (most detailed) log emitted by model code
to aid model debugging.
6.5.3. Implicit FastTrack Messages
Implicit FastTrack messages are messages that are being emitted by SCML2 modeling objects. The
subsequent sections outline which messages are being emitted, so the modeler is aware and does not
add similar explicit messages in model code.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
281</p>
</section>
<section id="page-282">
<h2>Page 282<a class="headerlink" href="#page-282" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
Note:
Messages that are emitted because of wrong API usage or configuration of SCML2 objects are not
listed here.
The following table lists the implicit FastTrack Error  messages.
Table 62: Implicit FastTrack Error Messages
Event
Category
Message
Calling SCML2_ASSERT(true)
FATAL_ERROR
Message passed to SCML2_ASSERT
The following table lists the implicit FastTrack Warning  messages.
Table 63: Implicit FastTrack Warning Messages
Event
Category
Message
memory_disallow_access_callback with
disallow
ACCESS_INVALID_PERMISSION
[read|write] access
denied at address
[address] on [object]
memory_disallow_access_callback ignored
access
ACCESS_IGNORED
[read|write] access
ignored at address
[address] on [object]
bitfield_disallow_read_access_callback
ignored access
ACCESS_IGNORED
Read access ignored on
[object]
bitfield_disallow_write_access_callback
ignored access
ACCESS_IGNORED
Write access ignored on
[object]
bitfield_disallow_read_access_callback
with disallow
ACCESS_INVALID_PERMISSION
Read access denied on
[object]
bitfield_disallow_write_access_callback
with disallow
ACCESS_INVALID_PERMISSION
Write access denied on
[object]
Enabling tracing on an scml_clock object
UNDEFINED_WARNING
Warning in scml_clock
[object]: disabling
optimizations, clock cannot
be optimized when tracing
The following table lists the implicit FastTrack Model Internal  messages.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
282</p>
</section>
<section id="page-283">
<h2>Page 283<a class="headerlink" href="#page-283" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
Table 64: Implicit FastTrack Info Message
Event
Category
Message
Invoking a write callback on
any scml_memory  location or
register
SCML_CALLBACK_ENTRY [callback function name] ([object name]):
write to [address]: [data]
Returning from a write
callback on any scml_memory
location or register
SCML_CALLBACK_EXIT
[callback function name] ([object name])
Invoking a read callback on
any scml_memory  location or
register
SCML_CALLBACK_ENTRY [callback function name] ([object name])
Returning from a read callback
on any scml_memory  location
or register
SCML_CALLBACK_EXIT
[callback function name] ([object name]):
read from [address]: [data]
Invoking a write callback on
any scml_bitfield
SCML_CALLBACK_ENTRY [callback function name] ([object name]: write
[value] with mask [bitmask]
Returning from a write
callback on an scml_bitfield
SCML_CALLBACK_EXIT
[callback function name] ([object name])
Invoking a read callback on an
scml_bitfield
SCML_CALLBACK_ENTRY [callback function name] ([object name])
Returning from a read callback
on an scml_bitfield
SCML_CALLBACK_EXIT
[callback function name] ([object name]: read
[value] with mask [bitmask]
6.5.4. Suppressing FastTrack Messages
Suppressing a message means that it does not:
•
show on standard output,
•
record to the analysis database, and
•
trigger a FastTrack  breakpoint.
To suppress specific FastTrack messages, place a comma-separated value (CSV) file called
suppressions.csv  in the simulation working directory.
The format of the CSV file is as follows:
•
Each line represents one suppression rule.
•
Each line consists out of the following comma-separated values, which reflect the values of
attributes of the message that is to be suppressed. For a description of the meaning of the attributes,
SystemC Modeling Library Reference Manual
X-2025.06-SP1
283</p>
</section>
<section id="page-284">
<h2>Page 284<a class="headerlink" href="#page-284" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
see the beginning of FastTrack. The attributes should be listed in the order as outlined in the
following table:
Table 65: Sequential Order of the Attributes
Attribute
Optional
(Y/N)
Regular
Expression
Support
Notes
Simulation Time
Y
N
unit is ps (pico seconds).
This can be any one of the following:
◦a specific timestamp.
◦a single time range, two numerical values
separated with a -  character.
Severity
N
N
This can be any one of the following:
◦error
◦warning
◦info
◦model internal
Instance Name
Y
Y
Category
Y
N
The possible values are contained in tables
5.2/5.3/5.4. Do not use the enumerated values
for the categories, but the category names as they
appear in the Details view of the FastTrack event
trace in Virtualizer Studio/VP Explorer.
Message
Y
Y
Core Name
Y
Y
Program Counter
Y
N
This can be any one of the following:
◦a specific program counter value.
◦a single program counter range, two numerical
values separated with a -  character.
Software Function
Y
Y
Software Context
Y
Y
Software File Line Info
Y
Y
Note:
◦
Fields that are left empty are treated as wildcards, meaning that the value of this specific field
is not considered when determining when a message should be suppressed or not.
◦
Fields that support regular expressions only are treated as such if prefixed with the string
regex:.
◦
If a range is specified for a numerical field.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
284</p>
</section>
<section id="page-285">
<h2>Page 285<a class="headerlink" href="#page-285" title="Permalink to this heading"></a></h2>
<p>Chapter 6: Modeling Utilities
 
▪
The lower value should be specified first.
▪
The upper value is inclusive.
The following lines extracted from a CSV file illustrates these highlighted points:
•
To suppress all messages of severity error, emitted by HARDWARE.DISPLAY  if the program counter of
the core that did the access that triggered the message is between 0x210  and 0x214  (inclusive):
,error,HARDWARE.DISPLAY,0x210-0x214,
•
To suppress all messages of severity info, emitted by HARDWARE.DISPLAY , if the message contains
the string write:
,info,HARDWARE.DISPLAY,regex:.<em>write.</em>,
•
To suppress all messages of severity info, emitted by any module between 0  and 999999 ps :
0-999999,info,regex:.<em>,
•
To suppress all messages of severity info, category State Transition , emitted by any module:
,info,regex:.</em>,State Transition,
SystemC Modeling Library Reference Manual
X-2025.06-SP1
285</p>
</section>
<section id="page-286">
<h2>Page 286<a class="headerlink" href="#page-286" title="Permalink to this heading"></a></h2>
<p>Chapter 7
Functional Coverage
This chapter describes:
•
Functional Coverage
7.1. Functional Coverage
This chapter describes:
•
Coverage Semantics
•
SCML Functional Coverage Reference
•
Examples
The functional coverage solution part of SCML is heavily dependent on the work done in SystemVerilog
on the same topic. In that standard, functional coverage is defined as the user-specified coverage to
tie the verification environment to the design intent or functionality. It is in contrast to code coverage
that can be automatically extracted from the design code. The same coverage issues exist in a TLM
model: when looking at the code and function coverage, there is no way to know whether all possible
features have been exercised, for example, whether all enumerated values for a bitfield have been
covered. This example highlights a second problem: the code that contains the bitfield behavior is not
part of the model, many functions of a TLM model are hidden in the simulation libraries through the use
of SystemC and SCML modeling objects.
The following questions may come up while testing the model:
•
Do the tests exercise all the required functionality in the model?
•
Is enough testing being done? How to know that everything is done?
To answer these questions, a modeler can use the SCML coverage objects to create a coverage
model that defines what functionality is expected to be tested. These coverage objects are used by
the simulation engine to create a coverage database, from which the coverage report generator can
create an HTML report with the coverage results. A Coverage model links the specification to the
implementation. It determines what to cover, for example: what register accesses are important, which
values for bitfields are relevant, and what interfaces should be tested. The coverage model exists
next to the actual model and monitors the test activity versus the coverage specification and reports
coverage metrics.
You define three states for the Coverage report. Initially, the Coverage model is unreviewed, leading
to some uncovered and unreviewed coverage objects. At this stage, the Coverage report is labeled as
SystemC Modeling Library Reference Manual
X-2025.06-SP1
286</p>
</section>
<section id="page-287">
<h2>Page 287<a class="headerlink" href="#page-287" title="Permalink to this heading"></a></h2>
<p>Chapter 7: Functional Coverage
 
Failed. After an initial review phase, all coverage objects are either covered or reviewed, at which point
the coverage report will be labeled as In Progress. Finally, after all to-be-covered coverage objects are
covered, the coverage report indicates a Pass.
7.1.1. Coverage Semantics
This section describes:
•
Functional Coverage Constructs
•
Functional Coverage Exemptions
•
Functional Coverage Calculation
7.1.1.1. Functional Coverage Constructs
The SCML coverage semantics are derived from the SystemVerilog functional coverage standard. In
this standard, the following constructs are defined that are reused in SCML:
•
Covergroup: The covergroup construct encapsulates the specification of a coverage model. It
defines a set of coverage points and defines the sampling event for coverage points (when to
measure).
•
Coverage point: A coverage point specifies an expression or variable that is to be covered. A
coverage point includes a set of bins associated with the sampled values, which get calculated to a
coverage percent.
•
Coverbin: A coverbin defines how coverage is to be counted and which values should be covered. A
coverage point is covered when all its bins are covered.
Taking these semantics from SystemVerilog to SystemC TLM modeling with SCML, a number of
modifications are required:
•
Covergroup: In a TLM model, sampling using a covergroup does not make much sense. TLM
transactions, signal events, and other activities are not as synchronized as in an RTL model.
Therefore, sampling is not done using the covergroup, but is done for each coverage point
separately. Moreover, the sampling is implicit for the predefined coverage points; a modeler does not
need to care about sampling points.
•
Coverage point: A predefined set of coverage points is made available with specific, implicit
sampling behavior and attributes for the SystemC and SCML objects. Custom coverage points can
be added by the user through a function coverage point where the function determines what should
be validated for coverage. The sampling of function coverage points is user-defined.
•
Coverbin: In SCML, coverbins are not limited to values that should be evaluated before the start of
the simulation like in SystemVerilog. In SCML, it is possible to define a coverbin through a function
that defines whether a bin is covered or not. This allows to define coverbins for those objects, for
which no predefined evaluation is possible.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
287</p>
</section>
<section id="page-288">
<h2>Page 288<a class="headerlink" href="#page-288" title="Permalink to this heading"></a></h2>
<p>Chapter 7: Functional Coverage
 
•
Exemptions: As the TLM model functions at a higher abstraction level, not all details of lower-
level abstractions are required to be modeled. Additionally, some models are not required to be
functionally complete. To indicate these differences in expected coverage between the model
specification and the model implementations, exemptions can be put on specific coverage objects.
7.1.1.2. Functional Coverage Exemptions
TLM models often allow for a higher level of abstraction than described in the model specification. As
such, the model specification contains some aspects that are irrelevant for the TLM model. Additionally,
a TLM model might not require the full functional capability of the model specification.
To address these deviations from the model specification, a Coverage model allows for exemptions to
put on coverage objects to indicate that some deviation from the model specification is (temporarily)
expected.
The following exemptions are currently supported:
•
Unmodeled Nonfunctional
The coverage object is related to some model functionality which is nonfunctional at the required
level of abstraction.
•
Logically Reserved
The coverage object is related to a model object which logically is reserved, although the model
specification does not explicitly state it as such.
•
Unmodeled Functional
The coverage object is related to some model functionality which is not part of the functional scope
of the TLM model.
•
Tested Externally
The coverage object is related to some model functionality which is not part of the coverage scope of
the TLM model.
•
Untested Safe
The coverage object is related to some model functionality which is not part of the critical functional
scope of the TLM model.
•
Untested Unsafe
The coverage object is related to some model functionality which is part of the critical functional
scope of the TLM model, but currently uncovered.
If any coverage object has this exemption associated with it, the coverage report does not report a
Pass. This exemption is meant to facilitate the coverage report to transition from a Failed state to an
In Progress state.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
288</p>
</section>
<section id="page-289">
<h2>Page 289<a class="headerlink" href="#page-289" title="Permalink to this heading"></a></h2>
<p>Chapter 7: Functional Coverage
 
7.1.1.3. Functional Coverage Calculation
The report presents two coverage metrics: Reviewed Coverage and Tested Coverage.
Reviewed Coverage gives an indication of the level of coverage for the collection of coverage objects
except those that have an exemption (including the exemption Untested Unsafe). After this metric
achieves full coverage, the functional coverage report have the In Progress state.
Tested Coverage gives an indication of the level of coverage for the collection of coverage objects
except those that have an exemption (excluding the exemption Untested Unsafe). After this metric
achieves full coverage, the functional coverage report have the Pass state.
Functional coverage is calculated as follows:
Cg= (ΣiWi  x Ci) / (ΣiWi)
where:
•
i  is Σ / set of coverage items (coverage points) defined in the coverage group.
•
Wi  is the weight associated with item i  (see set_weight).
•
Ci  is the coverage of item i.
A coverpoint typically refers to a feature to be covered. It is a metric for the coverage of a feature. The
overall coverage number of a covergroup is representing how well all features have been covered. Each
feature can be more or less covered. The coverage of a coverpoint is calculated as:
Ci  = |binscovered| /|bins|
where:
•
|bins|  is the cardinality of the set of bins defined.
•
|binscovered|  is the cardinality of the covered bins: the subset of all (defined) bins that are covered.
A coverbin determines how a feature should be measured. Only when all bins are covered, the feature
is considered covered.
7.1.2. SCML Functional Coverage Reference
This section describes:
•
Covergroup
•
Coverage Point Base Class
•
Storage Coverage Points
•
Parameter and Status Coverage Points
•
Clock Coverage Point
•
Signal Port Coverage Point
SystemC Modeling Library Reference Manual
X-2025.06-SP1
289</p>
</section>
<section id="page-290">
<h2>Page 290<a class="headerlink" href="#page-290" title="Permalink to this heading"></a></h2>
<p>Chapter 7: Functional Coverage
 
•
TLM Socket Coverage Point
•
Generic Function Coverage Point
•
Coverbins
•
Default Bin
7.1.2.1. Covergroup
A covergroup is the owner of coverpoints. All derived classes should create coverpoints in their
constructor. The covergroup collects all the coverage data and is used to write the coverage database
at the end of the test run.
The covergroup can be constructed with the following constructor:
scml2::cov::covergroup::covergroup(const std::string&amp; covergroup_name,
const std::string&amp; test_name,
const sc_core::sc_module* module);
where:
covergroup_n
ame
Specifies the name for the covergroup. It is used by the report generator to refer
to the covergroup it is reporting for.
test_name
When a covergroup is used for different test runs, a different test name should
be used for each test run. The test_name  is used as base name for the log
file in which the covergroup stores the coverage results. The generated file is
./functional_coverage/test_name.log  and can be passed to the report
generator.
module
The module  is used as reference for error reporting. All messages reported by
the coverage infrastructure in this covergroup is reported against this module.
To serialize all the gathered data, the covergroup has a write_log()  API. This can be called at one
time, before any object related to the coverage collection is destructed.
scml2::cov::covergroup::write_log();
7.1.2.2. Coverage Point Base Class
There is no need to use the coverpoint  base class in a cover model, it is only listed here to describe
the generic properties of all coverpoints.
The coverage point supports the following methods:
void disable();
Disables a coverage point. No coverage metrics is collected in this case.
void enable();
Undoes the disable()  call.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
290</p>
</section>
<section id="page-291">
<h2>Page 291<a class="headerlink" href="#page-291" title="Permalink to this heading"></a></h2>
<p>Chapter 7: Functional Coverage
 
void set_comment(const std::string&amp;);
Adds a comment to the coverage point. The comment is added to the log file and ends up in the
HTML report.
void set_weight(floatw);
Specifies the weight for this coverage point relative to the other coverage points, while
calculating the overall coverage. By default, the weight is set to 1.
void iff(const std::function&lt;bool()&gt;&amp;);
Specifies a condition that should be satisfied, so that the sampling is recorded. The condition is
specified using a function that is evaluated on sampling, typically a C++11 lambda  function can
be used.
void set_max_value(const DT&amp; max_value);
Sets a maximum value for the object. This API should be used whenever the datatype of a
SystemC or SCML object allows for more values than that can be represented in the object.
For example, a 3-bit bitfield has a max_value  seven, even though you use an unsigned int  to
represent the bitfield.
void set_auto_bin_max(size_t auto_bin_max);
Generates an automatic bin for the coverage point. This API is used when no bin is created for
a coverage point. In that case, the infrastructure automatically generates bins for the coverage
point. The number of bins created is controlled using the auto_bin_max  value. Automatic bin
creation creates a bin for the full value range (0  to max_value) and configure it as an array
of size auto_bin_max. This splits the value range for the coverage point equally, over as
many bins as specified by the auto_bin_max  value. The default for auto_bin_max  is 1. If
auto_bin_max  is set to 0, no bins is generated.
bin_type&amp; bins(const std::string&amp; name,
const std::string&amp; description = “”);
Adds coverbins to the coverage point.
default_bin_type&amp; default_bin(const std::string&amp; name = “default_bin”,
const std::string&amp; description = “”);
Creates a default bin for the coverage point. For more information on default bins, see Default
Bin.
void clear_bins();
Removes all bins that were added so far, that is, it clears the complete coverage point. This API
is useful to overwrite the default bins generated by TLM Creator.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
291</p>
</section>
<section id="page-292">
<h2>Page 292<a class="headerlink" href="#page-292" title="Permalink to this heading"></a></h2>
<p>Chapter 7: Functional Coverage
 
7.1.2.3. Storage Coverage Points
A specific coverage point type is available for each of the SCML2 memory objects:
•
scml2::cov::reg<T>
•
scml2::cov::bitfield<T>
•
scml2::cov::memory<T>
•
scml2::cov::memory_alias<T>
These are specialized coverage points for all the SCML2 memory objects. These coverage points have
implicit sampling on a transaction access, or a regular put()  call (or assignment) to the memory object.
The sampling can be controlled using the access_type  attribute of these coverage points.
The constructors for the storage coverage points are:
•
reg(scml2::reg<T>&amp; r, const std::string&amp; name);
•
bitfield(scml2::bitfield<T>&amp; r, const std::string&amp; name);
•
memory(scml2::memory<T>&amp; r, const std::string&amp; name);
•
memory_alias(scml2::mmory_alias<T>&amp; r, const std::string&amp; name);
When constructing a storage coverage point, a reference to the original SCML2 storage object should
be passed. The typename of the coverage point in the scml2::cov namespace  should be the same as
the typename of the SCML2 memory object in the scml2:: namespace.
Note:
The name of the storage coverpoint is used by the coverage report generator to create a
hierarchical representation of the storage objects. The SystemC hierarchy naming convention is
used (using .), so m.regs.A.ENABLE  represents three levels of hierarchy. This is important while
adding coverage points to the storage objects already generated by TLM Creator, and to ensure that
the extra coverage points end up in their logical place in the coverage report.
The storage coverage points support the following extra method:
void access(access_type at);
This API can be used to set the access_type  attribute for the coverage point. This attribute is used to
restrict the sampling to specific accesses to the storage object.
The access_type  can be one of the following values:
•
TRANSACTION_READS
•
TRANSACTION_WRITES
•
WRITES
SystemC Modeling Library Reference Manual
X-2025.06-SP1
292</p>
</section>
<section id="page-293">
<h2>Page 293<a class="headerlink" href="#page-293" title="Permalink to this heading"></a></h2>
<p>Chapter 7: Functional Coverage
 
•
ALL_WRITES
•
ALL_WRITES_AND_TRANSACTION_READS
•
WRITES_AND_TRANSACTION_READS
•
ALL_TRANSACTION_ACCESSES
These values of access_type  are a concatenation of the terms below. For example,
WRITES_AND_TRANSACTION_READS  value covers what is specified for WRITES  and TRANSACTION_READS
terms below.
•
TRANSACTION_READS: example transactions that return read data on a read  command (no check
whether value is the one stored).
•
TRANSACTION_WRITES: example transactions with a write  command to the object (no check
whether the value is actually stored).
•
WRITES: checks for values actually written into the storage (put()  calls).
The default access_type  is WRITES_AND_TRANSACTION_READS. This covers those values that are read
using a transaction, and all written values.
Note:
Typically ALL_WRITES  counts accesses twice, as the transaction comes in and when the value is
stored in the storage object.
For coverage points associated with scml2::memory  and scml2::memory_alias, the default behavior
is that the whole range of memory is covered. This means that while sampling, there is no restriction on
the location to which a value is written. So, when a bin is created to cover the value 0x10, the coverage
bin is covered as soon as this value is written to the memory, independent of the location it is written in.
The coverpoints for memory  (scml2::cov::memory<T>) and memory_alias
(scml2::cov::memory_alias<T>) have the following extra APIs:
void indices(unsigned long long start, unsigned long longend);
Restricts the sampling to a specific range in the storage object, specified by the start  and end
byte address.
void set_interface_and_offset(const std::string&amp; _interface, size_toffset);
Guides the report generator. It enables the report generator to group memories connected to
the same interface together, and to sort them according to their offset.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
293</p>
</section>
<section id="page-294">
<h2>Page 294<a class="headerlink" href="#page-294" title="Permalink to this heading"></a></h2>
<p>Chapter 7: Functional Coverage
 
7.1.2.4. Parameter and Status Coverage Points
There are specialized coverage points for scml_property  (scml2::cov::scml_property<T>) and
status  (scml2::cov::status) objects:
The constructor for these coverage points is:
scml_property(const::scml_property<T>&amp; prop,
const std::string&amp; name);
The template type of the scml_property  coverpoint should be the same as for the
scml_property  itself. The scml_property  coverpoint is sampled at initialization of the
simulation. Since coverage is about values assigned to the object monitored by the coverage
point, there is no check whether the scml_property  is used. When an scml_propery
coverage point does not have any bins, it is automatically disabled. There is no need to
explicitly call the disable()  call.
status(const scml2::status&amp; st, const std::string&amp; name);
The status  coverage point is sampled each time a value is assigned to the scml2::status
object.
7.1.2.5. Clock Coverage Point
For the coverage of clocks inputs on a module, there is a specialized coverage point:
scml2::cov::scml_clock
This coverage point has the following constructor:
scml_clock(const sc_core::sc_in<bool>&amp; in, const std::string&amp; name);
The coverage point refers to the clock input signal on a module, but the coverage monitoring is done
on the scml_clock  instance that is at the source of this clock input signal. The clock coverage point is
sampled whenever set_period()  is called on the clock source. This works for both sc_clocks, as well
as the clock objects in SCML2.
The clock coverage point has one extra attribute: the time unit in which the values in the coverbins are
defined. The time unit attribute can be defined using the set_time_unit  API:
void set_time_unit(sc_core::sc_time_unit tu);
The default time unit is sc_core::SC_NS.
7.1.2.6. Signal Port Coverage Point
To measure coverage on signal ports of a module, the following coverage points are available:
•
scml2::cov::sc_in<T>
•
scml2::cov::sc_out<T>
•
scml2::cov::sc_inout<T>
SystemC Modeling Library Reference Manual
X-2025.06-SP1
294</p>
</section>
<section id="page-295">
<h2>Page 295<a class="headerlink" href="#page-295" title="Permalink to this heading"></a></h2>
<p>Chapter 7: Functional Coverage
 
with constructors:
•
sc_in(const sc_core::sc_in<T>&amp; in, const std::string&amp; name);
•
sc_out(const sc_core::sc_out<T>&amp; in, const std::string&amp; name);
•
sc_inout(const sc_core::sc_inout<T>&amp; in, const std::string&amp; name);
These are specialized coverpoints for signal inputs and outputs of a module. The template type of the
coverpoint should be same as the template type on the port of the module. All types supported by the
SystemC signal ports are supported here as well. Sampling is done whenever there is a value change
event on the signal associated with the port.
7.1.2.7. TLM Socket Coverage Point
For TLM sockets, there is a specialized coverage point:
scml2::cov::socket<T>
with constructor:
socket(<T>&amp; s, const std::string&amp; name);
The template type of the coverpoint should be same as the type of the port. At the moment, only
tlm::tlm_target_socket<BUSWIDTH>  and tlm::tlm_initiator_socket<BUSWIDTH>  are supported
(for a generic payload). Sampling is done whenever a b_transport  interface is called on the socket,
no other interface APIs is sampled. The default_bin  checks for any b_transport  call on the socket,
no checks on content are done. There is also no way to use the value bins for a socket coverage point.
To customize the bin for a socket coverage point, a custom evaluator method is needed. For more
information, see Coverbins.
7.1.2.8. Generic Function Coverage Point
It is possible to extend the SCML coverage solution by using the function  coverage point:
scml2::cov::function<T>
This coverage point allows to create coverage points for features that are not related to any SystemC
or SCML object. The type of the function  coverage point refers to the values that will be measured for
coverage.
The constructor for function  coverage point is:
function(const std::function&lt;T()&gt;&amp; f, const std::string&amp; name);
When constructing the coverage point, a function is specified as std::function&lt;T()&gt;&amp; f. This
function should return a value of the coverage point type. This function is called whenever the coverage
point is sampled and should return the value that should be evaluated for coverage.
A sample function is:
T sample();
SystemC Modeling Library Reference Manual
X-2025.06-SP1
295</p>
</section>
<section id="page-296">
<h2>Page 296<a class="headerlink" href="#page-296" title="Permalink to this heading"></a></h2>
<p>Chapter 7: Functional Coverage
 
The function  coverage point is the only coverage point without any implicit sampling, so it is required
that the sample()  function is called during the test, or is called by the object for which the function
coverage point is created.
7.1.2.9. Coverbins
A coverbin is owned by a single coverage point and counts how many times a coverage point monitored
a specific set of values.
A coverbin is always created using a coverage point:
auto&amp; binA = cov_pt.bins(“bin_name”, “bins_description”);
It can be immediately fully specified:
cov_pt.bins(“bin_name”).values({32,64,128,256}).array(4);
Bins are added to the coverage point using the bins  API. This creates a new bin with the specified
name and returns a reference for further refinement. The second argument is a description which is
recorded in the coverage database and are added to the HTML report by the report generator.
There is no need to use or know the type of the bins  objects, simply use the C++11 auto  keyword to
leave that to the compiler to figure out.
Since the bins  API returns a reference and the same is true for all APIs that further refine the bind
definition, it is possible to write the full bin definition in a single C++ statement (as shown in the
preceding code example).
The coverbin  objects have a set of APIs to further define the bin:
bin_type&amp; illegal();
Indicates that the values specified in this bin are illegal, they are not considered in the coverage
calculation of the coverage point. A runtime message is printed through FastTrack, indicating
when an illegal bin has been covered.
bin_type&amp; iff(const std::function&lt;bool(void)&gt; &amp; f);
Specifies a condition that needs to be satisfied to record the coverage sampling. The iff
function takes a functor (or C++11 lambda  function) that is evaluated each time the example
method for the coverage point is used. The function should return true  if the value is to be
recorded, and false  if it is to be ignored.
bin_type&amp; array(unsigned long long &amp; array_size);
Splits the values that are specified for the coverbin into an array of size array_size. The
values are equally spread over the bins, according to the order in which they were added.
Values that were added multiple times are kept as is, in the order they were added. The array
call should be the last definition refinement on the bin. It is not possible to add more values after
an array call has been made.
The following APIs are available to define the values for the coverbin:
bin_type&amp; range(const value_type&amp; start, const value_type&amp; end);
SystemC Modeling Library Reference Manual
X-2025.06-SP1
296</p>
</section>
<section id="page-297">
<h2>Page 297<a class="headerlink" href="#page-297" title="Permalink to this heading"></a></h2>
<p>Chapter 7: Functional Coverage
 
Adds a range of values to the coverbin, defined from the start  and up to and including the end
value.
bin_type&amp; value(const value_type&amp; v);
Adds a single value to the coverbin.
bin_type&amp; values(const std::initializer_list&lt;value_type&gt;&amp; vs);
Adds a set of values to the coverbin. It uses an initializer list to specify the values for clarity.
bin_type&amp; evaluator(const std::function&lt;bool(const value_type&amp;)&gt; &amp;f););
Specifies a function that should be called when the coverage point is sampled, to determine
whether the value that is sampled is part of the bin. The function takes one argument: the value
that is being sampled. The Boolean return value of the evaluator  function should indicate
whether the bin is covered.
The SCML coverage library provides a couple of utility evaluators that can be used in the evaluator
API of a coverbin:
scml2::cov::bit(unsigned idx);
This function returns true  when the bit with index idx  is set in the value to be covered.
scml2::cov::bits(const std::initializer_list&lt;value_type&gt; idxs);
This function returns true  when one of the bits is set in the value to be covered. The bits are
defined using an initializer list.
7.1.2.10. Default Bin
A default bin can be created for a coverage point:
auto&amp; defaultbin = cov_pt.default_bin(“name”, “comment”);
When there are bins created for the coverage point, the default bin represents all remaining values that
are not covered by any other bin. The default bin is not present by default. It needs to be created using
the default_bin  API on the coverage point. This feature is available for all coverage point types.
•
The default_bin  optionally takes a name and a comment for the bin (the default name is
default_bin).
•
There is one default bin for each coverage point.
The default bin has limited support for the coverage bin APIs:
•
It is not possible to define values for the default bin.
•
It is not possible to create an array for the default bin.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
297</p>
</section>
<section id="page-298">
<h2>Page 298<a class="headerlink" href="#page-298" title="Permalink to this heading"></a></h2>
<p>Chapter 7: Functional Coverage
 
7.1.3. Examples
cov_A.bins(“A”).values({32,64,128,256});
Creates one bin for four values.
As soon as any of these values is
sampled, the bin is covered.
cov_B.bins(“B”).values({32,64,128,256}).array(
4);
Creates four bins for four values,
each bin contains one value. The
coverpoint is fully covered when all
four values are sampled.
cov_C.bins(“C”).range(0, 255).array(8);
cov_C.default_bin().illegal();
A set of bins for the value range
0…255split in eight equally sized bins.
All other values are illegal.
auto &amp;Q = this-&gt;B.bins(“Q”);
Q.value(32).range(3,9).values({4,7,10,20}).arra
y(4);
Creates four bins with values: (32, 3,
4), (5, 6, 7), (8, 9, 4), and (7, 10,
20).
NOTE: The order in which values are
added to a bin is important.
this-&gt;A.disable(); this-&gt;A.ENABLE.bins(“all
values”).values({0,1}).array(2);
Disables the coverage for the register
A  and creates two bins for the single
bit bitfield ENABLE.
this-&gt;C.access(scml2::cov::TRANSACTION_READS);
this-&gt;C.iff(<span class="xref myst">&amp;t</span>{return t.A.ENABLE == 1; });
Only cover transaction reads for
coverpoint C  and adds a condition,
so that sampling is only done when
enable is set (t  is the model).
this-&gt;P3.bins(“allowed_values”).values({“AXI”,
“GFT”}); this-&gt;P3.default_bin().illegal();
Defines bins for the string parameter
coverpoint using an initializer list and
makes all other values illegal.
this-&gt;A_VAL_writes.bins(“S”).evaluator([&amp;t](co
nst unsigned int &amp;value) { return (value !=0 &amp;&amp;
value == t.B + t.C);});
A bin defined through an evaluator
function that checks whether the
sampled value is the sum of two other
registers in the design.
auto &amp;T = this-&gt;bus_reg_in.bins(“transaction
check”);T.evaluator([&amp;t](const
tlm::tlm_generic_payload &amp;trans) {return
trans.get_address() == 0x8;} );
A bin on a socket coverpoint checking
whether a transaction on address 0x8
was received.
this-&gt;A.ERRCODE.bins(“FATAL
ERROR”).evaluator(scml2::cov::bit<unsigned 
int>(0));
Creates a bin that checks whether bit
0  in the ERRCODE  bitfield of register A  is
set.
this-&gt;Q_ERRCODE.bins(“Minor
ERRORS”).evaluator(scml2::cov::bits<unsigned 
int>({0,1,2,3,4}));
Creates a single bin that checks
whether bits 0, 1, 2, 3  and 4  are set in
register Q_ERRCODE.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
298</p>
</section>
<section id="page-299">
<h2>Page 299<a class="headerlink" href="#page-299" title="Permalink to this heading"></a></h2>
<p>Chapter 7: Functional Coverage
 
this-&gt;UICCMDARG1.disable_all();
this-&gt;UICCMDARG1.enable();
Disables the coverpoints for all
bitfields in the UICCMDARG1  register.
The disable_all  call also disables
the register itself, therefore it is
reenabled using an enable  call.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
299</p>
</section>
<section id="page-300">
<h2>Page 300<a class="headerlink" href="#page-300" title="Permalink to this heading"></a></h2>
<p>Chapter 8
Modeling Guidelines
This chapter describes:
•
Requirements for a Virtual Prototype Model
•
Virtual Prototype Model Content
•
The SCML Modeling Guidelines for LT
•
Synchronization and Modeling for Speed
•
Getting Started
8.1. Requirements for a Virtual Prototype Model
v
i
r
t
u
a
l</p>
<p>p
r
o
t
o
t
y
p
e
s
r
e
q
u
i
r
e
m
e
n
t
s
Virtual Prototype models are developed to provide software developers and integration engineers with
an abstract model of the system. The goal is to enable them to create application, middleware, and/or
driver software, to optimize software performance and to validate and optimized system and software
architectures. The key requirements for a virtual prototype model to enable this use case are (taken
from the TLM2.0 requirements specification):
•
Running real unmodified software
It is important that the object code as it is compiled for the final system can be executed on the
virtual prototype. This implies the use of Instruction-Set Simulators (ISSes) for the processors for
which software is developed.
•
Simulation speed
A virtual prototype is a model of a design that is executed on a host machine. It is important that
the virtual prototype can execute software at a speed that is as close as possible to real time. This
for example means that it should be possible to start an OS in a few seconds to support driver
software development. At the same time, there is a trade-off between simulation speed and temporal
accuracy, which implies that for use cases that require a higher level of timing accuracy there is a
speed penalty, although also here the goal should be to achieve the highest possible simulation
speed.
•
Register accurate
To run embedded software correctly, the memory and memory-mapped register layout and content
should be modeled.
•
Functionally complete
SystemC Modeling Library Reference Manual
X-2025.06-SP1
300</p>
</section>
<section id="page-301">
<h2>Page 301<a class="headerlink" href="#page-301" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
All consequences of the software interaction with the rest of the system should be modeled. This
implies how software interfacing with memory-mapped registers influences their content or the
content of other memory-mapped registers. It also implies to model the influence of interrupt signals
and other sideband signals that have an effect on the execution of software.
•
Loosely Timed (LT)
Timing in a virtual prototype is intended to simplify the synchronization of hardware components with
software. Timing information is not an indication of timing accuracy for the overall operation of the
system. In an LT model, timer interrupts fire roughly at the expected time to successfully start OS. In
general it is important to have an indication of the speed of the hardware interactions with software
(through interrupts, timers, and so on) and of how fast register content is updated. However, it is
not required to have the exact timing for each and every event in the system to enable software
development.
•
Approximately Timed (AT):
For the software optimization and architecture analysis use cases, the Loosely timed abstraction
does not provide with sufficient temporal accuracy. In this case, it is required to add more timing
detail to the models. This implies that timing details of the processor need to be modeled in the
instruction set simulator, including its memory subsystem (caches, prefetch operations, and so on).
The goal is that the resulting system provides with enough detail to derive reasonably accurate
performance data to decide on optimization strategies, resource mapping and memory architectures.
•
Debugging and analysis
The virtual prototype should provide hooks to attach embedded software debuggers, and tools to
perform software analysis for the design.
•
Performance information
It should be possible to derive reasonably accurate performance data from simulation to enable
software performance profiling and optimization. For this, timing annotation information may need
to be improved, which may lead to additional functionality of the system that needs to be modeled.
For example, the caches and memory controllers of the system should now be modeled more
accurately.
•
Configuration
Due to the possible speed difference when enabling performance information gathering, a runtime
switch is required that enables these additional features.
8.2. Virtual Prototype Model Content
v
i
r
t
u
a
l</p>
<p>p
r
o
t
o
t
y
p
e
s
c
o
m
p
o
n
e
n
t
s
When assembling a virtual prototype, it is important to meet the requirements listed in Requirements
for a Virtual Prototype Model. An actual embedded system usually consists of many components, not
all of which need to be modeled in a virtual prototype. Some components have a direct relation to the
execution of software, whereas others may have no relation to software. Only the components that are
important to execute software correctly need to be modeled. Components like built-in self test, analog-
SystemC Modeling Library Reference Manual
X-2025.06-SP1
301</p>
</section>
<section id="page-302">
<h2>Page 302<a class="headerlink" href="#page-302" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
digital converters, voltage regulators, on-chip debug interfaces, protocol converters, arbitration units,
clock control, and any other block should not be modeled if they do not impact the functionally correct
execution of software. A virtual prototype typically contains components of the following types:
•
p
r
o
c
e
s
s
o
r</p>
<p>m
o
d
e
l
,</p>
<p>i
n</p>
<p>v
i
r
t
u
a
l</p>
<p>p
r
o
t
o
t
y
p
e
Processor cores
To run the object code of the actual software, ISSes are used, wrapped into a module with sockets
for the data communication, interrupt signals, and integrated into the multitasking kernel of SystemC.
Processors that run software which is not part of the current development can be replaced with
an abstract functional model of the software. Such a model contains the algorithm with timing
annotation and explicit socket accesses to model the data communication with the rest of the
system. When creating a virtual prototype, there is no need to model processors. Processor models
are typically made available by the processor vendors.
•
i
n
t
e
r
c
o
n
n
e
c
t
,</p>
<p>i
n</p>
<p>v
i
r
t
u
a
l</p>
<p>p
r
o
t
o
t
y
p
e
Memory and Interconnect Hierarchy IP
Communication between different components in a system can be very complex, but depending on
the use case it may not be necessary to model all the details of the system interconnect. Instead
communication could be limited to reflect the memory-map decoding of the actual system. The data
transactions in the model should include all information necessary for correct software execution.
For example, information about secure accesses, protection, exclusive access should be modeled.
TLM2.0 has provided generic interconnect models and has set the basis for other organizations to
develop standard interfaces for industrial interconnect components. For software optimization and
exploration use cases, the interconnect model should have sufficient timing detail to allow modeling
of the protocol specific timing implications of data and instruction exchanges. Even more accurate
models of the interconnect are needed when the focus of the architecture exploration focuses on
the interconnect itself, these models should be reusable for the software-centric use cases, but are
generally replaced by their more abstract versions.
•
m
e
m
o
r
y
i
n</p>
<p>v
i
r
t
u
a
l</p>
</section>
<section id="p-r-o-t-o-t-y-p-e-memory-ip-obviously-the-key-component-for-software-execution-is-to-have-a-memory-model-the-memory-subsystem-does-not-have-to-include-the-full-behavior-of-caches-and-memory-controllers-it-is-possible-to-limit-their-function-to-have-the-control-registers-for-these-components-modeled-and-leave-the-behavior-out-however-if-performance-analysis-of-the-software-is-required-then-the-functional-behavior-of-caches-and-the-memory-subsystem-should-be-present-to-be-able-to-see-the-timing-impact-of-the-different-data-accesses-by-software-with-scml-generic-memory-models-are-trivial-so-no-special-effort-is-required-for-these-m-e-m-o-r-y">
<h2>p
r
o
t
o
t
y
p
e
Memory IP
Obviously, the key component for software execution is to have a memory model. The memory
subsystem does not have to include the full behavior of caches and memory controllers. It is
possible to limit their function to have the control registers for these components modeled and leave
the behavior out. However, if performance analysis of the software is required, then the functional
behavior of caches and the memory subsystem should be present to be able to see the timing
impact of the different data accesses by software. With SCML, generic memory models are trivial; so
no special effort is required for these.
•
m
e
m
o
r
y<a class="headerlink" href="#p-r-o-t-o-t-y-p-e-memory-ip-obviously-the-key-component-for-software-execution-is-to-have-a-memory-model-the-memory-subsystem-does-not-have-to-include-the-full-behavior-of-caches-and-memory-controllers-it-is-possible-to-limit-their-function-to-have-the-control-registers-for-these-components-modeled-and-leave-the-behavior-out-however-if-performance-analysis-of-the-software-is-required-then-the-functional-behavior-of-caches-and-the-memory-subsystem-should-be-present-to-be-able-to-see-the-timing-impact-of-the-different-data-accesses-by-software-with-scml-generic-memory-models-are-trivial-so-no-special-effort-is-required-for-these-m-e-m-o-r-y" title="Permalink to this heading"></a></h2>
<p>m
a
p
p
e
d</p>
<p>c
o
m
p
o
n
e
n
t
s
,</p>
<p>i
n</p>
<p>v
i
r
t
u
a
l</p>
<p>p
r
o
t
o
t
y
p
e
Memory-mapped components
For virtual prototypes, these components are very important: They allow the functional verification of
the embedded software. Internal memory-mapped registers and the behavioral consequences of a
register access should be modeled. Model creation for memory-mapped components is one of the
key topics of this modeling guidelines manual.
•
E
x
t
e
r
n
a
l</p>
<p>i
n
t
e
r
f
a
c
e
s
,</p>
<p>i
n</p>
<p>v
i
r
t
u
a
l</p>
<p>p
r
o
t
o
t
y
p
e
External interfaces
USB, serial ports, Ethernet, audio and video IO, Camera, Firewire, SIM card and so on are key
elements of many system on chip designs. For the virtual prototype development, they are partly
memory mapped components, that is, the register interface of these components is important to
SystemC Modeling Library Reference Manual
X-2025.06-SP1
302</p>
</section>
<section id="page-303">
<h2>Page 303<a class="headerlink" href="#page-303" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
enable embedded software development. However, to test the functionality of these components, the
virtual prototype needs to be extended with a model of the ‘external world’ as seen by the system it
is modeling. This external world can be modeled as real world IO by using similar capabilities in the
host (for example, USB) allowing the platform to forward the communication to the host, alternatively
virtual IO can be used where for example, the file system on the host is used to mimic things like
MMC/SD/SDIO, HDMI, SATA.
•
c
o
m
m
u
n
i
c
a
t
i
o
n</p>
<p>c
o
m
p
o
n
e
n
t
s
,</p>
<p>i
n</p>
<p>v
i
r
t
u
a
l</p>
<p>p
r
o
t
o
t
y
p
e
Communication components
This refers to DMA, communication bridges between subsystems, shared memory components,
accelerators, and so on. These components are important for the part of their behavior that changes
the content of memories and memory-mapped registers or how these components can be accessed.
As they have an impact on the execution of software, these components need to be part of virtual
prototype models.
•
P
l
a
t
f
o
r
m</p>
<p>s
y
n
c
h
r
o
n
i
z
a
t
i
o
n
,</p>
<p>i
n</p>
<p>v
i
r
t
u
a
l</p>
<p>p
r
o
t
o
t
y
p
e
Platform synchronization
These components are required for scheduling and real-time software functionality and deal with
synchronization in the system. Usually, these components are software configurable; for this part of
their behavior they are not different from any other memory-mapped components. The difference
is in the behavior of these components, where it is important to model the correct timing and
synchronization of the system. These components are also addressed in this manual.
•
D
a
t
a</p>
<p>p
r
o
c
e
s
s
i
n
g
,</p>
<p>i
n</p>
<p>v
i
r
t
u
a
l</p>
<p>p
r
o
t
o
t
y
p
e
Data processing
These are all the blocks that can perform certain functionality related to the processing of data in
parallel to the execution of software, but that are tightly controlled by it. For the virtual prototype
use cases the exact implementation of the processing algorithm may be of lesser importance, the
focus of the models for these components should be on the functionality they provide, their register
interface and the mechanisms they use to exchange data with the embedded software. Therefore,
it is possible to develop these models reusing generic data processing libraries as they exist for the
host and wrap them with register and data exchange interface models to include them in the virtual
prototype.
•
S
u
b
s
y
s
t
e
m
s
,</p>
<p>i
n</p>
<p>v
i
r
t
u
a
l</p>
<p>p
r
o
t
o
t
y
p
e
Subsystems
As systems get more and more complex a key question when creating a virtual prototype is whether
all components and subsystems need to be modeled for a certain use case or not. In general
common sense should drive the decision when to stop. If the goal of the virtual prototype is to
enable software development on the main application processor of the system, then it may not be
necessary to model the wireless modem subsystem, or to have that limited to its data interface.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
303</p>
</section>
<section id="page-304">
<h2>Page 304<a class="headerlink" href="#page-304" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The following figure shows an example of a virtual prototype.
Figure 91: A Virtual Prototype
S
C
M
L</p>
<p>m
o
d
e
l
i
n
g
,</p>
<p>i
n
t
r
o
d
u
c
i
n
g
V
i
r
t
u
a
l</p>
<p>P
r
o
t
o
t
y
p
e</p>
<p>M
o
d
e
l</p>
<p>C
o
n
t
e
n
t
S
C
M
L
p
u
r
p
o
s
e
The purpose of SCML is to enable efficient modeling of virtual prototype components. This is achieved
by encapsulating certain aspects of the TLM2.0 modeling standard with a generic implementation
covering the most common uses of TLM2.0. SCML also provides a number of additional modeling
objects that provide model-to-tool interactivity and a set of reusable timing objects.
8.3. The SCML Modeling Guidelines for LT
S
C
M
L
m
o
d
e
l
i
n
g</p>
<p>g
u
i
d
e
l
i
n
e
s
This section describes the rules to create component models for virtual prototypes using SCML. The
modeling guidelines and coding style discussed here are focused on the loosely timed coding style.
They present the requirements for the FT modeling style model configuration to address the embedded
software development use case. These rules are demonstrated through examples in the following
subsections. All rules that are demonstrated in the examples are listed here. They are split into two lists:
•
Modeling Methodology Guidelines
•
Coding Style Guidelines
8.3.1. Modeling Methodology Guidelines
m
o
d
e
l
i
n
g</p>
<p>m
e
t
h
o
d
o
l
o
g
y</p>
<p>g
u
i
d
e
l
i
n
e
s
The generic SCML modeling guidelines for virtual prototype components are derived from the
requirements to model virtual prototypes described in Requirements for a Virtual Prototype Model and
the coding style described in Fast Timed Modeling (FTM) Coding Style.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
304</p>
</section>
<section id="page-305">
<h2>Page 305<a class="headerlink" href="#page-305" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
m
o
d
e
l
i
n
g</p>
<p>g
u
i
d
e
l
i
n
e
s
m
o
d
e
l</p>
<p>o
n
l
y</p>
<p>w
h
a
t</p>
<p>y
o
u</p>
<p>n
e
e
d
Specification documents for hardware components typically contain a lot of detail that is not important
when creating a model that is going to be used in a virtual prototype.
The following table describes guidelines related to modeling only what you need.
Table 66: Rules for Modeling Only What You Need
Rule ID
Rule Description
1.1
Only that part of the specification that is relevant to the execution of software should
be modeled.
This is also called the software observable state. It is that part of the specification of
the component that is accessible, visible from software, or that can have an impact on
the execution flow of software. This means that the section describing the function of
the component is important, as well as the part of the specification that describes the
programming model with the detailed register layout.
1.2
The detailed I/O interfaces should be abstracted into bus interfaces and modeled using
TLM sockets.
virtual prototypes are mostly about memory-mapped communication between software and
hardware. TLM2 sockets should be used to model these interfaces. Other interfaces should
only be modeled when the activity on these interfaces influences the software execution. An
example are interrupt interfaces.
1.3
Where possible, timing information should be left out or abstracted to express the
software execution rate.
There is no need to follow the detailed timing specification of the component. The most
important reason to use timing information in a model is to model synchronization with the
software and the rest of the system.
1.4
Behavior must be implemented as a simple function call or possibly a state machine.
m
o
d
e
l
i
n
g</p>
<p>g
u
i
d
e
l
i
n
e
s
m
o
d
e
l
i
n
g</p>
<p>f
o
r</p>
<p>s
p
e
e
d
The simulation performance of a virtual prototype model requires special attention. The goal is to get as
close as possible to real-time execution for a model that will execute on a workstation. TLM2.0 defines
the standard approach to create models for high-speed simulation. It is based on temporal decoupling
and DMI (Direct Memory Interface). SCML enables these features in the SCML modeling objects so that
these features are available by default. For more information, see Synchronization and Modeling for
Speed.
The following table describes guidelines related to modeling for speed.
Table 67: Modeling for Speed Rules
Rule ID
Rule Description
2.1
Temporal decoupling must be used for components that initiate transactions.
This typically relates to processor models. Temporal decoupling improves speed since it
reduces the number of task switches between threads in a virtual prototype model. When all
processor models would run in lock step, there would be a task switch every instruction or
clock cycle; with temporal decoupling this only happens every thousand or more instructions.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
305</p>
</section>
<section id="page-306">
<h2>Page 306<a class="headerlink" href="#page-306" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Table 67: Modeling for Speed Rules (Continued)
Rule ID
Rule Description
2.2
Avoid the use of clock sensitive threads and methods.
This rule relates for example to timer components. When modeling a component that is only
active irregularly or with large time intervals, it is better to use SCML clock objects or to use
the SystemC event scheduler to schedule the exact time point where to execute the model
behavior. Since task switches are expensive, it is important to avoid them; this also implies
avoiding the use of threads and methods as much as possible.
2.3
Minimize the number of transactions.
The number of transactions used to communicate a certain chunk of data determines
the number of function calls used in the model (each transaction implies a blocking TLM
interface). There is an overhead with each function call and payload that is created. By
reducing the number of transactions, speed will be improved. For this reason, the TLM2.0
generic payload models bursts as a single transaction.
2.4
Use DMI for all sockets that initiate transactions.
DMI is intended to reduce the impact of the infrastructure required to do communication
between a processor and memory. By avoiding the assembly of a payload and the function
call overhead to implement a data transaction, simulation speed is improved.
2.5
Optimize for simulation speed when required.
Follow the strategy discussed in Modeling Fast Target and Router Peripherals.
1.Minimize synchronization by selecting the right synchronization level for memory-mapped
register callbacks.
2.Optimize the most frequently accessed peripheral first.
3.Use read/write callbacks whenever it is possible to differentiate read behavior from write
behavior.
4.Use dynamic registration and removal of callbacks for memory-mapped registers
2.6
Apply C++ coding guidelines for speed.
All methods that improve the execution speed of software on a workstation apply here as well.
1.Reduce the number of data copies required to execute the behavior and communication of
the model.
2.Avoid repeated external output (file access, terminal output).
3.Avoid repeated creation/destruction of complex data elements.
4.Avoid dynamic memory allocation
m
o
d
e
l
i
n
g</p>
<p>g
u
i
d
e
l
i
n
e
s
m
o
d
e
l
i
n
g</p>
<p>b
e
h
a
v
i
o
r
SCML provides memory modeling objects to model all memory-mapped storage and behavior. SystemC
threads should be used for all independent and concurrent behavior in a system.
The following table describes guidelines related to modeling behavior.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
306</p>
</section>
<section id="page-307">
<h2>Page 307<a class="headerlink" href="#page-307" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Table 68: Modeling Behavior Rules
Rule ID
Rule Description
3.1
Use the SCML memory modeling objects for all memory-mapped storage.
To separate the communication interface from the behavior, SCML provides memory, register,
and bitfield objects. SCML memory modeling objects provide a default storage behavior for
all accesses to the objects. These objects can interface with a socket of the module. So in a
component model, each memory-mapped socket have a memory object associated with it.
The storage objects can be constructed in a detailed hierarchical model of the memory map
of a component. The objects also implement the link to platform debug and analysis tools, and
provide DMI access for initiators.
3.2
Use callbacks on the SCML memory modeling objects for all memory-mapped
behavior.
The default storage behavior of the SCML memory modeling objects can be overridden
through callbacks. To model the impact of software accesses to the registers of a component,
there are callback interfaces. Internal values of the component can be updated based on
the information that comes with the register access. When a memory access results in
communication to another component in the system, the behavior needs to synchronize
the overall system state. For this purpose, callbacks can indicate their synchronization
requirements when they are registered with the storage objects.
3.3
Use SystemC threads for all behavior that is concurrent to the execution of software
and that initiates memory-mapped communication.
In many cases, communication that is a consequence of a memory-mapped access
can be modeled within the callback associated with the register access. In this case, all
communication and behavior is instantaneous for the software. Whenever the communication
happens in the future or is spread over multiple time points, a SystemC thread should be
used. The thread allows to model concurrent behavior to the execution of software.
3.4
Use SystemC methods to model all behavior that is concurrent to the execution of
software and that does not initiate memory-mapped communication.
SystemC methods are more efficient than SystemC threads for simulations speed. In a
SystemC method it is not possible to use a quantum keeper or to initiate communication over
a blocking interface like the TLM2.0 LT interface.
3.5
Use a regular class method to model the state update for a component.
A typical behavior for a component is that its I/O and register values depend on the changes
of both the I/O pins and the registers. This means that each time the value of one of the input
pins or registers changes, all output should be recomputed. In such a case, it is best to create
a recomputed method that is used both in the register callbacks as well as in the method
sensitive to the input changes.
3.6
Use submodules to model recurring behavior.
When a component is defined as a series of submodules with the same behavior, which
together form a unique and well-defined component, it is best to create this as a single
component for platform assembly. This implies that it is not necessary to use the usual
SystemC or TLM communication mechanisms. Use sc_module  s to define the submodules to
ease debugging, so that naming of signals and internals get an additional SystemC hierarchy
level. To communicate from the component level to the submodule, simple variable accesses
and class method calls are sufficient. There is no need to introduce ports on the submodules
or to use signals to communicate with the submodules.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
307</p>
</section>
<section id="page-308">
<h2>Page 308<a class="headerlink" href="#page-308" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
m
o
d
e
l
i
n
g</p>
<p>g
u
i
d
e
l
i
n
e
s
c
o
m
m
u
n
i
c
a
t
i
o
n
Modules communicate using TLM interfaces. The goal of TLM modeling is to abstract the details of
the pin interfaces between components to achieve higher simulation speed and make model creation
easier. Virtual prototype modeling is based on the LT coding style of TLM2.0. Communication is
done through a single function call from initiator to target, carrying the transaction payload and timing
information.
The following table describes guidelines related to communication.
Table 69: Communication Rules
Rule ID
Rule Description
4.1
t
r
a
n
s
a
c
t
i
o
n</p>
<p>p
a
y
l
o
a
d
Use the TLM2.0 generic transaction payload for all generic memory-mapped
communication.
In SystemC TLM2.0, a generic payload is defined. It carries the typical information of a
memory-mapped bus: address, data, data length, command (read/write), byte enables,
response status. The SCML storage objects implement the behavior associated with this
payload definition. The callbacks for memories can use the standard payload or also
simplified information, in which case the memory objects handles the semantics that are
not forwarded to the callbacks. An adapter is provided that sits between the storage objects
and the socket. This adapter implements some of the payload semantics that do not fit with
the behavior of the storage objects (for example, separating burst accesses into individual
accesses).
4.2
Use a protocol-specific TLM2.0 payload when available.
When creating a model for a component that uses an interconnect interface for which a
TLM2.0 LT payload or socket is defined, that specialized TLM2.0 payload has to be used.
This requires that a dedicated protocol adaptor for the protocol is available to connect SCML
memory objects to the specialized socket. An interconnect model using the specialized
payload must be used to connect the components of the virtual prototype together.
4.3
Use SystemC signals for all sideband communication between components.
For all infrequent communication between blocks that is not memory-mapped communication,
SystemC signals can be used. It is important to make sure to synchronize before and after
reading or writing to a signal from a memory-mapped behavior callback. This guarantees that
the signal value that is used is set or seen at the right time in the system, so that the most up-
to-date value is seen by all blocks involved.
m
o
d
e
l
i
n
g</p>
<p>g
u
i
d
e
l
i
n
e
s
t
i
m
i
n
g</p>
<p>a
n
d</p>
<p>s
y
n
c
h
r
o
n
i
z
a
t
i
o
n
The final foundation layer of the SCML modeling guidelines is timing. In a virtual prototype, timing
information is used to model the synchronization rate of different components in a system. For details,
see Requirements for a Virtual Prototype Model. Adding timing to a model can be done in various
ways, but always implies to add more synchronization points into the model, which has an impact on
simulation performance. For more information on synchronization, see Synchronization and Modeling
for Speed.
The following table describes guidelines related to timing and synchronization.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
308</p>
</section>
<section id="page-309">
<h2>Page 309<a class="headerlink" href="#page-309" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Table 70: Timing and Synchronization Rules
Rule ID
Rule Description
5.1
The timing parameter in the TLM2.0 LT interfaces must only be used for
synchronization or to influence the software execution rate.
The TLM2.0 communication interfaces carry a timing parameter. This is used to annotate the
timing of the data transfer. In a temporally decoupled system, it is the initiator that keeps track
of its local time in relation to the quantum. So it passes its current local time along with the
transaction for the target to annotate the delay of the transfer.
Whenever a target explicitly synchronizes with SystemC, it can use the value of the timing
parameter to advance the global simulation time and set the timing annotation to 0  so that the
initiator is aware of the synchronization that happened.
A target can also use the value of the timing parameter to implement the delay of a software
access to this memory-mapped location. This is not a measure for timing accuracy, but
influences the software execution rate of the software accessing the target versus other
software that is not accessing this target.
5.2
Increment the local time of an initiator with the execution time of the initiator on each
transaction.
The initiators referred to in this rule are SystemC threads that initiate transactions
independently of the software execution. As it is the initiator which the controls time in a
virtual prototype, the local time parameter of the quantum should be incremented on every
access. Before the TLM transaction is started, the local time should be updated to the point
before the transaction. After the transaction, the time should be further updated with the
timing for the current operation and next the quantum should be checked for synchronization
(see SCML2 Fast Timed (FT) Modeling). For example, an ISS would make sure local time is
updated to the point the current instruction is started, do the TLM transaction next, and after
the transaction increment the local time with the delay for the current instruction and then
check for synchronization.
5.3
There should be a check whether the local time is exceeding the quantum
synchronization period after every transaction.
With every transaction, local time of an initiator can be further incremented by the target
components. This possibly causes an overrun on the quantum value; this should force
synchronization with the rest of the system. This is done through the need_sync()  and
sync()  API calls of the TLM2.0 quantum keeper. As explained in 5.2, the initiator also should
take into account the delay for the current operation. This mechanism ensures that any signal
that is written can propagate to its final destination.
NOTE: Whenever a signal is written, there may be multiple event-sensitive methods between
the original source of the change and its destination. The delay after the transaction makes
sure all these event-sensitive methods get triggered before the initiator starts another
quantum.
5.4
Use the SCML clock objects to schedule regular events.
The SCML clock objects are a more efficient implementation of clocks than the regular clocks
found in the SystemC kernel. Avoid the use of SystemC clocks.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
309</p>
</section>
<section id="page-310">
<h2>Page 310<a class="headerlink" href="#page-310" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Table 70: Timing and Synchronization Rules (Continued)
Rule ID
Rule Description
5.5
Callback behavior on &gt;SCML memory objects must be set to AUTO_SYNCING  whenever
the correct execution of the behavior requires a synchronized system.
It is best to use AUTO_SYNCING  in all cases and only change when optimizing for speed.
Cases when AUTO_SYNCING  is required include, but are not limited to:
1.The behavior queries the global SystemC time using sc_time_stamp()  or
sc_simulation_time().
2.The behavior reads from an scml_counter  object using get_count() , read() , or the ()
operator.
3.The behavior reads from or writes to an sc_signal  or any other primitive SystemC channel
(either internal to the component or when accessing a pin port).
4.The behavior notifies an event.
5.The behavior calls wait().
6.The behavior accesses a port or socket that does not support temporal decoupling. This
includes using the post() , transport() , post_read() , or post_write()  methods of
the scml_post_port.
7.The behavior models a software synchronization primitive, for example, when the storage
is used for software semaphores.
5.6
Use SELF_SYNCING behavior whenever the behavior complies with the following
rules:
1.The behavior is not AUTO_SYNCING. This means the behavior requires synchronization,
maybe not with each invocation but at least in certain cases.
2.The behavior accesses ports or sockets that support temporal decoupling. This means they
have a timing parameter according to the definition for TLM2.0 b_transport.
5.7
Use NEVER_SYNCING behavior whenever the behavior never requires
synchronization.
This requires that the behavior complies to both of the following rules:
1.The behavior is not AUTO_SYNCING.
2.The behavior is not SELF_SYNCING.
8.3.2. Coding Style Guidelines
c
o
d
i
n
g</p>
<p>s
t
y
l
e</p>
<p>g
u
i
d
e
l
i
n
e
s
This section describes guidelines related to the coding style.
The following table describes SCML-related guidelines.
Table 71: SCML-Related Rules
Rule ID
Rule Description
6.1
m
o
d
e
l
i
n
g</p>
</section>
<section id="g-u-i-d-e-l-i-n-e-s-s-c-m-l">
<h2>g
u
i
d
e
l
i
n
e
s
S
C
M
L<a class="headerlink" href="#g-u-i-d-e-l-i-n-e-s-s-c-m-l" title="Permalink to this heading"></a></h2>
<p>r
e
l
a
t
e
d</p>
<p>c
o
d
i
n
g</p>
<p>g
u
i
d
e
l
i
n
e
s
A component must include the &lt;scml2.h&gt;, &lt;tlm.h&gt;, and <systemc> headers.
6.2
The template parameter of a tlm_target_socket and a tlm2_gp_target_adapter must be
the same.
This means that both should have the same bitwidth defined.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
310</p>
</section>
<section id="page-311">
<h2>Page 311<a class="headerlink" href="#page-311" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Table 71: SCML-Related Rules (Continued)
Rule ID
Rule Description
6.3
The size of the C++ data type specified as template parameter with an scml::memory
object must be the same as the bitwidth of the adapter and socket it is connected to.
6.4
For readability, it is advised to name the top-level SCML memory object and to put all
internal registers of the module together in a InternalRegisters memory object.
This improves the clarity of the code, but also ensure that the representation of the model in
debugging tools like VP Explorer is easy to use. All internal registers are grouped next to the
memory-mapped registers.
6.5
Always make sure there is a visual link between the address values used by software
and the index representation of scml::memory.
Addresses are specified as byte addresses in TLM2.0, while indexes in an SCML memory are
based on word size (for example, 32 bits, or 4 bytes). To avoid confusion over index versus
address values, it is best to put the conversion calculation in the code. This can for example
be done by specifying all index values as address &gt;&gt; 2.
6.6
Use scml2::initiator_socket to model a socket through which software transactions
or transactions concurrent to software execution is issued according to the TLM2.0
generic protocol.
In case the transactions are not from a processor executing software, or are not concurrent
to software execution, a regular TLM2.0 initiator socket can be used. This avoids an
independent quantum for transactions going through this socket.
6.7
Use an array of pointers to registers or memories when defining a range of registers or
memories.
To make sure each register can be given a name and to make sure it is possible to easily
iterate over a range of registers, you are advised to use a pointer to an array of registers or
memories so that each individual register can be constructed and properly named.
6.8
Whenever possible, use the same name for pins and sockets in the model as in the
specification of the component.
This improves legibility and testing for the component model. This name should be used for
the C++ object as well as the SystemC name passed in the initialization. Exception to this rule
is when multiple objects would end up with the same name.
6.9
Whenever possible, use the same names for memory-mapped registers and bitfields as
specified in the specification of the component.
This improves legibility and testing for the component model. This name should be used for
the C++ object as well as the SystemC name passed in the initialization. Exception to this rule
is when multiple objects would end up with the same name. An example is bitfields that are
specified with the same name as pins on a component.
6.10
Use meaningful names for the callback methods.
When a method is only used as a callback, it should have a name that indicates when it is
called and for which register. In the examples of this modeling guidelines manual, methods
are named according to the following naming template:
{on | post} {registerName | bitfieldName} {Read | Write | Transport}
For example, onWdogValueRead  or postWdogLoadWrite.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
311</p>
</section>
<section id="page-312">
<h2>Page 312<a class="headerlink" href="#page-312" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Table 71: SCML-Related Rules (Continued)
Rule ID
Rule Description
6.11
Use meaningful names for the methods that is made sensitive to events.
In the examples of this manual, methods are named according to the following naming
template:
on eventName
or for signals:
on signalNameChange
For example, onTimeOutEvent  or onIRQInchange.
6.12
Bit numbering in SCML registers.
When defining bitfields in a register, take into account that in SCML the Least-Significant Bit
(LSB) is at position 0. When your specification uses a bit numbering with the Most-Significant
Bit (MSB) at location 0, this should be taken into account.
6.13
Reusing callbacks for multiple registers.
Use the tagged version of callback registration when the same behavior (or very similar
behavior) is associated with a range of registers. This can be achieved by defining a memory
alias for this range and register a tagged callback. The callback itself has an additional
parameter that indicates which specific register index triggered the callback. This allows to
identify the register to be used in the behavior, or to differentiate parts of the behavior based
on the register that was accessed.
6.14
Do not duplicate state.
When registers, bitfields, or memory represent the state values of a component, it is not
necessary to add separate variables in the model to represent the state. This leads to
unnecessary copying and raises the risk of nonsynchronized values between the register
interface and the internal variables.
6.15
When the behavior of a register or bitfield access depends on the old and new value in
the register or bitfield, use a regular read or write callback; do not use the post_read or
post_write callbacks.
Since the post_  callbacks store the new value before triggering the behavior, the old value
is lost. Adding another variable to keep track of the old value is not necessary since the
alternative of using a simple read or write callback avoids this. However, remember that a
simple read callback does not store the value automatically, so this should now be part of the
behavior.
6.16
Use arrays or ranges to model a specification that defines register_0…n.
It is easier to work with myRegister[0] … myRegister[ n]  than with myRegister_0 …
myRegister_ n.
The following table describes SystemC-related guidelines.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
312</p>
</section>
<section id="page-313">
<h2>Page 313<a class="headerlink" href="#page-313" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Table 72: SystemC-Related Rules
Rule ID
Rule Description
7.2
Always make sure all SCML, TLM, or SystemC objects are given a name.
This name is preferably the same as the C++ object. This improves legibility and debugability
of the code.
7.3
When using sc_core::sc_time variables, it is best to construct these only one time and
reuse them in the component behavior.
Constructing sc_time  objects is an expensive operation for speed. It is important to avoid
constructing these objects each time you need them.
7.4
To finish a simulation always use sc_stop().
Never use exit(). The exception to this rule is the case that an error condition is triggered in
the model that forces an immediate exit to avoid the model to coredump or to misbehave.
7.5
Initialization of output ports should be done at end of elaboration.
Pin ports communicate through signals. These are separate objects that are instantiated
separately. To be certain that the signal has been constructed, the initialization of output pins
should happen at end of elaboration.
7.6
Retrieve the clock period of clocks at or after the end of elaboration.
Clocks are connected through signals, similar to the input and output pins. This means the
information about the actual SystemC clock or SCML clock that is connected to an input clock
port is only known at the end of elaboration. It is best to store the clock period in an internal
variable since the construction of sc_time  objects is expensive; so this value can only be
initialized at or after the end of elaboration.
7.7
Writing to pins and signals from callbacks.
It is possible and advised to assign a value to an output pin or a signal from within a callback.
There is no need to use a separate SystemC thread to do this. In RTL coding styles, signals
and pins should be assigned from a single source to avoid multi-driver conflicts. The RTL
simulator gives an error when multiple threads or methods assign the same signal. This
ensures that in the actual hardware that is modeled, logic is present to decide what the final
value for this signal should be. This rule does not apply in virtual prototype models and the
simulator does not issue an error when this happens.
8.4. Synchronization and Modeling for Speed
The modeling style presented in this manual provides a standardized approach to create models for
virtual prototype simulations. The intent of the guideline is to present an easy-to-use approach that
delivers on the speed requirements for virtual prototype models, so that the developer can concentrate
on making sure the model is functionally complete, has the right timing accuracy and is register
accurate. The FT modeling style that has been presented is created to lead to models that deliver on
the simulation performance requirements. However, it should be expected that simulation performance
always needs to be a key consideration when creating models. Besides that there is always a reason
to look for further speed optimization. The goal of this section is to provide some background and
guidance so that a virtual prototype model can be further optimized for speed.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
313</p>
</section>
<section id="page-314">
<h2>Page 314<a class="headerlink" href="#page-314" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
•
LT Centric Simulation Techniques Overview
•
Debugging Temporally Decoupled Systems
•
Modeling Fast Target and Router Peripherals
•
Optimizing Simulation Performance for FT Models
8.4.1. LT-Centric Simulation Techniques Overview
D
M
I
i
n
f
r
a
s
t
r
u
c
t
u
r
e
The first speed optimization available in TLM2.0 and the Synopsys SystemC simulation kernel is a
Direct Memory Interface (DMI) infrastructure. This infrastructure basically provides the initiators with a
direct backdoor access to all storage elements in the system (memories, registers). As explained in the
IEEE Std 1666TLM-2.0 standard, an initiator can request to get immediate access to the storage within
the target for simple storage accesses (read and write). The TLM2.0 infrastructure provides with means
for the target to enable and disable this direct access. An interconnect component should forward the
DMI requests.
In a virtual prototype model, it should be possible to configure the interconnect model to be as simple
as an address decoder. Even in that case, the overhead of TLM function calls for communication is too
big for high-speed simulations. So this is definitely an issue when using more refined bus models with
more accuracy, for example, when adding more interconnect components to increase the accuracy of
the functionally that is modeled or when adding more accurate timing information in the model.
So to have a configuration mode that takes full advantage of the speed optimization, the bypassed
models (buses, transactors) should not consume any simulation time in idle mode. This can be
achieved by an event-driven modeling style or by applying model gating, that is, disabling the clocks in
idle mode, or as is done with the SCML2 clock objects: simply by de-registering the callback methods
for the clock or by not triggering them.
At any time, it should be possible to switch between the speed-optimized simulation mode and the full
simulation mode. The speed-optimized simulation mode uses the fast backdoor access to the target,
while the full simulation mode simulates the complete detail of the bus transaction. It is only useful to
switch from optimized mode to full simulation mode to run fast through some initialization sequence
and then switch to a more accurate simulation mode. Switching from full mode to optimized mode is not
useful since typically it is unsafe because of unfinished transactions stored in the buffers of buses and
transactors.
The switch of the simulation mode can be initiated from the SystemC debugging tools VP Explorer and
SystemC Shell:
•
In VP Explorer
Right-click on the system in the SystemC Design Browser (this is the root element for the design)
and from the popup menu, select either Switch to full simulation mode or Switch to speed-optimized
simulation mode (depending on the current simulation mode).
SystemC Modeling Library Reference Manual
X-2025.06-SP1
314</p>
</section>
<section id="page-315">
<h2>Page 315<a class="headerlink" href="#page-315" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
•
In SystemC Shell:
◦
To switch the abstraction level to full simulation mode, call:
::scsh::set_full_simulation_mode
◦
To switch the abstraction level to speed-optimized simulation mode, call:
::scsh::set_speed_optimized_simulation_mode
On its own, the DMI would not have a big impact on the simulation speed. The full potential can
only be realized in combination with temporal decoupling. Together, the two techniques reduce the
interaction of the platform model with the SystemC kernel to the absolutely required minimum.
t
e
m
p
o
r
a
l</p>
<p>d
e
c
o
u
p
l
i
n
g
a
n
d</p>
<p>s
y
n
c
h
r
o
n
i
z
a
t
i
o
n
t
e
m
p
o
r
a
l</p>
<p>d
e
c
o
u
p
l
i
n
g
d
e
f
i
n
i
t
i
o
n
The DMI infrastructure provides a high-speed communication mechanism, which bypasses all
SystemC interconnect models. This alone does not yield high simulation speed as the ISS is
activated for every single instruction by the SystemC scheduler. In many cases it is not required
for a platform simulation to have this rather accurate temporal granularity. A processor reads and
writes to memory most of the time, without any impact on any other hardware block in the system, so
there is no need to synchronize at every clock cycle, instruction, or transaction. The frequency with
which software running on a processor synchronizes with the software on other processors or with
the hardware in the system is much more infrequent than a clock cycle. To take advantage of this,
temporal decoupling has been defined and standardized in TLM2.0.
s
y
n
c
h
r
o
n
i
z
a
t
i
o
n
a
n
d</p>
<p>t
e
m
p
o
r
a
l</p>
<p>d
e
c
o
u
p
l
i
n
g
A conventional way of building a SystemC simulation is to have a block synchronizing with the rest
of the system at the granularity of a clock cycle or individual instructions. The benefit of this is that all
internal state and I/O of all hardware blocks is synchronized at each clock cycle or each transaction.
In the following figure this is shown by the red arrows.
Figure 92: Clock-Cycle-Based Synchronization as in Full Simulation Mode
A typical implementation of this is to have an SC_METHOD  or SC_THREAD  process, which is sensitive to
an external clock signal. The process is activated by the SystemC scheduler on the raising edge of the
clock signal, executes one control step of the ISS, and suspends. In the context of temporal decoupling,
such an ISS is called fully synchronized with the SystemC scheduler, because the local time in the
ISS is always identical with the global SystemC time. In general, a SystemC process synchronizes
with the SystemC kernel by calling wait()  in case of an SC_THREAD  or next_trigger()  in case of an
SC_METHOD.
To improve the simulation speed, TLM2.0 standardizes temporal decoupling. This is implemented in
the fast ISSes in the Synopsys Virtualizer. As shown in figure Figure 93, the concept of a quantum
is introduced, that is, the simulation kernel allows the ISS to run a certain amount of time without
synchronizing with the SystemC scheduler. This means the SystemC thread containing the ISS
executes so many instructions and only at the end of the quantum calls a SystemC wait. During the
SystemC Modeling Library Reference Manual
X-2025.06-SP1
315</p>
</section>
<section id="page-316">
<h2>Page 316<a class="headerlink" href="#page-316" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
execution of such a quantum, the ISS basically runs ahead of the global SystemC time. The quantum
in the example of figure Figure 93 is assumed to be only four clock cycles, but the default duration in a
real simulation is in fact 10,000,000 ns.
q
u
a
n
t
u
m
d
e
f
i
n
i
t
i
o
n
q
u
a
n
t
u
m
d
y
n
a
m
i
c</p>
<p>a
d
j
u
s
t
m
e
n
t
The quantum is a global value for the whole simulation and it is maintained by the quantum keeper.
In many cases this could be a fixed value indicating the system-level synchronization for a certain
platform and the software running on it. Therefore, it is possible to configure the value for the quantum
for a certain simulation run. To improve on this concept, the Synopsys simulation engine introduces a
quantum that is controlled by the simulation kernel. When starting a new quantum period, the kernel
can make sure that the quantum is smaller than or equal to the time to the next scheduled event in the
kernel. This allows to automatically size the quantum with for example the period of a timer. On top of
that, the quantum terminates before the default duration is elapsed under the following conditions:
•
The default duration of the quantum is expired. This is as in the default TLM2.0 definition.
•
A SystemC event occurs.
Note:
This refers to the point in time, where the SystemC kernel activates the process(es), which is
(are) sensitive to the event. It does not refer to the notification of the event, that is, the point in
time where a model calls the notify() method of the event (see B.70 and B.75 of [IEEE-1666]).
•
A peripheral component, which requires synchronization, is accessed. This is as in the default
TLM2.0 definition.
Whenever the quantum is “broken” by any of the preceding conditions, a new quantum starts with the
default size or until the next known event. By the support to break a quantum whenever a SystemC
event occurs, the Synopsys simulation engine removes the need to determine the size of the quantum
before running the simulation. Typically, such a SystemC event is a timer interrupt being signaled or
some other system-level event that otherwise should be calculated by the user and passed to the
simulation.
The example shown in the following figure assumes that a SystemC event occurs after two cycles into
the second quantum. This forces all ISSes in the platform to synchronize with the SystemC scheduler,
because it may affect the software running on the ISSes. This may for example be the case if the event
occurrence causes the firing of an interrupt. This way the quantum dynamically resizes to align with the
system-level synchronization points.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
316</p>
</section>
<section id="page-317">
<h2>Page 317<a class="headerlink" href="#page-317" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Figure 93: Temporal Decoupling with an Occurrence of a SystemC Event After Instruction 6
The dynamic quantum is very important to enable a correct simulation. On the other hand, the breaking
of the quantum by any event occurrence can have a serious impact on the simulation speed. One
careless use of a clocked component forces the quantum’s length to be one clock cycle, which
completely ruins the simulation speed. You are strongly advised to use notifications of SystemC events
with great care and avoid them whenever possible.
s
y
n
c
h
r
o
n
i
z
a
t
i
o
n
s
y
n
c
h
r
o
n
i
z
i
n
g</p>
<p>b
e
h
a
v
i
o
r
As explained with the interrupt controller example in Modeling an Interrupt Controller, the
synchronization property is specified with the callbacks of the registers. By default, a callback should
be specified as AUTO_SYNCING. This means that before and after the callback the quantum is broken,
or in other words, the SystemC time and the local time is synchronized (so local time is 0; the initiator
is no longer running ahead of the SystemC simulation). AUTO_SYNCING  ensures that in a callback it is
possible to:
•
Query the SystemC time, for example by using calls to sc_time_stamp()
•
Read and write SystemC signals
•
Use the notify()  methods of SystemC events
The synchronization ahead of the callback ensures that queries of the SystemC time return a correct
value, as a read from a signal gives its most up to date value. By synchronizing after the callback,
any writes to SystemC signals is updated for all other initiators to see. The same is true for the event
notification.
Alternatively, it is possible to set the synchronization of a callback to SELF_SYNCING. In this case,
no automatic synchronization is implemented. It is possible to implement the synchronization at any
point in the callback by calling wait()  with the local time as parameter. This enforces synchronization
between SystemC time and local time; it is important to reset the local time parameter to 0  after such
a call. The local time is the parameter that is passed as an argument to the transport and read/write
callbacks.
When no synchronization is needed at all, the synchronization option NEVER_SYNCING  can be used to
provide better legibility of the code.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
317</p>
</section>
<section id="page-318">
<h2>Page 318<a class="headerlink" href="#page-318" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
8.4.2. Debugging Temporally Decoupled Systems
t
e
m
p
o
r
a
l</p>
<p>d
e
c
o
u
p
l
i
n
g
e
x
a
m
p
l
e
s
This section discusses temporal decoupling by means of example scenarios.
t
e
m
p
o
r
a
l</p>
<p>d
e
c
o
u
p
l
i
n
g
m
u
l
t
i
p
r
o
c
e
s
s
o
r</p>
<p>e
x
a
m
p
l
e
Special care is required when using temporal decoupling in a multiprocessor system. This is illustrated
in the example shown in the following figure, assuming a default quantum that is much larger than 500
ns.
Figure 94: Temporal Decoupling in a Multiprocessor System: Scenario 1
As shown in the Figure 94:</p>
<ol class="arabic simple">
<li><p>ISS1  executes for 500 ns in a temporally decoupled mode and then triggers a hardware block that
wants to write an interrupt for ISS2  in an AUTO_SYNCING  callback. As a result, the quantum for ISS1
terminates before the access to the hardware block happens and ISS1  synchronizes by calling
wait(500ns).</p></li>
<li><p>The SystemC kernel immediately activates ISS2  with a reduced quantum of 500 ns (there is an
event scheduled at 500 ns; so the quantum size is limited to that point). The ISS runs in temporally
decoupled mode and then synchronizes.</p></li>
<li><p>After 500 ns, the SystemC kernel reactivates ISS1, which performs the access to the peripheral in
the AUTO_SYNCING  callback. The behavior inside the callback writes the SystemC signal and after
the callback, ISS1  again terminates its quantum by calling inc()  and sync()  (which amounts to a
wait(sc_zero_time)).</p></li>
<li><p>The SystemC kernel activates ISS2, which handles the signal at the correct time and then executes
for the duration of the next quantum.
In this case, everything works as expected. However, the sequence of activation between ISS1  and
ISS2  is nondeterministic. Therefore, there is a 50% chance that the ISSes are activated in the opposite
order.
The following figure illustrates the scenario where ISS2  gets activated first.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
318</p></li>
</ol>
</section>
<section id="page-319">
<h2>Page 319<a class="headerlink" href="#page-319" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Figure 95: Temporal Decoupling in a Multiprocessor System: Scenario 2
As shown in the above figure:</p>
<ol class="arabic simple">
<li><p>ISS2  executes for the duration of the default quantum and then synchronizes with SystemC time.
The default quantum is 10,000,000 ns.</p></li>
<li><p>ISS1  executes for 500 ns and then triggers the AUTO_SYNCING  callback. Like in figure Figure 94,
ISS1  synchronizes by calling wait(500ns). However, in this case ISS2  has already executed up to
10,000,000 ns, so its next activation continues from that point forward.</p></li>
<li><p>After 500 ns, the SystemC kernel activates ISS1, which performs the access to the peripheral with
the AUTO_SYNCING  callback. The behavior of the callback writes to the SystemC signal and ISS1
immediately yields to the SystemC kernel.</p></li>
<li><p>ISS2  remains in waiting mode, so ISS1  is reactivated and executes for the duration of the default
quantum.</p></li>
<li><p>At 10,000,000 ns, ISS2  is reactivated and only now it sees the interrupt signal.
In this second example, ISS2  reacts too late to the interrupt signal from ISS1. As a result, the system
may not behave as expected, although the platform model as well as the software running on the
platform is correct. In this case, there are a couple of ways to address this issue:
•
Reduce the default size of the quantum. This is the brute-force approach. The quantum can be
reduced to 0  to make sure the two cores run in lock-step. At this point, the software in the example
above would run correctly. Obviously, a trial-and-error approach to find a quantum value that delivers
maximal speed can be used as well. Even in the case the quantum is set to zero, it is possible that
software that runs correctly on a real system does not run on the virtual prototype. This could be due
to the relative speed of software on different cores. On average, one core could be executing more
instructions per cycle than another. This could be due to architectural differences between the two
SystemC Modeling Library Reference Manual
X-2025.06-SP1
319</p></li>
</ol>
</section>
<section id="page-320">
<h2>Page 320<a class="headerlink" href="#page-320" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
cores, but also due to differences in the memory subsystem for each core (caches, interconnect,
memory controller).
•
When a problem is identified to be caused by quantum effects due to scheduling order, it is possible
to use the virtual prototype debugging tools to enforce synchronization only for the points where the
interrupt is set. In other words, breaking the quantum for those points in the simulation where this
matters. This can be done by setting a breakpoint on the simulation time where the interrupt is set.
In the Synopsys simulation environment, a breakpoint will cause the simulation to synchronize. This
breaks the quantum.
If the exchange would not be through interrupts but in case ISS2  reads a signal through some software
access, then the peripheral access in ISS2  is by default AUTO_SYNCING. This means that it forces the
quantum to break at the point the software reads the signal. There would be a synchronization before
the callback is called. This would allow ISS1  to run forward to the same time point. ISS1  sets the signal
through another AUTO_SYNCING  callback which makes sure the updated signal value is available before
ISS2  continued with its own callback.
If these accesses are not for signals but for variables in a memory it does not make sense to make all
accesses to that memory AUTO_SYNCING. In that case it is better to reduce the size of the quantum.
However, such a case points to an unsafe approach to synchronization between the two software
applications on these processors. In real life it is very hard to predict that a variable access happens
exactly at the time required to ensure write-read order. Typically, such variables should be guarded
by a mutex or semaphore, which in turn typically relies on interrupt signals to ensure safe access.
If that cannot be done it is better to try to make all accesses to the memory region that contains the
semaphores AUTO_SYNCING  accesses.
q
u
a
n
t
u
m
d
e
b
u
g
g
i
n
g</p>
<p>q
u
a
n
t
u
m</p>
<p>e
f
f
e
c
t
s
d
e
b
u
g
g
i
n
g</p>
<p>q
u
a
n
t
u
m</p>
<p>e
f
f
e
c
t
s
Unfortunately, some of the issues introduced by temporal decoupling are hard to pin down.
For example, a callback which is incorrectly registered as NEVER_SYNCING  can be easily overlooked. In
fact, the simulation may still behave correctly until a change in the platform or a change in the random
order of initiator activations suddenly unearths the problem. In this situation, the problem is typically
very hard to detect since the occurrence is completely unrelated to the actual reason. In the same way,
the multiprocessor corner case described in Debugging Temporally Decoupled Systems can be hard to
make out.
Still, there are several strategies to detect simulation issues due to temporal decoupling:
•
Check that all behavior registered through callbacks on memory-mapped devices is set to
AUTO_SYNCING. Revert all suspicious NEVER_SYNCING  or SELF_SYNCING  accesses to AUTO_SYNCING.
This slows down the simulation performance of the platform, but may point out the synchronization
problem that exists in the model.
•
A simple approach that does not require to inspect every callback in the system is to simply run the
simulation with quantum set to zero. If this works correctly, there is a good chance that there is some
synchronization problem. The simulation performance impact of this approach is, however, huge.
•
Each temporally decoupled core provides a method called show_optimized_accesses(). This
gives you the complete list of memory regions, which are accessed through DMI.
•
Running the simulation with quantum set to zero sometimes takes too long. In this case, the default
quantum period can be gradually reduced. This can be done in VP Explorer using the set_quantum
SystemC Modeling Library Reference Manual
X-2025.06-SP1
320</p>
</section>
<section id="page-321">
<h2>Page 321<a class="headerlink" href="#page-321" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
command. For detailed information, see “set_quantum” in the VP Explorer Tcl Interface Reference
Manual.
•
Another approach in case running the system with quantum set to zero takes too long is to
selectively disable optimized accesses for a suspicious region. This can be done in VP Explorer. To
do so, right-click on a memory in the Register view and then select Backdoor Access from the popup
menu to disable it. For detailed information, see the section “Controlling the Simulation Mode and
Backdoor Accesses” in the VP Explorer User Guide.
8.4.3. Modeling Fast Target and Router Peripherals
r
o
u
t
e
r</p>
<p>p
e
r
i
p
h
e
r
a
l
s
,</p>
<p>m
o
d
e
l
i
n
g
t
a
r
g
e
t</p>
<p>p
e
r
i
p
h
e
r
a
l
s
,</p>
<p>m
o
d
e
l
i
n
g
This section discusses the detailed modeling guidelines for target and router peripherals.
S
C
M
L</p>
<p>c
a
l
l
b
a
c
k</p>
<p>l
e
v
e
l
s
c
a
l
l
b
a
c
k
s
t
y
p
e
s
As explained in LT Centric Simulation Techniques Overview, the type of the callback on an SCML target
object (memory, reg, router) determines the simulation speed overhead for accessing this object.
Depending on the frequency of accesses, a too conservative callback can seriously limit the overall
simulation speed.
The following table associates rough speed level with each type of peripheral access. The three right-
most columns give the functional and synchronization features of each type of access that determine
the speed impact. As the speed impact increases, the speed-level numbering increases.
The “Synchronization over the Bus” column refers to the type of interconnect model used. By
preference, virtual prototypes use an LT memory-mapped model to interconnect the peripherals to
the initiator. An LT interconnect is a simple address decoder without any additional synchronization,
whereas AT or cycle-accurate interconnect models infer some or many additional synchronization points
in the simulation to model for example arbitration.
Table 73: SCML Access Levels
Speed
Level
Type of Access
Synchronizat
ion over the
Bus
Synchronizat
ion Required
Behavior
Attached to the
Memory
1
DMI pointer access
No
No
No
2
NEVER_SYNCING  callback
No
No
Yes
3
AUTO_SYNCING  callback
No
Yes
Yes
4
Bus Access over non-LT bus
Yes
Yes
Yes
•
Speed level 1 is by far the fastest peripheral access. In this case, the initiator gets access to the
internal storage of the peripheral through the DMI APIs and no user-defined behavior is invoked.
This corresponds to a target object without callbacks. The speed is not affected by the number of
interconnect nodes or the type of interconnect node; also the router objects do not have an impact
on this. As long as the DMI request is enabled throughout the whole path from initiator to target
object there will be a direct access to the storage of the target object.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
321</p>
</section>
<section id="page-322">
<h2>Page 322<a class="headerlink" href="#page-322" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
•
Speed level 2 is the case for a NEVER_SYNCING  callback where no additional synchronization points
are set inside the behavior. NEVER_SYNCING  is in essence the same as SELF_SYNCING  but through
the name the user shows the intent that no wait()  calls is used in the implementation. In this case,
where the interconnect model is still an LT address decoder, no synchronization is implemented
for the peripheral access. Since behavior is attached to the target object, it is required to create a
TLM2.0 payload and a set of TLM calls need to be made to get to the target peripheral. As a result,
the access to a level-2 peripheral is up to 50 times slower than accessing a level-1 storage object.
•
Speed level 3 refers to peripherals with a AUTO_SYNCING  callback attached to the target objects.
The access to a level-3 peripheral requires synchronization before and after the call is made. Each
synchronization infers a context switch of all ISS initiators in the system, so the simulation speed is
another factor 20 slower than at speed level 2.
Note:
This is the default and preferred setting for callbacks on target objects. Therefore, it is important
to investigate whether some of these can be reverted to speed level-2 accesses.
•
Speed level 4 refers to virtual prototype models where the interconnect model is not a simple LT
address decoder but a more complex AT or cycle-accurate bus model. To increase the timing
accuracy of these models, additional synchronization points are implemented inside the bus model
so that an access from initiator to target infers a multitude of synchronization points. These typically
has more speed impact than the additional synchronization of an AUTO_SYNCING  callback. Such a
model is another factor 10-100 slower than the speed level-3 model. Therefore, it is very important
for fast virtual prototypes to use an LT address decoder instead of a more accurate bus model.
Obviously, there are many peripherals in a complete virtual prototype model and the impact of an
individual peripheral should be weighted with the frequency of accesses to that peripheral. Imagine the
case of a platform model with an accurate bus that supports DMI and where only one out of one million
accesses are done over the bus (so all other accesses are DMI pointer accesses). Then the speed
impact of that single level-4 access still brings down the total simulation speed significantly but when
compared to a platform where all accesses are level-4 accesses it seems infinitely faster.
As described in LT Centric Simulation Techniques Overview, callbacks on target objects are by default
AUTO_SYNCING. This modeling guidelines manual promotes to use this as a default since it is the safest
approach to get the expected behavior. At the same time, LT Centric Simulation Techniques Overview
shows that a NEVER_SYNCING  callback has much better simulation performance. The main benefit of
an AUTO_SYNCING  callback is that it ensures that all initiators in the system have had the chance to
catch up to the current local time in the running initiator, and that SystemC time is updated to the current
initiator time (that is, local time is now 0). There is still the chance that one or more initiators are further
ahead in their local time.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
322</p>
</section>
<section id="page-323">
<h2>Page 323<a class="headerlink" href="#page-323" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
AUTOSYNCING
c
a
l
l
b
a
c
k
s
A
U
T
O
_
S
Y
N
C
I
N
G
A
U
T
O
_
S
Y
N
C
I
N
G</p>
<p>c
a
l
l
b
a
c
k
In general, it required to stick to AUTO_SYNCING  callbacks whenever the correct execution of the
behavior requires a synchronized system. In the following cases, a AUTO_SYNCING  callback should be
used:
•
The behavior queries the global SystemC time using sc_time_stamp()  or sc_simulation_time().
In case NEVER_SYNCING  would be used, these functions would return the SystemC time at the
beginning of the current quantum (that is, they do not take local time into account).
•
The behavior reads from an scml_counter  object using get_count(), read(), or the ()  operator.
Since the return value of these methods is computed based on the global SystemC time, the effect
would be the same as in the previous point.
•
The behavior reads from or writes to sc_signal  or any other primitive SystemC channel. Writing
to a primitive channel in a NEVER_SYNCING  callback would only update the projected value. As a
result, readers of the primitive channel would only see the new value after the update()  function of
the primitive channel has been called by the SystemC kernel, which is only after the quantum has
expired.
•
The behavior notifies an event. This operation updates the state of the event queue in the SystemC
kernel and therefore requires the current thread to yield (that is, call wait()). Only then the
SystemC kernel processes the notified event correctly. Same as above, an event notification inside a
NEVER_SYNCING  behavior would only be taken into account after the current quantum expires.
•
When the behavior has synchronizing semantics, an example is a semaphore register. At first
glance, the default behavior of an scm2::reg  perfectly models a register. However, the semaphore
semantics of this register require that every access to this register happens at the correct SystemC
time, so that other accesses to the semaphore are correctly handled.
•
The behavior uses the post(), post_read(), or post_write()  methods of the scml_post_port.
This rule is a consequence of the rule on notifying an event since the implementation of these
methods notifies the end_event  of the scml_transaction  object.
•
The behavior calls the transport()  method of scml_post_port. Unlike the post_methods listed
in the preceding lists, the transport()  method of scml_post_port  does not notify any events and
does not have any other side-effects. However, any component called through this transport()
method could have synchronizing behavior and since the transport()  call does not have a timing
parameter, it is required to synchronize with the rest of the system before calling transport.
SELF_SYNCING
c
a
l
l
b
a
c
k
s
S
E
L
F
_
S
Y
N
C
I
N
G
S
E
L
F
_
S
Y
N
C
I
N
G</p>
<p>c
a
l
l
b
a
c
k
It is safe to use SELF_SYNCING  callbacks in the following cases:
•
The behavior calls wait(). By calling wait(), the behavior effectively has become a synchronizing
behavior itself so there is no need to use AUTO_SYNCING. Whenever wait()  is called, the local time
should be passed as an argument to the wait()  call to make sure local time and SystemC time
are correctly aligned. The timing argument of the wait call may further be incremented with any
additional delay that needs to be modeled. After the wait()  call, the local time parameter should be
reset to 0.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
323</p>
</section>
<section id="page-324">
<h2>Page 324<a class="headerlink" href="#page-324" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
•
When the behavior calls the b_transport()  call on an initiator socket. As the timing parameter is
forwarded, any behavior further in the call chain can correctly synchronize.
•
With any APIs that take a timing parameter to support temporal decoupling. These could be
available from convenience sockets that come with extended TLM2.0 protocol definitions.
As mentioned before, in case of doubt, a callback should be registered as AUTO_SYNCING  to ensure the
correct execution of the functionality.
NEVER_SYNCING
c
a
l
l
b
a
c
k
s
N
E
V
E
R
_
S
Y
N
C
I
N
G
N
E
V
E
R
_
S
Y
N
C
I
N
G</p>
<p>c
a
l
l
b
a
c
k
Use NEVER_SYNCING  behavior whenever the behavior never requires synchronization. This requires that
the behavior complies to both of the following rules:
•
The behavior is not AUTO_SYNCING.
•
The behavior is not SELF_SYNCING.
For example:
•
The behavior does not use any SystemC constructs and does not have synchronizing semantics.
This applies to all purely arithmetic blocks like hardware accelerators.
•
The behavior only accesses scml2::memory  or scml2::reg  objects.
s
i
m
u
l
a
t
i
o
n</p>
<p>s
p
e
e
d
,</p>
<p>s
t
r
a
t
e
g
i
e
s</p>
<p>f
o
r</p>
<p>o
p
t
i
m
i
z
i
n
g
o
p
t
i
m
i
z
i
n
g</p>
<p>s
i
m
u
l
a
t
i
o
n</p>
<p>s
p
e
e
d
,</p>
<p>s
t
r
a
t
e
g
i
e
s
This section discusses a number of additional strategies to optimize for simulation speed.
•
Optimize the most frequently accessed peripheral first.
This means that the memory that is accessed most frequently should have the lowest speed level.
The practical application of this simple rule requires some knowledge about the system and should
be generalized to all accesses to a peripheral.
A simple example illustrates this idea: Imagine a peripheral that has three registers: A, B, and C.
The behavior of the peripheral is that register C  always contains the sum of A  and B. There are two
options to model this:
◦
This can be modeled by adding a NEVER_SYNCING  write callback to registers A  and B  so that on
every write to these registers the value of C  is updated. Register C  does not need a callback.
◦
An alternative approach is to have a NEVER_SYNCING  read callback on C  where every time C  is
read, A  and B  are added and stored in C.
Depending on the number of times A, B, and C  are read or written, one alternative is better than the
other. This decision may depend on the system context.
•
Use read/write callbacks whenever it is possible to differentiate read behavior from write behavior.
The SCML memory object offers the following kinds of callbacks:
◦
The transport callback gives access to all attributes in the TLM2.0 generic payload.
◦
The read and write callbacks are essentially a convenience shortcut which give access to a
limited set of attributes.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
324</p>
</section>
<section id="page-325">
<h2>Page 325<a class="headerlink" href="#page-325" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
There is basically no difference in simulation speed if you use either a transport callback or both
read and write callbacks of the same speed level. A speed advantage can be achieved if the
speed level for read and write can be different. For example, if a component behaves as plain
storage for read accesses but for write accesses there is some behavior implied then it is better
to implement a write callback if possible. Using a transport callback to model such a component
would be unnecessarily slow. Only having a write callback ensures that DMI is still enabled for read
accesses. All default behaviors (as write_only, ignore_access, and so on) are also implemented
using callbacks with NEVER_SYNCING  synchronization.
•
Use dynamic registration and removal of callbacks.
One more strategy to optimize simulation speed is to adjust the speed level of the callback during
simulation time. An example is shown in the watchdog timer (see Modeling a Watchdog Peripheral),
where the behavior of the module changes so that certain registers get simple storage behavior in
certain modes. In the example, callbacks are removed and reregistered when needed, providing
a simulation-speed improvement for the cases when callbacks are removed since DMI pointer
accesses will be allowed in that case. In a similar way, callbacks can be registered to change from
NEVER_SYNCING  to AUTO_SYNCING, for example, when the register models a serial buffer that needs
to synchronize with the rest of the system every 512 accesses. In this case, the callback will keep
track of the number of accesses and switch itself to AUTO_SYINCING  when the update needs to
happen.
Note:
Registration and removal of callbacks are in itself expensive operations so a careful trade-off has
to be made.
8.4.4. Optimizing Simulation Performance for FT Models
This section provides an overview of the simulation infrastructure.
s
i
m
u
l
a
t
i
o
n</p>
<p>m
o
d
e
s
O
p
t
i
m
i
z
i
n
g</p>
<p>S
i
m
u
l
a
t
i
o
n</p>
<p>P
e
r
f
o
r
m
a
n
c
e
The SCML FT Modeling methodology is built on top of SystemC. SystemC is a C++ based modeling
library with a cooperative event-driven process scheduler at its core. This means that at the core
SystemC provides with deterministic mechanisms to model the details of the concurrent hardware.
The drawback of these mechanisms is that they rely on a scheduler and process context switches.
Therefore, have a very negative impact on simulation performance. Typically, the simulation speed
of a fast standalone instruction-accurate ISS drops by more than one order of magnitude when it is
integrated into a SystemC platform.
Over time, several extensions have been added to SystemC, primarily to circumvent the process and
event based modeling basics of SystemC. This is done to improve the simulation performance so that
SystemC-based solutions can keep up with the ever increasing complexity of hardware systems. In the
first step, SystemC has been extended with Interface Method calls for communication, which is better
known and further standardized as Transaction Level Modeling (TLM). This replaces signal and event
based communication between models with interface method calls. This increases the risk for non-
SystemC Modeling Library Reference Manual
X-2025.06-SP1
325</p>
</section>
<section id="page-326">
<h2>Page 326<a class="headerlink" href="#page-326" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
determinism and the ugly debugging problems that come along with it, but this risk is low compared to
the simulation speed benefit.
In the next step the synchronization requirements to model communication between components is
further reduced. In the TLM2.0 standard, the concepts of temporal decoupling and direct memory
interface have been introduced.
Using a TLM modeling style with function calls for communication with the platform context of the ISS is
not sufficient. The overhead incurred by requiring TLM communication for every data exchange by an
ISS limits the reachable simulation speed. To enable the use of SystemC-based platforms for software
development use cases, TLM2.0 has standardized two major optimization techniques, which together
enable simulation speed of 10-500 MIPS and beyond for an entire SOC platform. The two optimizations
are:
•
DMI infrastructure
b
a
c
k
d
o
o
r</p>
<p>a
c
c
e
s
s
,</p>
<p>d
e
f
i
n
i
t
i
o
n
D
M
I
d
e
f
i
n
i
t
i
o
n
Direct Memory Interface (DMI) forwards memory requests directly from the initiator to the target.
This technique - also known as backdoor access - bypasses the complete interconnect model, which
typically comprises components like buses, bridges, and transactors.
•
Temporal decoupling
t
e
m
p
o
r
a
l</p>
<p>d
e
c
o
u
p
l
i
n
g
d
e
f
i
n
i
t
i
o
n
Temporal decoupling reduces the interaction between the platform simulation and the SystemC
scheduler. This is achieved by drastically extending the synchronization interval between the model
and the simulation kernel. A traditional model is activated by the SystemC kernel at the level of
cycles or transactions. A temporally decoupled model synchronizes with the SystemC kernel at the
level of quantums, which can last as 100,000 cycles.
Taken together, the two techniques basically turn any SystemC platform model into an LT platform
model.
These techniques can be enabled or disabled from the SCML modeling objects which in turn can be
used to configure the model in what is referred to as full simulation  mode and speed optimized
mode for a loosely-timed platform. Basically, these indicate whether an initiator initiates a TLM
communication call for each data exchange or whether it uses the DMI interface and temporal
decoupling to reach an optimal simulation speed.
TLM communication interfaces address the performance overhead of exchanging data between
components and temporal decoupling that is usually associated with loosely-timed modeling. The
FT modeling style also addresses the AT modeling style requirements where there is a need for
performance improvements due to the much finer grain synchronization. To enable the use of SystemC-
based platforms for the performance optimization and architecture exploration, use cases the SCML FT
modeling style extends two more optimization techniques available in SystemC and TLM2.0. These are:
•
Clock interfaces:
Traditional SystemC models uses a sc_clock  to model clocked behavior. This is a standard
SystemC object built on top of the event and process scheduler in SystemC. These clock objects
deliver extremely poor simulation performance. The Synopsys SystemC simulation engine
provides an improved implementation for those. However, this can be improved further through the
introduction of a clock interface that provides more information about the clock and that allows to
SystemC Modeling Library Reference Manual
X-2025.06-SP1
326</p>
</section>
<section id="page-327">
<h2>Page 327<a class="headerlink" href="#page-327" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
schedule behavior in the future. The benefit of this is that it reduces the number of processes and
events in the simulation by providing a central clock scheduler for all components that rely on the
same clock rather than reusing the basic SystemC kernel for that.
•
Timing annotation:
Basically, this technique is the same as temporal decoupling. In the TLM2.0 standard, temporal
decoupling is typically linked to the loosely-timed coding style, in the FT modeling style, timing
annotation is used in combination with a quantumkeeper, as provided for temporal decoupling. While
the granularity of temporal decoupling is much smaller there is still a performance gain to be had.
Based on the basic simulation technology described in this section, the following rules should be
considered while creating SCML FT component models moving from how to use the SystemC kernel up
to the optimization process:
•
Kernel activity:
Minimize the interaction with the process and event scheduler; this should be the first concern of any
model architecture since this is the key cause of simulation performance degradation. As already
explained, there have been several enhancements made to SystemC specifically with this goal
in mind. However, this does not imply that minimizing kernel overhead should be the number one
concern with regards to the simulation performance. Consider the following points:
◦
It is not necessary to mimic the internal parallelism and concurrency of a component. It is
sufficient to make sure that the interaction with the external world happens at the correct time
points. Parallelism and concurrency implies events and processes in SystemC, these are
only useful when there is contention; that is, several activities fighting over a resource. There
should be a synchronization point modeled only when there is a possible contention (that is, the
resource is free and there is activity) when the resource assignment schedule can be determined
for a series of activities, based on current inputs. Then, this can be used to avoid synchronization
in the SystemC kernel.
◦
Use TLM also for component interfaces that are not memory mapped. Use TLM1.0 API with a
dedicated payload or use the TLM2.0 base protocol restricted to the data pointer. This avoids
signal events and method sensitivity.
◦
When reusing code that intensively uses signal interfaces and sc_clocks, it may be worth
wrapping the code with a TLM interface and a clock gate, so that the component is only active
when there is data exchange.
◦
Use SystemC methods which are cheaper than threads; immediate notification is cheaper than
event notification or timed notification.
•
Clock scheduling:
A special case of kernel activity is incurred through clock scheduling. Traditional SystemC clocks
causes event and process overhead for every tick of the clock. In many cases, users overcome
this by not modeling the clock connectivity and revert to use a model parameter indicating the
clock period for that model and use that to schedule events which then mimic the clocked activity
in the model. This approach causes a mess when trying to mimic the clock tree of a design through
parameter settings. It makes it a nightmare when clocks are becoming programmable and even
SystemC Modeling Library Reference Manual
X-2025.06-SP1
327</p>
</section>
<section id="page-328">
<h2>Page 328<a class="headerlink" href="#page-328" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
more when optimizations for power (and therefore clock frequency scaling) become a key use case
for virtual prototypes. Therefore, the SCML2 modeling objects library provides specialized clock
interfaces to propagate the clock period to every component that needs it. Further optimizations
are possible when each component registers their clocked behavior with a central clock scheduler,
thus avoiding event and process overhead by the SystemC kernel for each of the components in
the design. Furthermore, this modeling approach also allows the central clock scheduler to keep
track of any period changes for the clock during temporal decoupling and to reschedule the callback
requests accordingly. Obviously, this last feature has a performance overhead since additional
checks and calculations are required for each callback that is scheduled. The key guideline for
clocks is to use the SCML2 modeling objects and then to apply the previous rule to minimize the
clock based activity.
•
TLM calls:
TLM calls model the communication between components. Each TLM call needs to be forwarded
over the memory and interconnect infrastructure even if these components do not modify or use
any of the information provided with the call. This is one of the reasons to come up with the TLM2.0
Direct Memory Interface. While using TLM calls it is important to minimize the number of transport
calls to implement the communication. The following are the different ways to achieve this:
◦
The most efficient TLM interface is the blocking transport interface since it has only two timing
points for a data transfer of arbitrary length and it is implemented with a single interface method
call. Therefore, it is the preferred API for the loosely-timed modeling style where speed is most
important. However, it can also be used for the approximately-timed coding style. The possible
drawback is that it must be called from a sc_thread, which is more expensive than methods.
And more importantly, when a transaction needs to be converted from a non-blocking transport
interface to the blocking transport interface, a sc_thread  needs to be added in the conversion
which adds additional synchronization overhead. Conversion from the blocking interface to the
non-blocking interface is cheaper since there is no additional thread and synchronization required
than would typically be incurred when using a non-blocking interface to start with. A component
can limit itself to only support the blocking interface in the following cases:
▪
An initiator that only needs the two timing points supported by the blocking API, or it can
use the API for the transactions for which this timing information is sufficient. Typically, the
speed improvement will be very limited since most likely the blocking interface needs to be
converted to a non-blocking interface somewhere in the interconnect path.
▪
A target for which it is sufficient to model the latency behavior. Also, here the speed
improvement is limited due to the conversion overhead that is likely to be there.
In both cases however, the simplified coding style is a reason to expect improved performance
(less code, so simpler to maintain and optimize).
◦
When using the non-blocking interface, there are typically a number of calls required to complete
a transaction. Usually, there is a complete set of calls defined that allow full timing accuracy for
all possible protocol state transitions and delays of a certain protocol, for example, they enable
to exchange data on a beat per beat for burst transactions. The key speed improvement here
is to do as few as possible TLM interface calls. The definitions of the protocol state machines is
such that they provide with shortcuts to skip states if they happen to be on the same timing point
SystemC Modeling Library Reference Manual
X-2025.06-SP1
328</p>
</section>
<section id="page-329">
<h2>Page 329<a class="headerlink" href="#page-329" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
or when they do not provide any meaningful accuracy improvement for initiator or target. These
shortcuts should be used whenever possible.
◦
One additional way of reducing the number of protocol states required to execute a transaction
is to use the TLM2.0 base protocol. This protocol has four timing points for the non-blocking
interface. When this provides all features to model the timing of a component, then the TLM2.0
base protocol should be used. When used in combination with other components that use a
more detailed protocol engine, protocol conversion is inserted. This reduces the potential for
speed improvement. The protocol state conversion adds the code that would be needed in case
all components used the detailed protocol; but there also is an additional conversion logic to
convert the attributes. When used in combination with the SCML storage objects that conversion
is anyway needed.
•
Use DMI:
DMI is a key TLM2.0 speed improvement feature. It should be used as much as possible and should
be made switchable so that less and more accurate modes are enabled. A DMI handler can be
protocol specific or even component specific to make sure that there is a maximum number of DMI
calls done. DMI is typically limited to the loosely-timed coding style but should be considered for the
AT case as well. Whenever a blocking call makes sense it is also useful to consider whether the full
interconnect path can be skipped using a DMI access. DMI allows for a latency parameter which can
be used to identify start and end of the transaction. Still there might be an accuracy impact when
doing this which should be considered in the evaluation: the impact of resource contention in the
interconnect is not taken into account.
•
Use temporal decoupling:
This is a specific variant of minimizing kernel activity by using timing annotation in the TLM interface
calls to model timing rather than to use process and event synchronization for every time advance.
Temporal decoupling is the key to the performance of loosely-timed simulations. In the FT modeling
style, timing annotation or temporal decoupling should be used whenever possible.
•
Configurability:
Have an LT/AT abstraction switch. Models should be configurable to run at different abstraction
levels. The timing accuracy of a simulation relates to the internal accuracy of the model as well
as the timing accuracy of the communication interface it is using. For ease of use and overall
consistency, each model should be aware of its own accuracy. This means that it should determine
what level of timing accuracy it enables and in which way it wants to initiate transactions or wants
to respond to them. The alternative where a model uses the abstraction of the incoming transaction
request to determine the timing accuracy it provides is acceptable, but tends to be lean to less
accuracy than you would expect. Transactions that are handled with less accuracy do not only
impact their own timing accuracy but also the accuracy of the following transactions.
More configurability can be added for complex models, so that the simulation performance can
be optimized for the specific use case, although typically an on/off switch for accuracy should be
sufficient. A model should only provide support to switch on accuracy one time, the complexity to
support a switch from accurate to less accurate is too high compared to the very limited use cases
where it can be used. This complexity is caused by the handling of timed transactions that are in
SystemC Modeling Library Reference Manual
X-2025.06-SP1
329</p>
</section>
<section id="page-330">
<h2>Page 330<a class="headerlink" href="#page-330" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
flight at the moment the accuracy is turned off, additional modeling is required to make sure an
inaccurate transaction overtakes a more accurate one.
•
Use profiling tools:
Despite the advises discussed above, the best approach to optimize performance is to profile the
models, preferably exercised in a realistic context and focus on the specific performance bottlenecks
of the model itself.
◦
Use the SystemC debugging tools to the following:
▪
Check the number of activations of threads or the number of event notifications.
▪
Validate whether the DMI configuration is done correctly.
▪
Check the number of TLM interface calls that are done.
◦
Use generic C++ profiling tools to check the computational overhead for the model.
Use this to validate the results of the SystemC debugging tools in context of the overall performance.
One of the factors that affect the performance of a SCML2 based system is the overhead of the frequent
calls to the nb_transport_fw()  and nb_transport_bw()  functions of the FT (TLM2.0) interface of the
models.
For example, consider an SCML2 FT AXI  based system. In the FT AXI  protocol, a sixteen beat read
transaction requires a minimum of seventeen calls to the TLM2.0 nb_transport (fw/bw)  functions,
when all the timing points of the transaction are to be modeled.
This can cause a substantial speed degradation, especially when the communicating components have
multiple intermediate blocks and each call is routed through all these blocks.
To mitigate this, the FT methodology allows skipping protocol states to gain on simulation
performance, for example, for the read transaction above, a target can send all the data using a single
nb_transport_bw()  call with the protocol state set to RVALID_LAST. While using a single call results
in a significant improvement in simulation performance, it causes a loss of timing information for the
individual beats of the transaction.
Data beat timing arrays allow model developers to reap the benefits of state skipping while retaining
the timing information on their FT interface. Using data beat timing arrays the sender of the data can
indicate the timings of the individual beats of data with a single call to the nb_transport_(fw/bw)
function on its FT interface.
SCML2 Payload Extensions for Using Data Beat Timing Arrays
This section describes the data beat timing array specific extensions as well as convenience macros
that have been provided for their use.
Two array type extensions have been defined to allow components to communicate the start
and end times of the individual data beats of a transaction using a single nb_transport_fw()  or
nb_transport_bw()  call. These extensions contain an array of unsigned integers, where each entry of
the array is the offset in number of clock cycles from sc_time_stamp() + time (annotated time of
the nb_transport_fw/bw() call).
SystemC Modeling Library Reference Manual
X-2025.06-SP1
330</p>
</section>
<section id="page-331">
<h2>Page 331<a class="headerlink" href="#page-331" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
•
data_beat_avail_extension
DECLARE_ARRAY_EXTENSION(data_beat_avail_extension, unsigned int);
◦
This extension is used by the sender of the data (initiator for writes and the target for reads) to
indicate the best effort availability time for each beat of data that it has to send for a transaction.
◦
The individual entries in the array should be interpreted by the receiver as the offset in clock
cycles from the sc_time_stamp () + t  at which the nb_transport_fw/bw()  call is made.
•
data_beat_used_extension
DECLARE_ARRAY_EXTENSION(data_beat_used_extension, unsigned int);
◦
This extension is used by the receiver of the data to indicate the time at which each beat of data
is consumed.
◦
The individual entries in the array should be interpreted by the sender of the data as the offset
in clock cycles from the sc_time_stamp () + t  at which the nb_transport_fw/bw()  call is
made.
The semantics for the use of data beat arrays (see General Rules for the Use of Data Beat Arrays)
mandate that each transaction must go through a handshake process in the address phase to
determine if the receiver of the data to honor data beat timing arrays. This per transaction handshake
ensures that data beat timing arrays are used only in the cases where the receiver of the data agrees
that to process the same.
The following extension is used for the mentioned handshake procedure.
•
can_accept_data_beat_array_extension
DECLARE_EXTENSION (can_accept_data_beat_array_extension, bool, false);
◦
This is an extension of type bool , and it must be set to true by the receiver of the data to
indicate that it can accept data beat timing array for the particular transaction.
◦
The default for this extension is false  and it is imperative that it is set before the data phase (if
any) of the transaction.
◦
The sender of data must not use data beat timing array for the transaction in case the extension
is set to false  by the receiver.
Note:
The can_accept_data_beat_array_extension  is just a hint from the receiver of the data
to the sender, to indicate that it can process data beat timing array. The initiator is free to not
use data beat arrays even if the extension is set to true.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
331</p>
</section>
<section id="page-332">
<h2>Page 332<a class="headerlink" href="#page-332" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Convenience Macros for Array Type Extensions
As explained in earlier in this section, the use of data beat timing requires adding and modifying payload
extensions that contain an array of unsigned integers.
The following macros have been provided to define, set and retrieve the extensions that contain arrays.
An extension containing an array can be defined using:
DECLARE_ARRAY_EXTENSION(ext_name, attr_type)
The parameters for this macro are:
•
The name of the extension.
•
The type of the array.
For example: DECLARE_ARRAY_EXTENSION(my_array_extension, int);  defines an extension that
consist of an array of integers.
The following convenience macro can be used to add an array type extension to a payload, or to
change the valid count of an array type extension that is already present with the payload.
SET_ARRAY_EXT_ATTR(payload_ptr, ext_name, attr_type, array_ptr, valid_count);
This macro takes the following parameters:
payload_ptr
Specifies pointer to the payload for which the extension needs to
be added or modified.
ext_name
Specifies the name of the array extension.
attr_type
Specifies the type of the array.
array_ptr
This returns the pointer to the start of the array.
valid_count
Specifies the number of valid entries in the array.
Usage:
The following demonstrates how this macro can be used to set the array size of
data_beat_avail_extension.
ft_generic_payload* trans;
SET_ARRAY_EXT_ATTR(trans, scml2::data_beat_avail_extension, unsigned int,
beat_array_ptr, 8);
•
The macro adds the data_beat_avail_extension  extension to the payload, if it does not exist
already.
•
This timing array gets automatically resized in case, the extension existed already and the original
valid count was less than the count specified.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
332</p>
</section>
<section id="page-333">
<h2>Page 333<a class="headerlink" href="#page-333" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Note:
The memory management for the array is done in the extension class itself.
The following convenience macro can be used to retrieve the array and the number of valid entries
in the array type extension.
GET_ARRAY_EXT_ATTR(payload_ptr, ext_name, attr_type, array_ptr, valid_count);
This macro takes the following parameters.
payload_ptr
Specifies the pointer to the payload for which the extension is to be retrieved.
ext_name
Specifies the name of the extension that needs to be retrieved.
attr_type
Specifies the type of the array.
array_ptr
This returns the pointer to the start of the array.
valid_count
This returns the number of valid entries in the extension.
Usage:
The following demonstrates how the macro can be used to get start of the array as well as the
number of valid entries in the array.
ft_generic_payload* trans;
GET_ARRAY_EXT(trans, scml2::data_beat_avail_extension, unsigned int,
beat_array_ptr, num_entries);
•
The number of valid entries gets stored in the num_entries  variable.
•
The start of the array is stored in an beat_array_ptr  variable which is of type unsigned  int*.
Note:
In case, the extension does not exist, the number of valid entries is set to 0. This implies that
the data beat semantics are not being used by the sender and the data beat array should not be
accessed.
General Rules for the Use of Data Beat Arrays
This section enumerates some rules which must be followed in case data beat arrays are being used by
FT based models.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
333</p>
</section>
<section id="page-334">
<h2>Page 334<a class="headerlink" href="#page-334" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
•
It is mandatory for the receiver of data to indicate that it can accept data beat arrays for the data
phase using the can_accept_data_beat_array_extension.
•
The can_accept_data_beat_array_extension  should be set to true  only when it is found in the
transaction payload. The receiver should use the standard TLM2.0 get_extension()  API, for this
extension to determine its presence in the payload.
•
Prior to starting the data phase, the sender must check the
can_accept_data_beat_array_extension  and should use data beat array semantics only if the
extension is set to true.
Using data beat arrays to transfer a part of the total data is not allowed. For instance, for a sixteen
beat burst, the sender cannot send two data transfers for the data phase each using a data beat
array of size eight.
•
The size of the data_beat_avail_extension  must always be set to the total number of beats in the
transaction.
•
The first entry in the data_beat_avail_extension  must always be 0. This helps to avoid
unnecessary manipulation of the data beat timing array in case the data phase is stalled for some
reason.
•
A receiver capable of handling data beats should use the valid count of the
data_beat_avail_extension  to determine whether data beat semantics are being used or not. A
value of 0  for this attribute indicates that the data beat arrays are not being used. This can happen in
case, the sender decides not to use data beat timing arrays even when the receiver hints that it can
accept the data beat arrays.
•
The valid count of the data_beat_used_extension  should always be set to the count retrieved from
the data_beat_avail_extension.
•
The receiver is not allowed to accept a subset of total beats using the data_beat_used_extension.
•
The values in the data_beat_avail_extension  indicate best effort availability of data. While
populating the data_beat_used_extension, the receiver should also account for the back-pressure
that may get created due to the data acceptance delays. The following may be used by the receiver
in case the data transfer is to be completed without synchronization.
for (unsigned int i = 0; i &lt; valid_count; i++)
{
if ( i == 0 )
{
data_used [i] = data_avail [i] + data_accept_delay;
} else {
data_used [i]  = ( data_avail [i] &gt; data_used [i-1] ) ? data_avail [i] +
data_accept_delay
:   data_used [i -1] + 1+
data_accept_delay;
}
}
•
In case the receiver wishes to synchronize and change context before sending the data
acknowledgement, it must set the first entry in the data_used_time_exetension  to 0.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
334</p>
</section>
<section id="page-335">
<h2>Page 335<a class="headerlink" href="#page-335" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
This section covers the FT GFT specific semantics for the use of data beat arrays.
Data Beat Array Handshake
The first step of the data beat array approach is the handshake between the initiator and the target
regarding the use of data beat arrays using the can_accept_data_beat_array_extension. For FT
GFT transaction, this handshake must happen during the CMD phases namely, the RD_CMD  and the
WR_CMD  phases.
Note the following points in this context with regards to read and write transactions respectively.
•
For a write transaction, the initiator must explicitly set the value of the extension to false, before
sending the WR_CMD. The target on receiving the WR_CMD  checks for the presence of this extension
and if it is present, sets it to true  or falsedepending on its behavior.
•
For a read transaction, the initiator must initialize the can_accept_data_beat_array_extension
appropriately by setting it to either true  or false  explicitly, before sending the RD_CMD.
Transaction State Machine for Write Transactions
The following figure depicts the protocol state machine for a write transaction when the data beat arrays
are used.
Figure 96: GFT State Machine for Write Accesses Using Data Beat Arrays
The state machine is a subset of the one shown in Figure 23 where the initiator is also allowed to send
the WR_DATA  states.
Observations on the state machine:
•
The initiator on receiving the WR_CMD_ACK  must set the protocol state to WR_DATA_LAST. The
data setup delay should be accounted for in the annotated time and the first entry in the
data_beat_avail_extension  should be set to 0.
•
Target on receiving the WR_DATA_LAST  state should look for the data_beat_avail_extension  and if
present should populate the data_beat_used_extension  keeping in mind its data-accept delays.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
335</p>
</section>
<section id="page-336">
<h2>Page 336<a class="headerlink" href="#page-336" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Transaction State Machine Read Transactions
The following figure depicts the protocol state machine for a read transaction when the data beat arrays
are used.
Figure 97: GFT State Machine for Read Accesses Using Data Beat Arrays
This state machine is a subset of the one shown in Figure 23, which also allows the target to send
RD_DATA  protocol states.
Observations on the state machine:
•
The target is allowed to skip the RD_CMD_ACK  phase and move directly to the RD_DATA_LAST  phase.
•
In case the target wishes to exercise path
in the state machine, the RD_CMD_ACK  is assumed to
be implicit and the time at which it is received should be taken as the sc_time_stamp() + t.
•
Moreover for path
, the address-accept  delay if any should be accounted for using the
annotation. The rule that the first entry in the data_beat_avail_extension  should be 0  must be
followed.
•
The target can also chose path
, where it wants to send an explicit RD_CMD_ACK  phase. In that
case, it must start the RD_DATA_LAST  from a different SystemC context.
•
On receiving the RD_DATA_LAST_ACK, the target must look for the data beat array specific extensions
in the payload so that it marks the free time of the GFT read channel correctly.
This section covers the FT AXI  specific semantics for the use of data beat arrays.
Data Beat Array Handshake
For the FT AXI  protocol, the handshake between the initiator and the target regarding the use of data
beat arrays must happen during the address phases of a transaction, namely, the ARVALID  and the
AWVALID  phases.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
336</p>
</section>
<section id="page-337">
<h2>Page 337<a class="headerlink" href="#page-337" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Note the following points in this context with regards to read and write transactions respectively.
•
At the start of a read transaction (that is, the ARVALID  phase) the initiator must initialize this
extension appropriately by setting it to either true  or false  explicitly.
•
At the start of the write transaction (that is, AWVALID  phase) the initiator must set the value of the
extension to false. The target on receiving the AWVALID  checks for the presence of this extension
and if it is present sets it to true  or false  depending on its behavior.
Transaction State Machine for Write Transactions
The following figure depicts the protocol state machine for a write transaction when the data beat arrays
are used.
Figure 98: FT AXI State Machine for Write Accesses Using Data Beat Arrays
This state machine is a subset of the one shown in Figure 23, which also allows the initiators to send
WVALID  protocol states.
Observations on the state machine:
•
The initiator on receiving the AWREADY  must set the protocol state to WVALID_LAST. The
data setup delay should be accounted for in the annotated time and the first entry in the
data_beat_avail_extension  should be set to 0.
•
Target on receiving the WVALID_LAST  state should look for the data_beat_avail_extension  and if
present should populate the data_beat_used_extension  keeping in mind its data-accept  delays.
•
On receiving the WVALID_LAST  state, the target can choose path
to advance the state machine
of the transaction and send an explicit WREADY_LAST  state.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
337</p>
</section>
<section id="page-338">
<h2>Page 338<a class="headerlink" href="#page-338" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
•
In case the target sends an explicit WREADY_LAST, the target would need to send a BVALID  using a
new SystemC context.
•
Alternatively, the target can also choose to skip WREADY_LAST  state altogether and send directly
move on to the BVALID  state using path
.
•
The target must populate the data_beat_used_extension  even when it is skipping the
WREADY_LAST  state.
•
The time at which BVALID  is sent should be calculated as sc_time_stamp () + t + used_array
[last_beat-1].
◦
In such a scenario, it is the responsibility of the initiator to extract the timing information from the
data beat array and transfer it to the time annotation while sending the BREADY.
◦
In other words, it is incumbent on the initiator to transfer the timing information from the data beat
array into the timing annotation after the data phase of the transaction is handled.
Transaction State Machine Read Transactions
The following figure depicts the protocol state machine for a read transaction when the data beat arrays
are used.
Figure 99: FT AXI State Machine for Read Accesses Using Data Beat Arrays
This state machine is a subset of the one shown in Figure 23, which also allows the target to send
RVALID  protocol states.
Observations on the state machine:
•
The target is allowed to skip the ARREADY  phase and move directly to the RVALID_LAST  phase.
•
In case the target wishes to exercise path
in the state machine, the ARREADY  is assumed to be
implicit and the time at which it is received should be taken as the sc_time_stamp() + t.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
338</p>
</section>
<section id="page-339">
<h2>Page 339<a class="headerlink" href="#page-339" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
•
Moreover for path
the address-accept  delay if any should be accounted for using the
annotation. The rule that the first entry in the data_beat_avail_extension  should be 0  must be
followed.
•
The target can also chose path
where it wants to send an explicit ARREADY  phase. In that case, it
must start the RVALID_LAST  from a different SystemC context.
On receiving the RREADY_LAST, the target must look for the data beat array specific extensions in the
payload so that it marks the free time of the FT AXI read channel correctly.
8.5. Getting Started
With the Virtualizer releases, there are a number of examples provided for the FT modeling coding
style. There are examples for models that use a pure LT TLM2 base protocol interface, which focuses
on the usage of the storage objects, there are also examples that introduce the GFT and AXI protocol
definitions for AT modeling. These examples can be found at $SNPS_VP_HOME/…/any/examples/
TLM2ModelingExamples/  location.
g
e
t
t
i
n
g</p>
<p>s
t
a
r
t
e
d
To introduce the coding style and modeling objects, this section explains some examples. The focus is
on the modeling guidelines for LT modeling with the TLM2 base protocol. There is also an introduction
to how components can be tested. Each construct is explained in detail when first introduced; later
examples focus on the additional constructs that are used in these examples.
•
Modeling a Memory
•
Modeling an Interrupt Controller
•
Modeling a Watchdog Peripheral
•
Modeling a DMA
•
Modeling a Cache
•
Example Timer Specification
8.5.1. Modeling a Memory
m
e
m
o
r
y
,</p>
<p>m
o
d
e
l
i
n
g
m
o
d
e
l
i
n
g</p>
<p>a</p>
<p>m
e
m
o
r
y
,</p>
<p>e
x
a
m
p
l
e
e
x
a
m
p
l
e
s
m
o
d
e
l
i
n
g</p>
<p>a</p>
<p>m
e
m
o
r
y
In this first example, the focus is on the use of the core language primitives of SCML, TLM2.0, and
SystemC to create a model. These are introduced using a memory model and a test component for the
memory.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
339</p>
</section>
<section id="page-340">
<h2>Page 340<a class="headerlink" href="#page-340" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The simplest possible component to model using SCML is a plain memory. Since the SCML memory
objects implement all the TLM2.0 interface features and the storage behavior, their code is limited to
instantiating and connecting the SCML memory object. The code looks as follows:
The labeled code fragments are explained as follows:
1 Header files
Any component should include the SCML, TLM, and SystemC header files. With these three header files, all
modeling constructs, interfaces, and objects from SCML, SystemC, and TLM2.0 are available.
NOTE: The SystemC, TLM2.0, and SCML2 libraries use namespaces and prefixes:
• All SystemC objects have an sc_  prefix and are defined in the sc_core  namespace.
• All TLM2.0 objects have a tlm_  prefix and are defined in the tlm  namespace.
• SCML objects do not have a prefix and are defined in the scml2  namespace.
2 Class definition
In SystemC, components are modeled as C++ classes that derive from the generic component model
sc_module. In this case, the module defines an ExampleMemory.
3 Sockets
The memory should be able to receive communication requests from other components in a system. Therefore,
a member is added to the module: tlm::tlm_target_socket&lt;32&gt; socket. The integer template parameter
indicates the width of individual data elements that pass through the socket; in this case 32 bits wide.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
340</p>
</section>
<section id="page-341">
<h2>Page 341<a class="headerlink" href="#page-341" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
4 Memory and adapter
1.In the private  section at the bottom, two more members are defined for the memory component.
2.There is an adapter object to interface the generic payload carried through the socket to the internal storage
of the memory (scml2::tlm2_gp_target_adapter&lt;32&gt; mAdapter).
3.There is the storage itself (scml2::memory<unsigned int> mMemory).
4.The template parameter for the adapter is 32 , and should be the same as for the socket. The template
parameter for the memory indicates the behavioral representation for the data elements of the memory. This
indicates how the data is used in expressions. The size of the C++ data type used should be equal to the
bitwidth of the socket and adapter. For the list of supported C++ data types, see Memory Objects.
5 Module constructor
1.The constructor for the module initializes the different members.
2.The constructor takes an argument sc_core::sc_module_name name, so that each instantiation of this
module can be given a name. The name is passed to the constructor of the sc_module  base class.
3.The socket is given a name, so that sockets can be identified in debugging tools.
4.Next, the adapter is initialized with a name and it is connected to the socket of the module.
5.Finally, the memory is initialized with a name and a size. The size of an SCML memory is specified in units
of the data type specified. Here unsigned int  is used while the size of a memory is typically defined in
address space, which is usually defined in byte. This is why the size of the memory is shifted down by 2  to
convert byte addresses into word index values.
6 Constructor body
In the body of the constructor, the memory is connected to the adapter. Through this initialization, all
communication received by the socket will be interpreted by the adapter to fit with the memory behavior and the
memory stores or retrieve the requested data.
8 Constant parameters
Whenever a constant parameter for a design is used, it is best to declare that as a constant member of the
class. In this case, the size of the memory is a constant. It is only used in one place but usually there will be
several points in the code where this parameter is needed. Obviously, these parameters are prime candidates
for parameterization through scml_property  objects, so that these values can be set through configuration
tools like Platform Creator.
To test the memory, you need a module that initiates memory-mapped transactions. An example of such
an initiator module is defined below.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
341</p>
</section>
<section id="page-342">
<h2>Page 342<a class="headerlink" href="#page-342" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
SystemC Modeling Library Reference Manual
X-2025.06-SP1
342</p>
</section>
<section id="page-343">
<h2>Page 343<a class="headerlink" href="#page-343" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The labeled code fragments are explained as follows:
1 The code defines a MemoryCheck  module.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
343</p>
</section>
<section id="page-344">
<h2>Page 344<a class="headerlink" href="#page-344" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
2 Initiator socket
The code contains an initiator socket scml2::initiator_socket&lt;32&gt; socket; this socket is part of the SCML
library. SCML has an initiator socket defined that has a simplified communication interface and also implements
a handler for the TLM2.0 DMI. This means that the socket keeps track of the memory regions for which DMI is
allowed and on every access a check is performed to see whether it is possible to retrieve the data using DMI.
3 Quantum keeper
All free-running initiators, which are components that model behavior that executes software or behavior that is
concurrent to software execution, must use a quantum keeper.
3.1: There is a quantum keeper to support temporal decoupling: tlm_utils::tlm_quantumkeeper
mQuantumKeeper. The quantum keeper will keep track of the local time in the initiator versus the global
SystemC time and will force synchronization at the rate of the global quantum.
3.2: The quantum keeper is part of the tlm_utils  namespace; so an additional header file is required.
4 Constructor
1.In the constructor of the module, the global quantum is set to 1  millisecond. SystemC defines an object
sc_time  which is used to identify time periods. Several units are defined for time: SC_MS  for milliseconds,
SC_NS  for nanoseconds (others are possible as well).
2.The quantum keeper of this module is also passed to the socket. The socket uses it to pass the local time
information along with the communication requests as is defined in TLM2.0 and synchronize if the local time
becomes larger than the global quantum.
3.The SC_THREAD(run)  macro registers the run()  method of the MemoryCheck  module to be used as a
thread in the multitasking kernel. Since the LT coding style is used in this initiator, the code that initiates
transactions must be called from a SystemC thread. In a SystemC thread it is allowed to return control to the
SystemC kernel from any point in the code; this is not possible for a SystemC method. Using a thread, it is
possible to synchronize with the SystemC kernel while processing a transaction request.
5 The run()  class method
The run()  method should implement the concurrent behavior of this module. Through the registration in the
constructor (see 4.3 above), the run()  method becomes an SC_THREAD. Typically, an SC_THREAD  models a
concurrent process that performs a task repeatedly. For that purpose, it usually contains an infinite loop. In this
case, the test should be executed only one time; therefore the infinite loop is not there.
To initiate a transaction, the read and write methods of the initiator socket are used. Both have an address  and
data  argument.
5.1: First, each of the 0x1000  elements in the memory is written to. The value stored in each location is equal
to the address multiplied by 2. This value is read back to test the memory. If the write fails, an error is printed.
Since the TLM2.0 address is a byte address and each access stores 32 bits (or 4 bytes) the address needs
to be incremented by 4  after each write. This also explains why the upper boundary for the address value
(0x4000) is four times larger than the size of the memory (0x1000).
5.2: Next, each word that was written is read back and checked. If the read fails, an error is printed; Also when
the value returned is not the same as the one that was written, an error is printed.
5.3: When modeling components for a virtual prototype, it is the initiator that controls time. So after every
access, the local time is incremented with the initiator execution time. The timing annotation in target models is
intended to model any additional delay on top of the execution time that should be expected from the initiators.
At every time increment, the quantum should be checked and a system-level synchronization should be
performed if needed. For this purpose, the timeAdvance()  method is added.
5.4: To model the initiator execution time, a period  parameter is added. This sc_time  variable is constructed
one time and reused to avoid simulation speed overhead when creating a new sc_time  object.
It is not good to write timeAdvance(sc_core::sc_time(100, sc_core::SC_NS))  since a new sc_time  object
is constructed on each invocation of timeAdvance().
5.5: The sc_stop()  call terminates the simulation.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
344</p>
</section>
<section id="page-345">
<h2>Page 345<a class="headerlink" href="#page-345" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
To run the test, the ExampleMemory  and MemoryCheck  modules are imported into Platform Creator,
connected together into a test system, compiled, and run. This section describes the procedure.
For detailed information, see the examples shared at $SNPS_VP_HOME/…/any/examples/
TLM2ModelingExamples/  location and also as the TLM2ModelingExamples  component library in
Platform Creator.
To run the memory test:</p>
<ol class="arabic simple">
<li><p>Launch Platform Creator:
pct &amp;</p></li>
<li><p>Load the ExampleMemory  and MemoryCheck  modules. To do so:
a. From the menu bar, select Project &gt; Import SystemC Modules.
Note:
Make sure that the TLM2_PL  library is opened before you take this step. To do so, on the
Definitions tab page on the left, scroll down to the TLM2_PL item, right-click on it and from the
popup menu, select Open.
The Import SystemC Modules dialog box appears.
b. Click Add to add the ExampleMemory.h  and MemoryCheck.h  files.
c. Click OK. The modules are loaded into SYSTEM_LIBRARY  (see the Definitions tab page).</p></li>
<li><p>Instantiate the two modules by dragging them from the Definitions tab page into the System
Diagram.</p></li>
<li><p>On the toolbar, click
to connect the two ports.</p></li>
<li><p>On the toolbar, click
to build and run the test.
The following figure shows the result.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
345</p></li>
</ol>
</section>
<section id="page-346">
<h2>Page 346<a class="headerlink" href="#page-346" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Figure 100: Result of the Memory Test
8.5.2. Modeling an Interrupt Controller
i
n
t
e
r
r
u
p
t</p>
<p>c
o
n
t
r
o
l
l
e
r
,</p>
<p>m
o
d
e
l
i
n
g
m
o
d
e
l
i
n
g</p>
<p>a
n</p>
<p>i
n
t
e
r
r
u
p
t</p>
<p>c
o
n
t
r
o
l
l
e
r
,</p>
<p>e
x
a
m
p
l
e
e
x
a
m
p
l
e
s
m
o
d
e
l
i
n
g</p>
<p>a
n</p>
<p>i
n
t
e
r
r
u
p
t</p>
<p>c
o
n
t
r
o
l
l
e
r
The purpose of this example is to introduce modeling of a register map, memory-mapped behavior, and
modeling of non-memory-mapped interfaces. In this example, the flow from text specification to model
testing is introduced.
The starting point for any component modeling activity is the specification for the component. In this
case, the specification looks as shown in the following figure.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
346</p>
</section>
<section id="page-347">
<h2>Page 347<a class="headerlink" href="#page-347" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Figure 101: Interrupt Controller Specification
The interrupt controller is specified as follows:
•
The interrupt controller has 32 interrupt inputs and one interrupt output. The output interrupt is active
high. The active level of the input interrupts is programmable.
•
The following tables outlines the registers by which the programming interface of the interrupt
controller is defined.
Table 74: Registers of the Interrupt Controller
Register
Description
Enable
Each interrupt input can be enabled or disabled separately through this register.
When a bit is set high, the corresponding interrupt inputs is forwarded to the
output.
Clear
When a bit is set high, the corresponding bit in the RawIrq  register is cleared; this
clears that interrupt from the output.
ActiveHighNotLow
When a bit in this register is set high, the corresponding input is active high; else
it is active low.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
347</p>
</section>
<section id="page-348">
<h2>Page 348<a class="headerlink" href="#page-348" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Register
Description
Status
Each bit in this register indicates whether the corresponding input is active and
enabled.
Each bit in the Enable, Clear, ActiveHighNotLow, and Status  registers corresponds to the
interrupt with the same number.
•
The following table shows how the memory map is defined.
Table 75: Memory-Map Specification of the Interrupt Controller
Address
Type
Width
Name
0x000
Read-Write
32
Enable
0x004
Read-Write
32
Clear
0x008
Read-Write
32
ActiveHighNotLow
0x00C
Read-only
32
Status
•
The interrupt controller also has two internal registers:
◦
RawIrq, which indicates the interrupt inputs that are currently active.
◦
LatchedIrq, which indicates the active interrupts that are not cleared.
These registers are not visible in the memory map.
•
The output interrupt is active high and is set whenever one of the input interrupts is active and
enabled.
Before writing any code, it is important to define the approach that is taken to create a model for a
component. The modeling approach determines how the behavior of the component is mapped to the
SCML and SystemC modeling objects.
The modeling approach for the interrupt controller is as follows:
•
There is a need for a memory-mapped interface and also an interface for the interrupt pins.
•
The register set is modeled with SCML objects.
•
The behavior of the component can be modeled through the callbacks that can be associated with
the SCML registers.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
348</p>
</section>
<section id="page-349">
<h2>Page 349<a class="headerlink" href="#page-349" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
•
A SystemC process is required to model the independent or concurrent behavior of the interrupt
controller. The callbacks on the registers are not sufficient since changes on the interrupt interfaces
also trigger changes to the registers and the output interrupt.
•
The changes to registers and outputs can be calculated without accessing a memory-mapped
socket; so it suffices to use a SystemC method, sensitive to the interrupt inputs. A SystemC method
is more efficient than a SystemC thread for simulation speed.
Based on the modeling approach information, the definition of the interrupt controller can be created:
The labeled code fragments are explained as follows:
1
The module contains a socket for the interface to the memory-mapped bus.
2
To model the interrupts, SystemC ports of type sc_in  and sc_out  are used. The template
parameter for the sc_in  and sc_out  objects indicates the data type of the values carried over
these ports, here bool  to represent a one-bit value. For the 32 interrupt inputs, an array of
pointers to input ports is defined. The pointers are used to avoid the default constructor for the
pins, which does not allow changing the name for the pins. By using a pointer, it is possible
to construct and initialize each pin with a meaningful name. The size of the array is set by a co
nstant parameter of the module class.
Note:
The SystemC modeling object sc_signal  should be used to connect sc_in  and sc_out  ports.
Signals are a SystemC construct to represent hardware at a low level. The value of a signal is
not immediately updated; it is updated only when all processes that are scheduled to run at the
current time point have finished. The execution of a SystemC process can be made sensitive to a
value change of a signal. This also means that new processes can be scheduled to run at a certain
time point as a consequence of signal value changes that happened at the same time point in
another process. Only when there are no new processes, scheduled time advances. In the SCML
methodology, signals are used to represent low-level hardware signals like interrupts and clocks.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
349</p>
</section>
<section id="page-350">
<h2>Page 350<a class="headerlink" href="#page-350" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The labeled code fragments are explained as follows:
3
To model the register interface, the memory object MemoryMap  is defined. This is the parent
object for all memory-mapped registers in the component.
4
For the individual register, scml2::reg  objects are used. The use of the register objects is
to provide easy access and to define different behavior for the different registers. The actual
storage is maintained by the MemoryMap  object, as well as the interaction with the interface of
the module.
5
For the internal registers, a separate memory called InternalRegisters  is defined. Here it
contains two additional registers RawIrq  and LatchedIrq. LatchedIrq  is a consequence of
the implementation for the behavior.
To model the behavior of the interrupt controller, the memory-mapped behavior should be specified, as
well as the concurrent behavior that is triggered on a change on one of the input interrupts. The setup
for this is done in the constructor of the model class.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
350</p>
</section>
<section id="page-351">
<h2>Page 351<a class="headerlink" href="#page-351" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The public  section looks as follows:
The labeled code fragments are explained as follows:
1 In the initialization, all objects get a name and the relation between the registers and the memory is defined.
This includes the definition of the local address map for this component.
This is done in the initialization of the register objects. The third parameter in the initialization is their index
in the array of memory elements. Since the memory map is defined in byte addresses, we need to shift the
address by 2  (or divide by 4).
2 The input interrupt pins need to be constructed and initialized in the constructor of the module since an array of
pointers is used for the input interrupts.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
351</p>
</section>
<section id="page-352">
<h2>Page 352<a class="headerlink" href="#page-352" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
3 By default, simple storage behavior is implemented by the memory and registers. To overwrite this behavior,
callbacks functions can be set for these objects.
It is possible to define different behavior for read and write accesses. Also a number of common behaviors are
available. These can be set through global functions in the scml2  namespace.
An example is scml2::set_read_only(), which disables write accesses by returning an error response on the
write transaction request.
A consequence of overwriting the default behavior of a memory or register is that accesses using DMI no
longer is possible.
4 As mentioned in the specification (see Figure 101), the behavior of the registers is specified as follows: All
registers are 32-bit registers, where each bit represents the corresponding interrupt input.
• Enable: When a bit is set high, the corresponding interrupt inputs is forwarded to the output.
• Clear: When a bit is set high, the corresponding bit in the RawIrq  register is cleared.
• ActiveHighNotLow: When a bit is set high, the corresponding input is active high.
• Status: Each bit indicates whether the corresponding input is active and enabled.
For the Enable  and Clear  register, it is required to add additional behavior through a callback. Different types
of callbacks are possible. In this example, the scml2::set_post_write_callback()  function is used to
define the callback function. The arguments of this function are the memory object and a method of the current
module which is used as callback. There is also a third argument indicating synchronization. By default, the
latter is set to AUTO_SYNCING. In this example, all callbacks are AUTO_SYNCING. Other functions exist for other
types of behavior and for the different memory objects.
The synchronization argument - when defining a callback for a register - is by default set to AUTO_SYNCING.
This means that the system synchronizes before and after calling the callback function. As a consequence,
the local time for the current initiator is zero when the callback function is called. This allows to schedule and
trigger events as well as to write to signals (for example, an output port). An alternative value for this argument
is SELF_SYNCING. This should be used for simulation speed optimization. SELF_SYNCING  can be used when the
callback contains behavior that only in certain cases (or never) requires the system to synchronize. When using
SELF_SYNCING, the local time for the initiator starting the transaction is passed as an argument to the callback,
which can use this information to synchronize the system. For callbacks that never needs to synchronize with
the rest of the system, there is also a NEVER_SYNCING  value for this argument (which is essentially the same as
SELF_SYNCING  but is provided for legibility).
5 In the constructor, the method for the interrupt input changes is defined using the SC_METHOD  macro and it
is made sensitive to all input interrupts. This is done using the sensitive &lt;&lt;  notation. A method is made
sensitive to all events and signals that are specified following the macro invocation.
6 Finally, the initial value for the registers is set.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
352</p>
</section>
<section id="page-353">
<h2>Page 353<a class="headerlink" href="#page-353" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The private  section looks as follows:
The labeled code fragments are explained as follows:
7
The output interrupt should not be initialized in the constructor as it may be writing to a signal that may
not be constructed yet. Output signals should be initialized in the end_of_elaboration()  method. This
method is part of the sc_module  base class and is called by the simulation kernel after all objects have been
constructed. The output interrupt is active high.
8
The core behavior of the interrupt controller is to compute whether the output interrupt signal should be active.
This behavior is captured in the recomputeInterrupts()  method. This method is also used as the callback
function for the Enable  register, since this value is directly related to the interrupt output. For the computation,
the LatchedIrq  register is used. The naming for this method does not follow the naming rules because it is
used both as a callback as well as a regular method.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
353</p>
</section>
<section id="page-354">
<h2>Page 354<a class="headerlink" href="#page-354" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
9
For the Clear  register, LatchedIrq  is first updated with the new Clear  value and then the output is
recomputed.
10 Whenever the value of an input interrupt changes, the onIRQInChange()  method is called. In this method,
LatchedIrq  is updated based on the value of the input pins and the active level for that pin, set in the
ActiveHighNotLow  register. This value is also stored in the RawIrq  register.
Each model requires a test setup to ensure that all features are correctly modeled. The test setup needs
to make sure that the following features are validated:
•
The memory map is correctly specified, including read/write permissions.
•
Reading and writing to the individual registers delivers the expected results.
•
All behavior scenarios that can be derived from the specification are correctly modeled.
To test an individual component, the SCML2 example library contains TclInitiator. This is an
example of an initiator targeted to test individual models. It has a TLM2.0 generic payload socket and a
flexible number of input and output pins. Most important is that it has a Tcl scripting interface targeted to
create test scripts for a model.
The Tcl interpreter is linked to the module and adds some additional Tcl commands that allow to:
•
Read and write to the initiator socket
•
Get values from input pins and set values on the output pins
•
Advance local time and manage the quantum
•
Wait for input signal changes or advance global time
The module reads commands from a script and terminates the simulation when the script is finished or
when there are no more events in the SystemC simulation. With this test infrastructure it is possible to
develop unit tests for a component using the Tcl scripting language.
For the interrupt controller, a unit test can be created, as described in the following procedure.
To run the interrupt controller test:</p>
<ol class="arabic simple">
<li><p>Launch Platform Creator:
pct &amp;</p></li>
<li><p>Open the TLM2ModelingExamples  library. To do so, right-click on TLM2ModelingExampleson the
Definitions tab page and from the popup menu, select Open.</p></li>
<li><p>Instantiate the ExampleInterruptController  module. To do so, drag ExampleInterruptController
from the Definitions tab page into the System Diagram.</p></li>
<li><p>Instantiate the TclInitiator  module. To do so, drag TclInitiator from the Definitions tab page into
the System Diagram.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
354</p></li>
</ol>
</section>
<section id="page-355">
<h2>Page 355<a class="headerlink" href="#page-355" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
5. Configure TclInitiator. To do so:
a. In the System Diagram, select the TclInitiator instance.
b. Click the Parameters tab at the bottom of the Platform Creator window.
c. Set the number of output ports to 32(to drive all the interrupt inputs of the interrupt controller).
d. Update the instance view by right-clicking on the instance in the System Diagram and selecting
Update Dynamic Port Arrays from the popup menu.
e. If required, you can change the names of the Tcl scripts that is run (initscript  and script).
6. Connect the initiator socket  with the Ctrl  socket of the interrupt controller, connect the output pins
to the IRQin  pins (make sure the indexes correspond), and connect the input pin to the IRQout  pin.
7. On the toolbar, click
to build the test.
The following figure shows the result.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
355</p>
</section>
<section id="page-356">
<h2>Page 356<a class="headerlink" href="#page-356" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Figure 102: Result of Interrupt Controller Example
To run the test, a Tcl script is required. According to the parameter settings for the constructor
arguments it should be called script.tcl. In this script, a number of procedures are defined to
access the individual registers of the memory map. These should be added to improve legibility. For
each register, a set  and get  function should be added. These functions use the readX  and writeX
commands of TclInitiator, where X  indicates the number of bytes that is read or written. The
following code shows an example.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
356</p>
</section>
<section id="page-357">
<h2>Page 357<a class="headerlink" href="#page-357" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
To access the input and output pins, TclInitiator  provides the setOutput  index value  and getInput
index  commands, where index  gives the index of the port to be used for the access.
The test itself goes through the following scenarios:</p>
<ol class="arabic simple">
<li><p>The test tries an access on all registers (read and write). This should give an error when attempting
to write to the Status  register.</p></li>
<li><p>Next, the test initializes the ActiveHighNotLow  register so that the first 16 interrupt inputs are active
high and the rest are active low.</p></li>
<li><p>Then the test tries every interrupt by enabling it, setting it, waiting for the interrupt to come in, and
clearing it again through the Clear  register.
If the test fails, this usually means that it is waiting for an event that never comes. This finishes the
simulation before the whole test is done.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
357</p></li>
</ol>
</section>
<section id="page-358">
<h2>Page 358<a class="headerlink" href="#page-358" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The remaining code for the test script looks as follows:
SystemC Modeling Library Reference Manual
X-2025.06-SP1
358</p>
</section>
<section id="page-359">
<h2>Page 359<a class="headerlink" href="#page-359" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
When running the test, the following output is generated:
8.5.3. Modeling a Watchdog Peripheral
w
a
t
c
h
d
o
g</p>
<p>p
e
r
i
p
h
e
r
a
l
,</p>
<p>m
o
d
e
l
i
n
g
m
o
d
e
l
i
n
g</p>
<p>a</p>
<p>w
a
t
c
h
d
o
g</p>
<p>p
e
r
i
p
h
e
r
a
l
,
e
x
a
m
p
l
e
e
x
a
m
p
l
e
s
m
o
d
e
l
i
n
g</p>
<p>a</p>
<p>w
a
t
c
h
d
o
g</p>
<p>p
e
r
i
p
h
e
r
a
l
In this example, the specification is derived from an actual peripheral. The key features introduced in
this example are system-level synchronization and timing modeling. These are introduced using an
example watchdog peripheral. A watchdog timer is a peripheral used to reset a system if the application
or OS freezes or has run into a failure. A watchdog timer is a counter with a programmable time-out
interface which generates an interrupt whenever the time-out is reached.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
359</p>
</section>
<section id="page-360">
<h2>Page 360<a class="headerlink" href="#page-360" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
As part of the AMBA peripheral IP delivered by Arm, a watchdog is specified (reference number:
SP805). A model of this component is delivered as part of the Synopsys Primecell Model Library. The
specification can be found on the website of Arm (www.arm.com). The watchdog described in this
section is a simplified version of that component. The specification looks as shown in the following
figure.
Figure 103: Watchdog Timer Specification
The functionality of the watchdog timer is specified as follows:
•
The watchdog counts down at the rate of a clock input, starting from a value stored in the load
register. When the counter reaches zero, an interrupt is sent and the counter restarts. When the
counter reaches zero again, a reset signal is set. The counter can be cleared through the interrupt
clear register.
•
The following table outlines the interface of this component.
Table 76: Interface of the Watchdog Timer
Name
Description
AMBA APB
Memory-mapped interface (APB in this case).
WDOGCLK
Clock input.
WDOGINT
Interrupt output. It is active high.
WDOGRES
Interrupt-reset output. It is active low.
•
The following tables outlines the registers and bitfields by which the programming interface of the
watchdog timer is defined.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
360</p>
</section>
<section id="page-361">
<h2>Page 361<a class="headerlink" href="#page-361" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Table 77: Registers of the Watchdog Timer
Register
Description
WdogLoad
The value written to this register sets the value for the time-out. The default is
0xFFFFFFFF.
WdogValue
Whenever this register is read, the current counter value should be returned. The
default is 0xFFFFFFFF.
WdogControl
Contains the bitfields RESEN  and INTEN  to enable the functionality of the watchdog
timer.
WdogIntClr
A write access to this register causes the counter to be stopped.
WdogRIS
Is a register that contains the raw interrupt status.
WdogMIS
Is a register that contains the masked interrupt status.
WdogLock
When the value 0x1ACCE551  is written to this register, all registers are accessible.
Any other value locks the watchdog registers. Reading the register should return
1  on lock; 0  when not locked. At reset, the registers are unlocked.
WdogITCR
Contains the ITEN  bitfield to control the integration test mode.
WdogITOP
Contains the WDOGINTBit  and WDOGRESBit  to be used in integration test mode.
Table 78: Bitfields of the Watchdog Timer
Bitfield
Description
RESEN
Is used to enable the watchdog reset outputs. It needs to be set high to enable
the reset. By default, the reset is disabled.
INTEN
Should be set high to enable the counter and the interrupt. When re-enabled, the
counter value is reloaded. By default, the interrupt is disabled.
ITEN
Is the integration test enable bit. When set high, the watchdog is set into
integration test mode.
WDOGINTBit
Is the value output on WDOGINT  when in integration test mode.
WDOGRESBit
Is the value output on WDOGRES  when in integration test mode.
•
The watchdog timer has a memory range defined of size 0x1000. The following table outlines its
register definitions.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
361</p>
</section>
<section id="page-362">
<h2>Page 362<a class="headerlink" href="#page-362" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Table 79: Register Definitions of the Watchdog Timer
Address
Type
Width
Name
0x000
Read-Write
32
WdogLoad
0x004
Read-only
32
WdogValue
0x008
Read-Write
2
WdogControl
0x00C
Write-only
WdogIntClr
0x010
Read-only
1
WdogRIS
0x014
Read-only
1
WdogMIS
0x018-0xBFC
Reserved
0xC00
Read-Write
32
WdogLock
0xC04-0xEFC
Reserved
0xF00
Read-Write
1
WdogITCR
0xF04
Write-only
2
WdogITOP
0xF08-0xFFC
Reserved
•
Bit specification
In the WdogControl  register, different bits have a special meaning, as shown in the following table.
Table 80: WdogControl Bit Specification
Bits
Type
Name
[31:2]
Reserved
[1]
Read-Write
RESEN
[0]
Read-Write
INTEN
The WdogITCR  register contains one bitfield ITEN, as shown in the following table.
Table 81: WdogITCR Bit Specification
Bits
Type
Name
[31:1]
Reserved
[0]
Read-Write
ITEN
SystemC Modeling Library Reference Manual
X-2025.06-SP1
362</p>
</section>
<section id="page-363">
<h2>Page 363<a class="headerlink" href="#page-363" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The WdogITOP  register contains two bitfields, as shown in the following table.
Table 82: WdogITOP Bit Specification
Bits
Type
Name
[31:2]
Reserved
[1]
Write-only
WDOGINT
[0]
Write-only
WDOGRES
The two bitfields specified for WdogITOP  have the same name as the output pins they drive. As it
is not possible to have several objects with the same name in C++, the name for the bitfields is
extended with the postfix Bit.
Before writing any code it is important to define the approach that is taken to create a model for a
component. The modeling approach determines how the behavior of the component is mapped to the
SCML and SystemC modeling objects.
The modeling approach for the watchdog timer is as follows:
•
The memory-mapped registers and bitfields are modeled using the SCML2 memory objects.
•
The memory-mapped interface is modeled using a TLM2.0 socket.
•
The interrupt and reset output is modeled using SystemC output pins.
•
The clock input can be modeled using an input pin. However, in general, clocks are not required
for a peripheral model for virtual prototypes as the timing is driven from the initiators and timing is
mainly used as an easy way to model system synchronization. Since the behavior depends on the
timing set by the clock, the clock input pin is required.
•
To model the behavior, SCML provides callbacks that can be associated with the register accesses.
•
The interrupt and reset output behavior cannot be modeled using callbacks on register accesses as
the interrupt and reset signals is set independent of a current register access. Their value needs to
be set at a future simulation point.
•
The obvious solution is to have a method sensitive to the clock and count down on each clock tick.
This would be very inefficient for simulation speed as this implies a process switch on every clock
cycle in the simulation model. This should be avoided at all cost.
Another approach is used in this example, which limits the number of process switches in the
SystemC simulation kernel: A SCML2 clocked_callback  is used. The callback is scheduled to
trigger at the correct time point.
This point can be calculated whenever the counter value is written. The output signals are then set
from the callback. This approach transparently handles all parameter changes of the clock, like
changes of the clock frequency or disabling and re-enabling gated clocks.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
363</p>
</section>
<section id="page-364">
<h2>Page 364<a class="headerlink" href="#page-364" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
•
The behavior of the lock register and the integration test registers is that they change the access
rights and behavior of other registers. To model that, each register could get a callback registered
to check whether the component is in lock mode or in integration test mode. The drawback of this
is additional complexity to manage the state machine implied by this; furthermore, it disables DMI
accesses to all registers. An alternative approach is to use dynamic registration and removal of
callbacks, which removes the need to check in every register access which state the component is
in, and allows to revert to default behavior whenever possible.
Based on the information so far, an initial skeleton for the model can be created, as shown in the
following code.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
364</p>
</section>
<section id="page-365">
<h2>Page 365<a class="headerlink" href="#page-365" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The labeled code fragments are explained as follows:
1
The module contains a socket for the interface to the memory-mapped bus. To model the
interrupt and clock signals, SystemC ports of type sc_in  and sc_out  of type bool  are used.
The reason to have a clock port is to allow this component to be used in virtual prototypes
running at different frequencies. The clock is used to schedule a callback for the clock tick,
at which the watchdog times out. This approach only works if the complete clock tree in the
design is using scml_clock  s (which is anyway advised; scml_clock  s are optimized for
speed). Clock objects are defined in SCML1, so they are not part of the scml2  namespace.
2
The MemoryMap  object represents the whole address range of the component. The individual
registers are defined using the SCML object scml2::reg. A register object is a convenience
object to refer to a single element within a memory object. Same holds for a bitfield object:
It allows access to individual bit ranges in a register and simplifies the code to manage
accesses to these bits. Bitfields are defined for the bits in the WdogControl, WdogITCR, and
WdogITOP  registers, since these bitfields can be written. In the WdogRIS  and WdogMIS, there
is a single read-only bit. No extra objects are added for those as these values can be easily
managed from within the behavior.
3
To model the time-out of the watchdog, a SCML2 clocked_callback  is defined.
4
Finally, there is a bool  variable that is used to check whether the signal that is set when the
counter reaches zero is the interrupt output or the reset output.
The setup for the modeling approach is done in the class constructor of the model. The constructor
defines the memory map for the component. It is also the place to define the callbacks for the
registers and the threads and methods for concurrent behavior. The code for the constructor is
shown in the following code.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
365</p>
</section>
<section id="page-366">
<h2>Page 366<a class="headerlink" href="#page-366" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
SystemC Modeling Library Reference Manual
X-2025.06-SP1
366</p>
</section>
<section id="page-367">
<h2>Page 367<a class="headerlink" href="#page-367" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The labeled code fragments are explained as follows:
1
All objects get a name and the register file is connected to the socket using the adapter.
For each register and bitfield, the location in the register file is specified. Finally, the internal
variables are initialized.
2
The access restrictions for the different registers are specified here as well.
3
The callback to register the behavior for the memory-mapped registers is set up through the
setAllCallbacks()  method, which is discussed below.
4
Next, the callback which is used to implement the behavior for signaling the time-out is
defined and hooked into the clocked_callback  object.
5
The final piece of code in the constructor initializes the memory-mapped storage to 0. The
registers for which a default is specified (see Modeling a Watchdog Peripheral) also are
initialized.
The setAllCallbacks()  method takes care of registering the callbacks with the memory-mapped
behavior. For the registers where an access has an impact on the further behavior of the component,
a callback is registered with the register to model this behavior. The behavior of the registers is
defined as follows (see also Modeling a Watchdog Peripheral).
WdogLoad
The value written to this register sets the value for the time-out. So on an access to
this register, a future callback needs to be scheduled to trigger the interrupt.
WdogValue
Whenever this register is read, the current counter value should be returned. Since
the counter is not updated on every clock cycle, this value needs to be calculated on
each access.
WdogIntClr
A write access to this register causes the counter to be stopped.
WdogLock
When the value 0x1ACCE551  is written to this register, all registers are accessible.
Any other value locks the watchdog registers. Reading the register should return 1
on lock, 0  when not locked.
Also for the bitfields, behavior can be added through callbacks. The specification of the bitfields is as
follows:
RESEN
Is used to enable the watchdog reset outputs. It needs to be set high to enable the
reset.
INTEN
Is used to enable the watchdog reset outputs. It needs to be set high to enable the
reset.
ITEN
Is the integration test enable bit. When set high, the watchdog is set into integration
test mode.
WDOGINTBit
Is the value output on WDOGINT  when in integration test mode.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
367</p>
</section>
<section id="page-368">
<h2>Page 368<a class="headerlink" href="#page-368" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
WDOGRESBit
Is the value output on SDOGRES  when in integration test mode.
In most cases, the read behavior is to return the current value or a predefined value for the register.
As this is the default behavior, there is no need to overwrite this through a function call. This also
makes sure that DMAs to those registers are still enabled, which guarantees that for read accesses
there is no speed impact.
Since it is required to register and remove callback behavior from the registers, the code for
registering the callbacks is moved to a couple of methods that is called from the constructor and
whenever behavior needs to be reinstated. The code for these functions is shown in the following
code.
For most of the write accesses, there is no need to change the storage behavior of the register.
However, some additional behavior should be modeled whenever a value is written to the register.
In this case, callback behavior can be added using the scml2::set_post_write_callback()
function. For the watchdog module, most of the callbacks are AUTO_SYNCING. Most behaviors
needs to schedule and/or cancel the time-out event, or set an output port for the module. Since
AUTO_SYNCING  is the default setting, it is not mentioned in the calls.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
368</p>
</section>
<section id="page-369">
<h2>Page 369<a class="headerlink" href="#page-369" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The labeled code fragments are explained as follows:
1
For the lock register, the value written is not stored. So the callback behavior is added to the
register using the scml2::set_write_callback()  function. The synchronization for the lock
register can be set to NEVER_SYNCING  since this register access has no side-effects.
2
A special case is the callback on a read access for the WdogValue  register. Since the model
does not implement an actual counter for the time-out, there is no register holding the
current counter value; this needs to be calculated on each access to the WdogValue  register.
Therefore, the callback used is set using the scml2_set_read_callback()  function, which
means that the data to be stored in the register is calculated in the behavior (as opposed to
the post_callbacks). To be able to calculate the current value of the counter, the system
should be synchronized to the SystemC time; therefore this callback is AUTO_SYNCING.
3
For the ITEN  bitfield, the behavior is to check if the model changes from a test mode into
normal mode. This should be checked before the value is stored in the bitfield. So also here it
is not possible to use a post_write_callback; therefore, a regular write_callback  is used.
The output pins of the component are initialized in the end_of_elaboration()  method. Here also,
the clock is assigned to the clocked_callback. This can only happen now, since it requires that
the clock port is already connected to the clock generator. Now where the clock and its period
parameter are defined, it is possible to request the callback for the default time-out through the
reCalculateTimeout()  method, which is shown in the following code.
The core of the behavior of the watchdog module is in the calculation of the time-out callback and
the method signaling the interrupt and reset outputs, as shown in the following code.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
369</p>
</section>
<section id="page-370">
<h2>Page 370<a class="headerlink" href="#page-370" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The labeled code fragments are explained as follows:
1
The calculation of the time-out is captured in the reCalculateTimeout()  method, which is
called whenever the time-out needs to be recalculated. The time-out is issued by a clock tick
callback that happens at the specified tick of the clock. At first, a potential former request
for a clock tick callback is canceled. Next, a new callback is requested for the case that the
watchdog counter is enabled. The future clock tick for the callback is determined by the value
of the WdogLoad  register. The argument to request_trigger()  specifies how many clock
ticks to skip before receiving the callback. Therefore a value of 0  requests the callback for the
beginning of the next clock period.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
370</p>
</section>
<section id="page-371">
<h2>Page 371<a class="headerlink" href="#page-371" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
2
The implementation of the method that is triggered on the time-out signals the interrupt or
reset output signal and sets the corresponding bitfields. The mWdogTimeoutForReset  member
variable keeps track of whether the time-out is scheduled for an interrupt output or a reset
output. In case the time-out is for interrupt, the time-out for the reset needs to be scheduled
using the reCalculateTimeout()  method.
3
As mentioned in Modeling a Watchdog Peripheral, the value for the WdogValue  register will
be calculated each time it is read. The calculation considers the difference between the tick
count for which the time-out callback is scheduled and the current tick count of the clock. Two
cases must be handled in a special way: If the timer is not enabled, then the last value of
the watchdog counter is returned, as it was saved when the timer was disabled. Next, if the
register is read from a time-out callback, and the next callback was not yet requested, then a
zero value is returned.
The callbacks on the WdogLoad, WdogValue, and WdogIntClr  registers are used to control the time-
out, as shown in the following code.
The labeled code fragments are explained as follows:
1
In the callback for the load register, the time-out is recalculated if the watchdog is enabled.
2
For the read callback on the value register, the counter value is calculated on demand, as
explained above.
3
On interrupt clear, the interrupt output is cleared and the callback is rescheduled. Also here the
state is set so that the next time-out will lead to an interrupt output.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
371</p>
</section>
<section id="page-372">
<h2>Page 372<a class="headerlink" href="#page-372" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Note:
Callbacks registered using the scml2::set_post_write_callback  method do not take
any argument and also do not have a return value. The callbacks registered using the
scml2::set_word_write_callback  method have a bool  return and take a data argument of
the same type as the register has. The bool  return value for the callback indicates an error for
the word access. These callbacks imply that only word accesses are allowed for this register;
subword or byte accesses returns an error. Other callback registration functions allow registering
callbacks that can handle subword accesses as well.
When the INTEN  bitfield is written, the watchdog can be disabled. In that case, the time-out must be
canceled. When the watchdog is reenabled after disabling it, the time-out restarts. The code looks as
follows:
The behavior of the lock register requires that no register can be accessed except for the lock
register itself. To model this, all callbacks can be removed and for the complete memory range, all
accesses are set to be ignored. This means no updates are allowed. When accesses are unlocked
by writing the correct value to the lock register, callbacks are reset and accesses to the memory
range are allowed again. The following code illustrates this.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
372</p>
</section>
<section id="page-373">
<h2>Page 373<a class="headerlink" href="#page-373" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Note:
When removing callbacks, also the read-only or write-only settings are removed (since these are
implemented through default callbacks). So only the behavioral callbacks should be removed.
The following code illustrates this.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
373</p>
</section>
<section id="page-374">
<h2>Page 374<a class="headerlink" href="#page-374" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Finally, there is the code for the integration test mode, as shown in the following code. This is similar
to the code for the ITEN  enable register and the lock register. When the watchdog is in integration
test mode, the callbacks for the registers that should not be used for integration test are removed
SystemC Modeling Library Reference Manual
X-2025.06-SP1
374</p>
</section>
<section id="page-375">
<h2>Page 375<a class="headerlink" href="#page-375" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
and they are restored when the watchdog exists from integration test mode. In the callbacks for the
WDOGINTBit  and WDOGRESBit  bitfields, the corresponding output signals are set.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
375</p>
</section>
<section id="page-376">
<h2>Page 376<a class="headerlink" href="#page-376" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
8.5.4. Modeling a DMA
D
M
A
m
o
d
e
l
i
n
g
m
o
d
e
l
i
n
g</p>
<p>a</p>
<p>D
M
A
,</p>
<p>e
x
a
m
p
l
e
e
x
a
m
p
l
e
s
m
o
d
e
l
i
n
g</p>
<p>a</p>
<p>D
M
A
The example in this section is not derived from an actual peripheral, but is intended to show the
modeling approach to create models for components that initiate transactions in a system. The example
also introduces the use of parameters to create configurable models. The example component is a
Memory Access (DMA), as this is a typical component for a system while still different from a pure
initiator like a processor. A DMA is a device that allows moving data from one memory to another while
allowing the software on a processor to continue to operate. A DMA is programmable through some
registers and it behaves as an initiator in the system to move the data around. To return control to the
software, it emits an interrupt.
The specification looks as shown in the following figure.
Figure 104: DMA Specification
The DMA is specified as follows:
•
The DMA example has three different interfaces: One interface to allow software to program the
data transfers, a second interface to initiate the data transfers, and an interrupt output that is used
to signal back to the processor executing software. Further, the DMA example has a clock pin. The
following table outlines the specification for the pins of this example.
Table 83: Interface of the DMA
Name
Description
DMADATA
Interface for data transfers
DMAREGS
interface to access the memory-mapped registers of the DMA
DMAIRQ
interrupt output
Clk
Clock input
SystemC Modeling Library Reference Manual
X-2025.06-SP1
376</p>
</section>
<section id="page-377">
<h2>Page 377<a class="headerlink" href="#page-377" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
•
The programming interface for the DMA is specified through the DMAREGS  interface, which provides
access to the configuration registers of the DMA. The memory range of this simple DMA is 0x18  and
the internal registers are defined as shown in the following table.
Table 84: DMA Specification
Address
Type
Width
Name
0x000
Read-Write
1
DmaEnable
0x004
Read-only
1
DmaStatus
0x008
Write-only
n/a
DmaIrqClr
0x00C
Read-Write
32
DmaSize
0x010
Read-Write
32
DmaSrcAddr
0x014
Read-Write
32
DmaDstAddr
•
As this is a simple DMA, only one DMA access can be programmed at any time. The following table
shows the use for the different registers.
Table 85: Registers of the DMA
Register
Description
DmaEnable
Indicates a request to start a DMA transfer from the software. This register is only 1 bit
wide, but can be accessed through a regular 32-bit access. This means only the first bit
contains an actual value.
DmaStatus
Is used by the DMA to reflect the output interrupt status. This register is only 1 bit wide.
DmaIrqClr
Is used to clear the output interrupt. The value of this register has no meaning.
DmaSize
The register should be programmed to contain the size of the data transfer (in bytes).
DmaSrcAddr
Should be programmed to contain the source address of the data to be copied (byte
address).
DmaDstAddr
Should be programmed to contain the destination address for the data to be copied to (in
byte addresses).
In its simplest form, a DMA has a target socket to access the configuration registers, an initiator socket
for the data transfers, and an interrupt port to signal back to the software. A thread is required to model
the data transfers as these should run independently of any register access.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
377</p>
</section>
<section id="page-378">
<h2>Page 378<a class="headerlink" href="#page-378" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
•
The behavior of the DMA module is driven from the DmaEnable  and DmaIrqClrregisters. When the
DmaEnable  register is written, a DMA transfer is started unless one is already underway, in which
case the request is ignored.
•
When a DMA transfer is finished, the interrupt output is set. To reset the interrupt value, the
DmaIrqClr  register should be written to.
•
The thread that executes the DMA transfer runs independently of the register accesses. To
synchronize between the DmaEnable  access and the thread, an event is used. The thread is
suspended until the event is notified and after finishing processing the DMA transfer the thread goes
back to sleep.
•
When doing a DMA transfer, the DMA model should store the data that is read into some local
buffer and then write it to the destination address. The size of that buffer can be fixed; in this model
the size of the buffer is made configurable. For this purpose, an scml_property  is added that
represents the size of the buffer.
•
Since this component initiates transactions independent of the software execution, there is a need
to determine the relative synchronization of the DMA transfer to the software execution. Timing is
used to implement this synchronization. Therefore, the clock input is present in this model; it allows
to get the clock period for this component and a simple delay model for initiating the individual DMA
transfers can be computed.
Note:
◦
It is possible to define a static sensitivity list for a SystemC thread (in Modeling Concepts,
sensitivity is only explained for methods). Whenever a static sensitivity is defined for a
SystemC thread, it is possible to use a wait()  call to suspend execution until the next event
in the sensitivity list is triggered. It is not possible to use a method with static sensitivity to
model the DMA transfers since you are using the blocking interface together with a quantum
keeper, which may cause additional wait calls in the implementation (for example, when
reaching a quantum boundary); this is not allowed in a method. Through the combination of
waiting for time and for the event it is possible to miss events. When the thread is waiting for
time to advance, it misses all events that were triggered during that time-span.
◦
When using scml_property  objects in models used in the virtual prototype tools, the value
for these parameters is read from a configuration file at the start of the simulation. When
loading the simple DMA model into Platform Creator, a static parameter as defined here is
recognized so that when building a system using this DMA model the size of the buffer can be
defined from within Platform Creator.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
378</p>
</section>
<section id="page-379">
<h2>Page 379<a class="headerlink" href="#page-379" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The class definition for the DMA looks as follows:
This piece of code contains the pin and port definitions. Additionally, there is the following code:
This section contains the register definitions, quantum keeper, adapter for the target socket, and the
local variables that is used in the behavior.
The labeled code fragments are explained as follows:
1
The SCML property mMaxDmaByteSize  is defined as an unsigned int  and is used to define
the size of the mData  array for the local data.
2
mClockPeriod  is used to keep track of the clock period for this block, so that a correct delay
can be calculated for each transaction.
3
mBusy  is a flag that indicates whether an DMA transfer is currently busy.
4
The mStartDmaEvent  event is used to start the DMA transfer from the register callback.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
379</p>
</section>
<section id="page-380">
<h2>Page 380<a class="headerlink" href="#page-380" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The constructor and destructor for the module look as follows:
SystemC Modeling Library Reference Manual
X-2025.06-SP1
380</p>
</section>
<section id="page-381">
<h2>Page 381<a class="headerlink" href="#page-381" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The labeled code fragments are explained as follows:
1
In the constructor, the memory map is defined and all ports and sockets get a name. The
module has a quantum keeper for the initiator socket and an adapter for the target socket.
2
The DmaSize, DmaSrcAddr, DmaDstAddr  registers can be modeled using the default SCML
storage behavior, so no callbacks are registered. Potentially, it would be possible to restrict
accesses to word-only accesses, but this is ignored in this example. The DmaStatus  register
has default read behavior but write accesses should be disabled. The DmaEnable  and
DmaIrqClr  each need a callback to enable the DMA transfer and to clear the interrupt output.
The callbacks are autosyncing; one triggers the sensitivity of a thread and the other writes to
an output signal.
3
For the actual data transfers, an SC_THREAD  is registered with the kernel.
4
The destructor is needed to clean up the local storage for the DMA transfers which is created
in the constructor based on the mMaxDmaByteSize  property.
The additional behavior of the DMA that needs to be specified is fully captured in the callbacks for
the register accesses and the method that is registered as thread:
The labeled code fragments are explained as follows:
1
When the DmaEnable  register is written, the DMA transfer is started by notifying the
mStartDmaEvent  event. Whatever value is written, the value 1  is stored in the register. Before
doing this, the status of the DMA is checked using the mBusy  flag. If a transfer is busy, the
event will not be notified and no new DMA transfer is enabled. When using this DMA, it is the
programmer’s responsibility to first check the DMA enable value before starting a new DMA
transfer.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
381</p>
</section>
<section id="page-382">
<h2>Page 382<a class="headerlink" href="#page-382" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
2
When the DmaIrqClr  register is written, the DMAIRQ  output is cleared, whatever its value was.
Also the DmaStatus  register is cleared (value zero is written). This means that here it is the
programmer’s responsibility to check the DmaStatus  register before clearing the IRQ output of
the DMA.
The code for the thread is as follows:
SystemC Modeling Library Reference Manual
X-2025.06-SP1
382</p>
</section>
<section id="page-383">
<h2>Page 383<a class="headerlink" href="#page-383" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The labeled code fragments are explained as follows:
3
The behavior of the thread is concurrent to the execution of software and an unknown number
of DMA transfers has to be executed; so the thread contains a while  loop that can run an
infinite number of iterations. Each iteration starts by waiting for the static sensitivity of the
thread. In this case, this means the wait finishes when the mStartDmaEvent  event is notified.
4
On each invocation, the quantum keeper of this module is reset. This forces to recalculate the
next synchronization point. Since it is unknown when the mStartDmaEvent  event is triggered,
any previous quantum keeper synchronization event may be long passed.
5
The actual DMA transfer is implemented by using the read and write methods of the DMADATA
port. In the read access, the data is stored in the local storage (mData), which is used again
when writing. After each access, the local time is incremented and there is a check for
synchronization through the inc_and_sync()  method, which is local to this class. At every
step, there is an assert to check whether all of the boundary conditions are met (burstsize
is not bigger than array size, each access is successful). Obviously, these can be replaced
by more elaborate error checking and reporting or even an upgraded specification that would
allow the software to catch these errors.
6
After the complete DMA transfer is done, there is another synchronization with the rest of
the system through the quantum keeper. Since the inc_and_sync()  call only synchronizes
when the quantum boundary is reached, no synchronization may have been done in the
last inc_and_sync. The additional synchronization is required to make sure the complete
delay of the DMA transfer is taken into account and no new DMA transfer is started
before the previous was completed. Removing the synchronization would allow the next
mStartDmaEvent  to come before the delay was completed.
7
At the end of the DMA transfer, the DmaEnable  register is reset, the mBusy  flag is set to false,
and the interrupt is generated plus the status register is set.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
383</p>
</section>
<section id="page-384">
<h2>Page 384<a class="headerlink" href="#page-384" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
At end of elaboration, the interrupt output is initialized and the period of the clock is stored in
mClockPeriod. The code looks as follows:
The inc_and_sync()  method increments the quantum, check if you reached the quantum boundary,
and synchronize if necessary. The code looks as follows:
8.5.5. Modeling a Cache
c
a
c
h
e
,</p>
<p>m
o
d
e
l
i
n
g
m
o
d
e
l
i
n
g</p>
<p>a</p>
<p>c
a
c
h
e
,</p>
<p>e
x
a
m
p
l
e
e
x
a
m
p
l
e
s
m
o
d
e
l
i
n
g</p>
<p>a</p>
<p>c
a
c
h
e
This section describes a cache model. The goal of the example is to introduce the modeling approach
for a component that deals with memory accesses. The key SCML2 feature introduced in this example
is the router object. This example also introduces the TLM2.0 style transport callbacks for memories.
A cache is a component that provides a local copy for part of the data that is stored further in the
memory path. As such, a cache is similar to the DMA of Modeling a DMA, that is, both receive and
initiate transactions. The key difference is that a cache forwards a transaction in case no local copy is
available for the data. So the software needs to wait for the forwarded transaction to finish before it can
continue. A DMA is programmed through its memory-mapped registers to initiate transactions that copy
data from one memory to another independently from the software that is running on the core.
The specification looks as shown in the following figure.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
384</p>
</section>
<section id="page-385">
<h2>Page 385<a class="headerlink" href="#page-385" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Figure 105: Cache Specification
The cache is specified as follows:
•
The cache example has three memory-mapped interfaces: One interface to allow the software to
program the cache, a second through which the incoming transactions are routed, and an output
interface that is used to fetch data copies to be stored in the cache. The following table outlines the
specification for the pins of this example.
Table 86: Interface of the Cache
Name
Description
CACHEIN
Interface for data transfers.
CACHEREGS
Interface to access the memory-mapped registers of the cache.
CACHEOUT
Output interface of the cache.
•
The programming interface for the cache is specified through the CACHEREGSinterface which
provides access to the configuration registers of the cache. This simple cache has a single internal
register, Control  at local address 0x0, which has two bitfields which are defined as shown in the
following table.
Table 87: Bit Specification of Cache
Bits
Type
Name
0x0
Read-Write
Enable
0x1
Read-Write
WritePolicy
SystemC Modeling Library Reference Manual
X-2025.06-SP1
385</p>
</section>
<section id="page-386">
<h2>Page 386<a class="headerlink" href="#page-386" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The Enable  bitfield is used to enable or disable the behavior of the cache. In case the cache is
disabled, all transactions are forwarded to the CACHEOUT  port.
The WritePolicy  bitfield is defined as read-write. However, this is only true as the cache is
disabled. After the cache is enabled, WritePolicy  cannot be changed.
•
The cache has an internal storage where it stores a local copy of the result of every read transaction.
Whenever the same address is read again, it returns the local copy of the data. The cache
overwrites already existing local copies when a transaction comes in for an address for which the
data is not stored locally and the local storage is fully used (a cache miss). The cache keeps track of
the addresses for which a local copy is stored.
•
The behavior of the cache in case of write transactions is configurable:
◦
When WritePolicy  is set to WriteThrough, all write transactions are forwarded to the CACHEOUT
port.
◦
In case the policy is to set WriteBackAll, writes are stored locally in the cache and whenever
there is a cache miss, the data is written back to its original location.
In this simple example, the focus is on the modeling approach and the SCML2 features, so the
storage is done per byte and the cache does not support burst accesses.
The key SCML2 feature that enables a simple cache model is the router object. The main goal for
the router is to manage accesses for components that reroute transactions. In the case of a cache,
transactions either ends up in the internal storage or is forwarded to the CACHEOUT  port. All accesses
should be routed to one of these two. The management of this decision is implemented in the router
object. A router object has an API to define the mapping between incoming addresses and memory
objects or output ports. This mapping can be changed at any time. The mapping is used to route
incoming transactions. Callbacks can be associated to the router to implement transaction handling for
any address range that is not mapped. The router object does not implement any storage behavior, so
failing to forward transactions leads to transactions that are not handled at all.
The model of the cache contains a router object that implements the transaction routing for the cache
and a memory object that implements the default storage behavior for the cache storage. Next to that,
there should be a register to model the control register. The behavior of the cache in case of a cache
miss is implemented in the callback of the router.
Although the cache has an initiator port, it does not contain a quantum keeper since its behavior is not
concurrent with the execution of software.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
386</p>
</section>
<section id="page-387">
<h2>Page 387<a class="headerlink" href="#page-387" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The class definition for the cache looks as follows:
This part of the definition contains the socket definition and the parameters for the cache.
•
The mCacheLines  parameter defines the size of the local storage of the cache.
•
The mMemorySize  parameter defines the range of addresses the cache covers.
The definition of the other internals of the model looks as follows:
The labeled code fragments are explained as follows:
1
The router object is defined together with the target adapter to connect it to its socket.
2
The adapter and storage for the memory-mapped register is defined, as well as the
local storage for the cache. Obviously, no adapter is defined for the local storage since
accesses comes through the router object.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
387</p>
</section>
<section id="page-388">
<h2>Page 388<a class="headerlink" href="#page-388" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
3
std::map  is defined, which is used to keep track of the address regions that are cached
in the local storage.
The constructor of the cache looks is used to initialize all objects of the model and to set up the memory
map for the cache model. What is different in this model is the setup of the callbacks for the router
object.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
388</p>
</section>
<section id="page-389">
<h2>Page 389<a class="headerlink" href="#page-389" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The labeled code fragments are explained as follows:
1
The callback type used for the router is different from the ones in the other examples.
A router object only supports TLM2.0-style transport callbacks. Since a router needs
to make a decision on the further trajectory of an incoming transport call, the callback
should have access to the full TLM2.0 transaction payload. The callback is registered as
SELF_SYNCING  so that the syncing strategy can be further decided by the components
to which the transaction is forwarded. In case of an internal memory, no syncing may be
required, while an access over the DATAOUT  socket may lead to further synchronization.
2
A debug callback is also registered for the router object. This callback is used to handle
the debug accesses that come through the TLM2.0 interface.
In the constructor, the cache is initialized to be disabled and with WritePolicy  set to WriteThrough.
The behavior of the cache is controlled by the Enable  bitfield. The callback registered for the Enable
bitfield is used to check whether there is a change in mode for the cache. When the cache moved from
SystemC Modeling Library Reference Manual
X-2025.06-SP1
389</p>
</section>
<section id="page-390">
<h2>Page 390<a class="headerlink" href="#page-390" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
enabled to disabled state or vice versa the router mapping needs to be updated. The code for managing
the enable/disable state switch looks as follows:
The labeled code fragments are explained as follows:
1
When disabling after the cache has been enabled, the content of the cache should be written
back to the destination memory in case the write policy was set to WriteBackAll. Also the
mapping of internal to external addresses should be cleared. Further, disable functionality is
split into a separate function since that code is reused for the initialization of the cache.
2
When enabling the cache, all current mappings of the router should be removed.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
390</p>
</section>
<section id="page-391">
<h2>Page 391<a class="headerlink" href="#page-391" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
3
When disabling the cache, all current mappings of the router should be removed; typically
these are the mappings that occurred during the operation of the cache. A new mapping is
defined which forwards all requests to the output port. This ensures that the system continues
to work correctly. This mapping needs to be removed when enabling the cache.
Next is the code to maintain and update the cache contents when it is enabled. This is done in the
callback for the router object. This callback is only called for memory accesses that are currently
not mapped (cache misses). All mapped accesses is automatically forwarded. In case the cache is
disabled, the whole memory region of the cache is mapped to the output port; so the callback on the
router never is called. In case the cache is enabled, all mappings are removed, so the first accesses is
directed to the callback. In the callback, the decision is taken whether a copy for the requested access
is stored in the local memory. After the cache is full, the callback is also need to handle the replacement
SystemC Modeling Library Reference Manual
X-2025.06-SP1
391</p>
</section>
<section id="page-392">
<h2>Page 392<a class="headerlink" href="#page-392" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
strategy for the cache. In this simple example, only the current access is stored. The code for the
callback looks as follows:
SystemC Modeling Library Reference Manual
X-2025.06-SP1
392</p>
</section>
<section id="page-393">
<h2>Page 393<a class="headerlink" href="#page-393" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The labeled code fragments are explained as follows:
1
First task in the callback is to calculate the aligned address for the transaction and determine
the local address that is used in the cache. The local address is determined by the lower
bits in the address (here calculated as the remainder of CacheLines  expressed in byte
addresses).
2
In case of a read transaction, first fetch the data using the output port.
3
The pair of local address and external address is stored in CacheTags. This is done using the
insert()  method of std::map. For code simplicity, the version of the insert()  method is
used that returns a pair containing the iterator in the map where the insertion was done and a
bool  value that indicates whether an insert happened. If the bool  is false, there was already
a value stored with the same key. In this case, the key is the local address in the cache.
4
If there is already a value stored in the cache for this local address, the current stored
address should be evicted from the cache and replaced with the new request. This is done by
unmapping the old address in the router. The pairing of local address with external address is
updated in the map.
5
When the write policy is set to write back, the currently stored value in the cache should be
written back to memory.
6
When all cache management is finished, the value can be stored in the cache and the router
mapping is updated. In case the write policy is set to write through, the router should only
forward reads to the local memory. This means that writes to the external address is still
forwarded to the output port. In case the write policy is set to write back, all accesses to the
external address should be forwarded to the local storage.
7
Finally, the read transaction is finished by retrieving the data from the local memory and
setting the response for the transaction.
8
In case of a write transaction, the callback is only triggered for an address that is not
cached or in case the write policy is set to write through. For noncached write accesses, the
transaction should be forwarded to the output port. A copy of the data is stored in the local
memory in case the write policy is set to write through and the external address is cached.
The callbacks on the Enable  bitfield as well as the callback on the router object use the methods that
implement the write back.
•
The doWriteBack  function implements the write back for a single value by getting the data from the
local memory and writing it back to the real address.
•
The doWriteBackAll  function goes through the complete map of the cache and writes back every
value in the cache.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
393</p>
</section>
<section id="page-394">
<h2>Page 394<a class="headerlink" href="#page-394" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
The code for these functions looks as follows:
Finally, there is the implementation for the debug callback. In this example, the debug accesses are
simply forwarded to the output port. The assumption is that for all cached data, DMI is supported and
that debug accesses is using DMI. In that case, only uncached accesses for which the destination
memory does not support DMI is using this callback and need to be forwarded through the output port.
The code looks as follows:
Finally, one more call checks whether the cache supports a certain type of transaction and returns an
error response in case the transaction is not supported.
8.5.6. Example Timer Specification
The Example timer specification looks as shown in the following figure.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
394</p>
</section>
<section id="page-395">
<h2>Page 395<a class="headerlink" href="#page-395" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Figure 106: Example Timer Specification
The timer is specified as follows:
•
The timer counts down at the rate of a clock input, starting from a value stored in the reload register.
When the count reaches zero, and the interrupt is enabled, an interrupt is sent. If the timer is
configured as a periodic timer, it starts counting down again from the reload value after it reached
zero. The interrupt can be cleared by writing zero to the interrupt status register.
•
The following table outlines the interface of this component:
Table 88: Interface of the Example Timer
Name
Description
clk
Clock input
irq
Interrupt output. It is active high.
socket
Memory-mapped interface
•
The following table outlines the registers and bitfields by which the programming interface of the
timer is defined.
Table 89: Registers of the Example Timer
Registers
Description
ControlStatus
Contains the bitfields TimerEnable, OneShot  and InterruptEnable  to control the
functionality of the timer, and the bitfield InterruptStatus  to read out the status of
the timer.
SystemC Modeling Library Reference Manual
X-2025.06-SP1
395</p>
</section>
<section id="page-396">
<h2>Page 396<a class="headerlink" href="#page-396" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Registers
Description
ReloadValue
The value written to this register is the initial value for the timer when it is reloaded.
The default is 1000.
Counter
Whenever this register is read, the current counter value is returned.
Table 90: Bitfields of the Example Timer
Bitfields
Description
TimerEnable
Should be set high  to enable the timer. When re-enabled, the counter value is
reloaded. By default, the interrupt is disabled.
OneShot
Should be set high  to configure the timer as an one-shot timer, if set to low, the
timer is configured as a periodic timer. By default, the timer is configured to be a
periodic timer.
InterruptEna
ble
Should be set high  to enable the interrupt. By default, the interrupt is disabled.
InterruptSta
tus
Is the value output in irq.
•
The timer has a memory range defined of size 0xC. The following table outlines its register definition.
Table 91: Register Definitions of the Example Timer
Address
Type
Width
Name
0x0
RW
6
ControlStatus
0x4
RW
32
ReloadValue
0x8
R
32
Counter
•
Bit specification
The ControlStatus  register contains the bitfields, as shown in the following table.
Table 92: ControlStatus Bit Specification
Bits
Type
Name
[31:6]
Reserved
[5]
RW
InterruptStatus
[4]
RW
InterruptEnable
SystemC Modeling Library Reference Manual
X-2025.06-SP1
396</p>
</section>
<section id="page-397">
<h2>Page 397<a class="headerlink" href="#page-397" title="Permalink to this heading"></a></h2>
<p>Chapter 8: Modeling Guidelines
 
Bits
Type
Name
[3:2]
Reserved
[1]
RW
OneShot
[0]
RW
TimerEnable
SystemC Modeling Library Reference Manual
X-2025.06-SP1
397</p>
</section>
<section id="page-398">
<h2>Page 398<a class="headerlink" href="#page-398" title="Permalink to this heading"></a></h2>
<p>Index
A
adaptors, definition 91
Address Type. See AT 11
API, definition 11
Application Programmer’s Interface. See API 11
Approximately Timed. See AT 11
Architect’s View. See AV 11
architecture analysis use case 87
ASI TLM WG, definition 11
AT
description 88
AT, definition 11
AUTO_SYNCING callback 323
AV, definition 11
B
backdoor access, definition 326
bind() function
scml_clock_counter 223
scml_divided_clock 217, 217
bitfield
get_description() method 59
get_name() method 59
get_offset() method 59
get_register() method 59
get_size() method 59
has_default_debug_read_behavior() method 59
has_default_debug_write_behavior() method 59
has_default_read_behavior() method 59
has_default_read_restriction() method 59
has_default_write_behavior() method 59
has_default_write_restriction() method 59
has_never_syncing_read_behavior() method 59
has_never_syncing_write_behavior() method 59
is_dmi_read_allowed() method 59
is_dmi_write_allowed() method 59
set_debug_callback() method 63
set_debug_read_callback() method 63
set_debug_write_callback() method 63
set_description method 59
set_post_write_callback method 62
set_read_callback() method 62
set_read_no_store_callback() method 62
set_write_callback() method 62
bitfield_debug_read_callback_base 76
bitfield_debug_write_callback_base 76
bitfield_read_callback_base 75
bitfield_write_callback_base 75
C
cache, modeling 384
callback base classes 74
callbacks
AUTO_SYNCING 323
NEVER_SYNCING 324
SELF_SYNCING 323
types 321
clock objects 211
example 242
clocks, definition 92
coding style guidelines 310
coding styles
AT 88
LT 88
commands, definition 93
communication components, in virtual prototype 303
Compute Express Link. See CXL 11
CXL, definition 11
D
Data processing, in virtual prototype 303
Data Type. See DT 11
data_type() function 223
debugging quantum effects 320
Direct Memory Access. See DMA 11
disable() function 214
disabled() function 214
DMA
modeling 376
DMA, definition 11
DMI
definition 92, 326
398</p>
</section>
<section id="page-399">
<h2>Page 399<a class="headerlink" href="#page-399" title="Permalink to this heading"></a></h2>
<p>infrastructure 314
dmi_handler 252
disable_dmi() method 253
enable_dmi() method 253
invalidate_direct_mem_ptr() method 254
is_dmi_enabled() method 253
read_debug() method 253
read() method 253
set_interface() method 253
transport_debug() method 254
transport() method 254
write() method 253
DT, definition 11
E
embedded software development use case 85
enable() function 214
event() function 216
examples
modeling a cache 384
modeling a DMA 376
modeling a memory 339
modeling a watchdog peripheral 359
modeling an interrupt controller 346
External interfaces, in virtual prototype 302
F
FIFO, definition 11
First In First Out. See FIFO 11
functional specification use case 87
G
get_count() function 223
get_divider() function 217
get_duty_cycle() function 214
get_period_multiplier() function 214
get_period() function 214
get_posedge_first() function 214
get_start_time() function 214
getBoolProperty() function
scml_property_registry 267
scml_property_server_if 268
scml_simple_property_server 270
getDoubleProperty() function
scml_property_registry 267
scml_property_server_if 268
scml_simple_property_server 270
getIntProperty() function
scml_property_registry 267
scml_property_server_if 268
scml_simple_property_server 270
getName() function 265
getStringProperty() function
scml_property_registry 267
scml_property_server_if 268
scml_simple_property_server 270
getting started 339
getType() function 265
getUIntProperty() function
scml_property_server_if 268
scml_simple_property_server 270
H
hardware verification use case 87
I
initiator_socket 254
b_transport() method 256
disable_dmi() method 255
enable_dmi() method 255
get_local_time() method 254
inc() method 254
is_dmi_enabled() method 255
need_sync() method 254
read_debug() method 256
read() method 255
set_endianness() method 255
set_quantumkeeper() method 254
set() method 254
sync() method 254
transport_dbg() method 256
write_debug() method 256
write() method 255
Intellectual Property. See IP 11
interconnect, in virtual prototype 302
interfaces
blocking 91
definition 91
nonblocking 91
interrupt controller, modeling 346
IP, definition 11
399</p>
</section>
<section id="page-400">
<h2>Page 400<a class="headerlink" href="#page-400" title="Permalink to this heading"></a></h2>
<p>L
load() function 269
logging, definition 93
Loosely Timed. See LT 11
LT
description 88
LT, definition 11
M
mappable_if 73
b_transport() method 74
get_direct_mem_ptr() method 74
get_mapped_name() method 73
register_bw_direct_mem_if() method 73
transport_dbg() method 74
unregister_bw_direct_mem_if() method 73
memory
definition 92
in virtual prototype 302
memory_debug_callback_base 74
memory_index_reference 72
put_debug() method 72
put() method 72
memory-mapped components, in virtual prototype 302
memory, modeling 339
methods, definition 92
modeling a cache, example 384
modeling a DMA, example 376
modeling a memory, example 339
modeling a watchdog peripheral,example 359
modeling an interrupt controller, example 346
modeling guidelines
communication 308
model only what you need 305
modeling behavior 306
modeling for speed 305
SCML-related coding guidelines 310
timing and synchronization 308
modeling methodology guidelines 304
modeling objects
combining 93
concepts 91
modules, definition 91
N
negedge_event() function 216
negedge() function 216
NEVER_SYNCING callback 324
O
operator() function
scml_clock_counter 223
scml_divided_clock 217, 217
optimizing simulation speed, strategies 324
original clock period, definition 217
overview
Storage Modeling Objects 18
Utility Objects 22
P
Payload-event-queue, definition 93
payload, definition 91
PCI Express, definition 11
Peripheral Component Interconnect Express. See PCI
Express 11
phases, definition 91
pins, definition 91
Plain Old Data Type. See PODT 11
Platform synchronization, in virtual prototype 303
PODT, definition 11
posedge_event() function 216
posedge() function 216
processor model, in virtual prototype 302
Programmer’s View. See PV 11
properties, definition 93
Protocol Checker 185, 197
Pulse Width Modulation. See PWM 11
PV
definition 11
PWM
definition 11
Q
quantum
debugging quantum effects 320
definition 316
dynamic adjustment 316
R
read() function 223
register_observer() function 215
400</p>
</section>
<section id="page-401">
<h2>Page 401<a class="headerlink" href="#page-401" title="Permalink to this heading"></a></h2>
<p>router
b_transport method 68
disable_dmi() method 66
enable_dmi() method 66
get_description() method 66
get_direct_mem_ptr method 68
get_name() method 66
get_offset() method 66
get_size() method 66
get_width() method 66
is_dmi_enabled() method 66
map_read() method 67
map_write() method 67
map() method 67
set_callback() function 71
set_debug_callback function 71
set_description method 66
transport_dbg method 68
unmap_all() method 68
unmap_read() method 68
unmap_write() method 68
unmap() method 68
router peripherals, modeling 321
router_callback_base 75
router_debug_callback_base 75
router, definition 92
running() function 215
S
SCML
modeling guidelines 304
purpose 83, 304
SCML callback levels 321
SCML modeling, introducing
Introduction to SCML FT Modeling 83
Virtual Prototype Model Content 304
scml_clock_counter 223
scml_command_processor 259
scml_loader 262
SCML1, definition 11
SCML2, definition 11
SELF_SYNCING callback 323
set_duty_cycle() function 214
set_period_multiplier() function 214
set_period() function 214
set_posedge_first() function 214
set_start_time() function 214
setCustomPropertyServer() function 267
simulation modes
Optimizing Simulation Performance 325
simulation speed, strategies for optimizing 324
Socket Transaction Language. See STL 11
sockets, definition 91
status 271
status, definition 93
STL, definition 11
Subsystems, in virtual prototype 303
synchronization
and temporal decoupling 315
synchronizing behavior 317
SystemC Modeling Library 1. See SCML1 11
SystemC Modeling Library 2. See SCML2 11
T
target peripherals, modeling 321
temporal decoupling
and synchronization 315
definition 92, 315, 326
examples 318
multiprocessor example 318
threads, definition 92
time, definition 92
TLM
description 84
TLM, definition 12
tlm2_gp_initiator_adapter 82
tlm2_gp_target_adapter 80
operator() method 81
transaction payload 308
Transaction-Level Modeling. See TLM 12
transactor, definition 91
U
unregister_observer() function 215
use cases 85
V
value_changed_event() function 216
Virtual Processing Unit. See VPU 12
virtual prototypes
components 301
requirements 300
401</p>
</section>
<section id="page-402">
<h2>Page 402<a class="headerlink" href="#page-402" title="Permalink to this heading"></a></h2>
<p>VPU, definition 12
W
watchdog peripheral, modeling 359
write() function 223
402</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, SystemC Modeling Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>